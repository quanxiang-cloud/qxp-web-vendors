System.register([], (function (exports) {
  'use strict';
  return {
    execute: (function () {

      exports({
        compose: compose,
        composeK: composeK,
        composeP: composeP,
        pipe: pipe,
        pipeK: pipeK,
        pipeP: pipeP
      });

      /**
       * A function that always returns `false`. Any passed in parameters are ignored.
       *
       * @func
       * @memberOf R
       * @since v0.9.0
       * @category Function
       * @sig * -> Boolean
       * @param {*}
       * @return {Boolean}
       * @see R.T
       * @example
       *
       *      R.F(); //=> false
       */
      var F = function () {
        return false;
      };

      var F$1 = exports('F', F);

      /**
       * A function that always returns `true`. Any passed in parameters are ignored.
       *
       * @func
       * @memberOf R
       * @since v0.9.0
       * @category Function
       * @sig * -> Boolean
       * @param {*}
       * @return {Boolean}
       * @see R.F
       * @example
       *
       *      R.T(); //=> true
       */
      var T = function () {
        return true;
      };

      var T$1 = exports('T', T);

      /**
       * A special placeholder value used to specify "gaps" within curried functions,
       * allowing partial application of any combination of arguments, regardless of
       * their positions.
       *
       * If `g` is a curried ternary function and `_` is `R.__`, the following are
       * equivalent:
       *
       *   - `g(1, 2, 3)`
       *   - `g(_, 2, 3)(1)`
       *   - `g(_, _, 3)(1)(2)`
       *   - `g(_, _, 3)(1, 2)`
       *   - `g(_, 2, _)(1, 3)`
       *   - `g(_, 2)(1)(3)`
       *   - `g(_, 2)(1, 3)`
       *   - `g(_, 2)(_, 3)(1)`
       *
       * @name __
       * @constant
       * @memberOf R
       * @since v0.6.0
       * @category Function
       * @example
       *
       *      const greet = R.replace('{name}', R.__, 'Hello, {name}!');
       *      greet('Alice'); //=> 'Hello, Alice!'
       */
      var __ = exports('__', {
        '@@functional/placeholder': true
      });

      function _isPlaceholder(a) {
        return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
      }

      /**
       * Optimized internal one-arity curry function.
       *
       * @private
       * @category Function
       * @param {Function} fn The function to curry.
       * @return {Function} The curried function.
       */

      function _curry1(fn) {
        return function f1(a) {
          if (arguments.length === 0 || _isPlaceholder(a)) {
            return f1;
          } else {
            return fn.apply(this, arguments);
          }
        };
      }

      /**
       * Optimized internal two-arity curry function.
       *
       * @private
       * @category Function
       * @param {Function} fn The function to curry.
       * @return {Function} The curried function.
       */

      function _curry2(fn) {
        return function f2(a, b) {
          switch (arguments.length) {
            case 0:
              return f2;

            case 1:
              return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
                return fn(a, _b);
              });

            default:
              return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
                return fn(_a, b);
              }) : _isPlaceholder(b) ? _curry1(function (_b) {
                return fn(a, _b);
              }) : fn(a, b);
          }
        };
      }

      /**
       * Adds two values.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Math
       * @sig Number -> Number -> Number
       * @param {Number} a
       * @param {Number} b
       * @return {Number}
       * @see R.subtract
       * @example
       *
       *      R.add(2, 3);       //=>  5
       *      R.add(7)(10);      //=> 17
       */

      var add =
      /*#__PURE__*/
      _curry2(function add(a, b) {
        return Number(a) + Number(b);
      });

      var add$1 = exports('add', add);

      /**
       * Private `concat` function to merge two array-like objects.
       *
       * @private
       * @param {Array|Arguments} [set1=[]] An array-like object.
       * @param {Array|Arguments} [set2=[]] An array-like object.
       * @return {Array} A new, merged array.
       * @example
       *
       *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
       */
      function _concat(set1, set2) {
        set1 = set1 || [];
        set2 = set2 || [];
        var idx;
        var len1 = set1.length;
        var len2 = set2.length;
        var result = [];
        idx = 0;

        while (idx < len1) {
          result[result.length] = set1[idx];
          idx += 1;
        }

        idx = 0;

        while (idx < len2) {
          result[result.length] = set2[idx];
          idx += 1;
        }

        return result;
      }

      function _arity(n, fn) {
        /* eslint-disable no-unused-vars */
        switch (n) {
          case 0:
            return function () {
              return fn.apply(this, arguments);
            };

          case 1:
            return function (a0) {
              return fn.apply(this, arguments);
            };

          case 2:
            return function (a0, a1) {
              return fn.apply(this, arguments);
            };

          case 3:
            return function (a0, a1, a2) {
              return fn.apply(this, arguments);
            };

          case 4:
            return function (a0, a1, a2, a3) {
              return fn.apply(this, arguments);
            };

          case 5:
            return function (a0, a1, a2, a3, a4) {
              return fn.apply(this, arguments);
            };

          case 6:
            return function (a0, a1, a2, a3, a4, a5) {
              return fn.apply(this, arguments);
            };

          case 7:
            return function (a0, a1, a2, a3, a4, a5, a6) {
              return fn.apply(this, arguments);
            };

          case 8:
            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
              return fn.apply(this, arguments);
            };

          case 9:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
              return fn.apply(this, arguments);
            };

          case 10:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
              return fn.apply(this, arguments);
            };

          default:
            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
        }
      }

      /**
       * Internal curryN function.
       *
       * @private
       * @category Function
       * @param {Number} length The arity of the curried function.
       * @param {Array} received An array of arguments received thus far.
       * @param {Function} fn The function to curry.
       * @return {Function} The curried function.
       */

      function _curryN(length, received, fn) {
        return function () {
          var combined = [];
          var argsIdx = 0;
          var left = length;
          var combinedIdx = 0;

          while (combinedIdx < received.length || argsIdx < arguments.length) {
            var result;

            if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
              result = received[combinedIdx];
            } else {
              result = arguments[argsIdx];
              argsIdx += 1;
            }

            combined[combinedIdx] = result;

            if (!_isPlaceholder(result)) {
              left -= 1;
            }

            combinedIdx += 1;
          }

          return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
        };
      }

      /**
       * Returns a curried equivalent of the provided function, with the specified
       * arity. The curried function has two unusual capabilities. First, its
       * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
       * following are equivalent:
       *
       *   - `g(1)(2)(3)`
       *   - `g(1)(2, 3)`
       *   - `g(1, 2)(3)`
       *   - `g(1, 2, 3)`
       *
       * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
       * "gaps", allowing partial application of any combination of arguments,
       * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
       * the following are equivalent:
       *
       *   - `g(1, 2, 3)`
       *   - `g(_, 2, 3)(1)`
       *   - `g(_, _, 3)(1)(2)`
       *   - `g(_, _, 3)(1, 2)`
       *   - `g(_, 2)(1)(3)`
       *   - `g(_, 2)(1, 3)`
       *   - `g(_, 2)(_, 3)(1)`
       *
       * @func
       * @memberOf R
       * @since v0.5.0
       * @category Function
       * @sig Number -> (* -> a) -> (* -> a)
       * @param {Number} length The arity for the returned function.
       * @param {Function} fn The function to curry.
       * @return {Function} A new, curried function.
       * @see R.curry
       * @example
       *
       *      const sumArgs = (...args) => R.sum(args);
       *
       *      const curriedAddFourNumbers = R.curryN(4, sumArgs);
       *      const f = curriedAddFourNumbers(1, 2);
       *      const g = f(3);
       *      g(4); //=> 10
       */

      var curryN =
      /*#__PURE__*/
      _curry2(function curryN(length, fn) {
        if (length === 1) {
          return _curry1(fn);
        }

        return _arity(length, _curryN(length, [], fn));
      });

      var curryN$1 = exports('curryN', curryN);

      /**
       * Creates a new list iteration function from an existing one by adding two new
       * parameters to its callback function: the current index, and the entire list.
       *
       * This would turn, for instance, [`R.map`](#map) function into one that
       * more closely resembles `Array.prototype.map`. Note that this will only work
       * for functions in which the iteration callback function is the first
       * parameter, and where the list is the last parameter. (This latter might be
       * unimportant if the list parameter is not used.)
       *
       * @func
       * @memberOf R
       * @since v0.15.0
       * @category Function
       * @category List
       * @sig ((a ... -> b) ... -> [a] -> *) -> ((a ..., Int, [a] -> b) ... -> [a] -> *)
       * @param {Function} fn A list iteration function that does not pass index or list to its callback
       * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
       * @example
       *
       *      const mapIndexed = R.addIndex(R.map);
       *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
       *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
       */

      var addIndex =
      /*#__PURE__*/
      _curry1(function addIndex(fn) {
        return curryN$1(fn.length, function () {
          var idx = 0;
          var origFn = arguments[0];
          var list = arguments[arguments.length - 1];
          var args = Array.prototype.slice.call(arguments, 0);

          args[0] = function () {
            var result = origFn.apply(this, _concat(arguments, [idx, list]));
            idx += 1;
            return result;
          };

          return fn.apply(this, args);
        });
      });

      var addIndex$1 = exports('addIndex', addIndex);

      /**
       * Optimized internal three-arity curry function.
       *
       * @private
       * @category Function
       * @param {Function} fn The function to curry.
       * @return {Function} The curried function.
       */

      function _curry3(fn) {
        return function f3(a, b, c) {
          switch (arguments.length) {
            case 0:
              return f3;

            case 1:
              return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
                return fn(a, _b, _c);
              });

            case 2:
              return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
                return fn(_a, b, _c);
              }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
                return fn(a, _b, _c);
              }) : _curry1(function (_c) {
                return fn(a, b, _c);
              });

            default:
              return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
                return fn(_a, _b, c);
              }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
                return fn(_a, b, _c);
              }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
                return fn(a, _b, _c);
              }) : _isPlaceholder(a) ? _curry1(function (_a) {
                return fn(_a, b, c);
              }) : _isPlaceholder(b) ? _curry1(function (_b) {
                return fn(a, _b, c);
              }) : _isPlaceholder(c) ? _curry1(function (_c) {
                return fn(a, b, _c);
              }) : fn(a, b, c);
          }
        };
      }

      /**
       * Applies a function to the value at the given index of an array, returning a
       * new copy of the array with the element at the given index replaced with the
       * result of the function application.
       *
       * @func
       * @memberOf R
       * @since v0.14.0
       * @category List
       * @sig Number -> (a -> a) -> [a] -> [a]
       * @param {Number} idx The index.
       * @param {Function} fn The function to apply.
       * @param {Array|Arguments} list An array-like object whose value
       *        at the supplied index will be replaced.
       * @return {Array} A copy of the supplied array-like object with
       *         the element at index `idx` replaced with the value
       *         returned by applying `fn` to the existing element.
       * @see R.update
       * @example
       *
       *      R.adjust(1, R.toUpper, ['a', 'b', 'c', 'd']);      //=> ['a', 'B', 'c', 'd']
       *      R.adjust(-1, R.toUpper, ['a', 'b', 'c', 'd']);     //=> ['a', 'b', 'c', 'D']
       * @symb R.adjust(-1, f, [a, b]) = [a, f(b)]
       * @symb R.adjust(0, f, [a, b]) = [f(a), b]
       */

      var adjust =
      /*#__PURE__*/
      _curry3(function adjust(idx, fn, list) {
        if (idx >= list.length || idx < -list.length) {
          return list;
        }

        var start = idx < 0 ? list.length : 0;

        var _idx = start + idx;

        var _list = _concat(list);

        _list[_idx] = fn(list[_idx]);
        return _list;
      });

      var adjust$1 = exports('adjust', adjust);

      /**
       * Tests whether or not an object is an array.
       *
       * @private
       * @param {*} val The object to test.
       * @return {Boolean} `true` if `val` is an array, `false` otherwise.
       * @example
       *
       *      _isArray([]); //=> true
       *      _isArray(null); //=> false
       *      _isArray({}); //=> false
       */
      var _isArray = Array.isArray || function _isArray(val) {
        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
      };

      function _isTransformer(obj) {
        return obj != null && typeof obj['@@transducer/step'] === 'function';
      }

      /**
       * Returns a function that dispatches with different strategies based on the
       * object in list position (last argument). If it is an array, executes [fn].
       * Otherwise, if it has a function with one of the given method names, it will
       * execute that function (functor case). Otherwise, if it is a transformer,
       * uses transducer [xf] to return a new transformer (transducer case).
       * Otherwise, it will default to executing [fn].
       *
       * @private
       * @param {Array} methodNames properties to check for a custom implementation
       * @param {Function} xf transducer to initialize if object is transformer
       * @param {Function} fn default ramda implementation
       * @return {Function} A function that dispatches on object in list position
       */

      function _dispatchable(methodNames, xf, fn) {
        return function () {
          if (arguments.length === 0) {
            return fn();
          }

          var args = Array.prototype.slice.call(arguments, 0);
          var obj = args.pop();

          if (!_isArray(obj)) {
            var idx = 0;

            while (idx < methodNames.length) {
              if (typeof obj[methodNames[idx]] === 'function') {
                return obj[methodNames[idx]].apply(obj, args);
              }

              idx += 1;
            }

            if (_isTransformer(obj)) {
              var transducer = xf.apply(null, args);
              return transducer(obj);
            }
          }

          return fn.apply(this, arguments);
        };
      }

      function _reduced(x) {
        return x && x['@@transducer/reduced'] ? x : {
          '@@transducer/value': x,
          '@@transducer/reduced': true
        };
      }

      var _xfBase = {
        init: function () {
          return this.xf['@@transducer/init']();
        },
        result: function (result) {
          return this.xf['@@transducer/result'](result);
        }
      };

      var XAll =
      /*#__PURE__*/
      function () {
        function XAll(f, xf) {
          this.xf = xf;
          this.f = f;
          this.all = true;
        }

        XAll.prototype['@@transducer/init'] = _xfBase.init;

        XAll.prototype['@@transducer/result'] = function (result) {
          if (this.all) {
            result = this.xf['@@transducer/step'](result, true);
          }

          return this.xf['@@transducer/result'](result);
        };

        XAll.prototype['@@transducer/step'] = function (result, input) {
          if (!this.f(input)) {
            this.all = false;
            result = _reduced(this.xf['@@transducer/step'](result, false));
          }

          return result;
        };

        return XAll;
      }();

      var _xall =
      /*#__PURE__*/
      _curry2(function _xall(f, xf) {
        return new XAll(f, xf);
      });

      var _xall$1 = _xall;

      /**
       * Returns `true` if all elements of the list match the predicate, `false` if
       * there are any that don't.
       *
       * Dispatches to the `all` method of the second argument, if present.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig (a -> Boolean) -> [a] -> Boolean
       * @param {Function} fn The predicate function.
       * @param {Array} list The array to consider.
       * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
       *         otherwise.
       * @see R.any, R.none, R.transduce
       * @example
       *
       *      const equals3 = R.equals(3);
       *      R.all(equals3)([3, 3, 3, 3]); //=> true
       *      R.all(equals3)([3, 3, 1, 3]); //=> false
       */

      var all =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _dispatchable(['all'], _xall$1, function all(fn, list) {
        var idx = 0;

        while (idx < list.length) {
          if (!fn(list[idx])) {
            return false;
          }

          idx += 1;
        }

        return true;
      }));

      var all$1 = exports('all', all);

      /**
       * Returns the larger of its two arguments.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Relation
       * @sig Ord a => a -> a -> a
       * @param {*} a
       * @param {*} b
       * @return {*}
       * @see R.maxBy, R.min
       * @example
       *
       *      R.max(789, 123); //=> 789
       *      R.max('a', 'b'); //=> 'b'
       */

      var max =
      /*#__PURE__*/
      _curry2(function max(a, b) {
        return b > a ? b : a;
      });

      var max$1 = exports('max', max);

      function _map(fn, functor) {
        var idx = 0;
        var len = functor.length;
        var result = Array(len);

        while (idx < len) {
          result[idx] = fn(functor[idx]);
          idx += 1;
        }

        return result;
      }

      function _isString(x) {
        return Object.prototype.toString.call(x) === '[object String]';
      }

      /**
       * Tests whether or not an object is similar to an array.
       *
       * @private
       * @category Type
       * @category List
       * @sig * -> Boolean
       * @param {*} x The object to test.
       * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
       * @example
       *
       *      _isArrayLike([]); //=> true
       *      _isArrayLike(true); //=> false
       *      _isArrayLike({}); //=> false
       *      _isArrayLike({length: 10}); //=> false
       *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
       */

      var _isArrayLike =
      /*#__PURE__*/
      _curry1(function isArrayLike(x) {
        if (_isArray(x)) {
          return true;
        }

        if (!x) {
          return false;
        }

        if (typeof x !== 'object') {
          return false;
        }

        if (_isString(x)) {
          return false;
        }

        if (x.nodeType === 1) {
          return !!x.length;
        }

        if (x.length === 0) {
          return true;
        }

        if (x.length > 0) {
          return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
        }

        return false;
      });

      var _isArrayLike$1 = _isArrayLike;

      var XWrap =
      /*#__PURE__*/
      function () {
        function XWrap(fn) {
          this.f = fn;
        }

        XWrap.prototype['@@transducer/init'] = function () {
          throw new Error('init not implemented on XWrap');
        };

        XWrap.prototype['@@transducer/result'] = function (acc) {
          return acc;
        };

        XWrap.prototype['@@transducer/step'] = function (acc, x) {
          return this.f(acc, x);
        };

        return XWrap;
      }();

      function _xwrap(fn) {
        return new XWrap(fn);
      }

      /**
       * Creates a function that is bound to a context.
       * Note: `R.bind` does not provide the additional argument-binding capabilities of
       * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
       *
       * @func
       * @memberOf R
       * @since v0.6.0
       * @category Function
       * @category Object
       * @sig (* -> *) -> {*} -> (* -> *)
       * @param {Function} fn The function to bind to context
       * @param {Object} thisObj The context to bind `fn` to
       * @return {Function} A function that will execute in the context of `thisObj`.
       * @see R.partial
       * @example
       *
       *      const log = R.bind(console.log, console);
       *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
       *      // logs {a: 2}
       * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
       */

      var bind =
      /*#__PURE__*/
      _curry2(function bind(fn, thisObj) {
        return _arity(fn.length, function () {
          return fn.apply(thisObj, arguments);
        });
      });

      var bind$1 = exports('bind', bind);

      function _arrayReduce(xf, acc, list) {
        var idx = 0;
        var len = list.length;

        while (idx < len) {
          acc = xf['@@transducer/step'](acc, list[idx]);

          if (acc && acc['@@transducer/reduced']) {
            acc = acc['@@transducer/value'];
            break;
          }

          idx += 1;
        }

        return xf['@@transducer/result'](acc);
      }

      function _iterableReduce(xf, acc, iter) {
        var step = iter.next();

        while (!step.done) {
          acc = xf['@@transducer/step'](acc, step.value);

          if (acc && acc['@@transducer/reduced']) {
            acc = acc['@@transducer/value'];
            break;
          }

          step = iter.next();
        }

        return xf['@@transducer/result'](acc);
      }

      function _methodReduce(xf, acc, obj, methodName) {
        return xf['@@transducer/result'](obj[methodName](bind$1(xf['@@transducer/step'], xf), acc));
      }

      var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
      function _reduce(fn, acc, list) {
        if (typeof fn === 'function') {
          fn = _xwrap(fn);
        }

        if (_isArrayLike$1(list)) {
          return _arrayReduce(fn, acc, list);
        }

        if (typeof list['fantasy-land/reduce'] === 'function') {
          return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
        }

        if (list[symIterator] != null) {
          return _iterableReduce(fn, acc, list[symIterator]());
        }

        if (typeof list.next === 'function') {
          return _iterableReduce(fn, acc, list);
        }

        if (typeof list.reduce === 'function') {
          return _methodReduce(fn, acc, list, 'reduce');
        }

        throw new TypeError('reduce: list must be array or iterable');
      }

      var XMap =
      /*#__PURE__*/
      function () {
        function XMap(f, xf) {
          this.xf = xf;
          this.f = f;
        }

        XMap.prototype['@@transducer/init'] = _xfBase.init;
        XMap.prototype['@@transducer/result'] = _xfBase.result;

        XMap.prototype['@@transducer/step'] = function (result, input) {
          return this.xf['@@transducer/step'](result, this.f(input));
        };

        return XMap;
      }();

      var _xmap =
      /*#__PURE__*/
      _curry2(function _xmap(f, xf) {
        return new XMap(f, xf);
      });

      var _xmap$1 = _xmap;

      function _has(prop, obj) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }

      var toString$2 = Object.prototype.toString;

      var _isArguments =
      /*#__PURE__*/
      function () {
        return toString$2.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
          return toString$2.call(x) === '[object Arguments]';
        } : function _isArguments(x) {
          return _has('callee', x);
        };
      }();

      var _isArguments$1 = _isArguments;

      var hasEnumBug = !
      /*#__PURE__*/
      {
        toString: null
      }.propertyIsEnumerable('toString');
      var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']; // Safari bug

      var hasArgsEnumBug =
      /*#__PURE__*/
      function () {

        return arguments.propertyIsEnumerable('length');
      }();

      var contains$2 = function contains(list, item) {
        var idx = 0;

        while (idx < list.length) {
          if (list[idx] === item) {
            return true;
          }

          idx += 1;
        }

        return false;
      };
      /**
       * Returns a list containing the names of all the enumerable own properties of
       * the supplied object.
       * Note that the order of the output array is not guaranteed to be consistent
       * across different JS platforms.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Object
       * @sig {k: v} -> [k]
       * @param {Object} obj The object to extract properties from
       * @return {Array} An array of the object's own properties.
       * @see R.keysIn, R.values
       * @example
       *
       *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
       */


      var keys = typeof Object.keys === 'function' && !hasArgsEnumBug ?
      /*#__PURE__*/
      _curry1(function keys(obj) {
        return Object(obj) !== obj ? [] : Object.keys(obj);
      }) :
      /*#__PURE__*/
      _curry1(function keys(obj) {
        if (Object(obj) !== obj) {
          return [];
        }

        var prop, nIdx;
        var ks = [];

        var checkArgsLength = hasArgsEnumBug && _isArguments$1(obj);

        for (prop in obj) {
          if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
            ks[ks.length] = prop;
          }
        }

        if (hasEnumBug) {
          nIdx = nonEnumerableProps.length - 1;

          while (nIdx >= 0) {
            prop = nonEnumerableProps[nIdx];

            if (_has(prop, obj) && !contains$2(ks, prop)) {
              ks[ks.length] = prop;
            }

            nIdx -= 1;
          }
        }

        return ks;
      });
      var keys$1 = exports('keys', keys);

      /**
       * Takes a function and
       * a [functor](https://github.com/fantasyland/fantasy-land#functor),
       * applies the function to each of the functor's values, and returns
       * a functor of the same shape.
       *
       * Ramda provides suitable `map` implementations for `Array` and `Object`,
       * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
       *
       * Dispatches to the `map` method of the second argument, if present.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * Also treats functions as functors and will compose them together.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig Functor f => (a -> b) -> f a -> f b
       * @param {Function} fn The function to be called on every element of the input `list`.
       * @param {Array} list The list to be iterated over.
       * @return {Array} The new list.
       * @see R.transduce, R.addIndex
       * @example
       *
       *      const double = x => x * 2;
       *
       *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
       *
       *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
       * @symb R.map(f, [a, b]) = [f(a), f(b)]
       * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }
       * @symb R.map(f, functor_o) = functor_o.map(f)
       */

      var map =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _dispatchable(['fantasy-land/map', 'map'], _xmap$1, function map(fn, functor) {
        switch (Object.prototype.toString.call(functor)) {
          case '[object Function]':
            return curryN$1(functor.length, function () {
              return fn.call(this, functor.apply(this, arguments));
            });

          case '[object Object]':
            return _reduce(function (acc, key) {
              acc[key] = fn(functor[key]);
              return acc;
            }, {}, keys$1(functor));

          default:
            return _map(fn, functor);
        }
      }));

      var map$1 = exports('map', map);

      /**
       * Determine if the passed argument is an integer.
       *
       * @private
       * @param {*} n
       * @category Type
       * @return {Boolean}
       */
      var _isInteger = Number.isInteger || function _isInteger(n) {
        return n << 0 === n;
      };

      /**
       * Returns the nth element of the given list or string. If n is negative the
       * element at index length + n is returned.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig Number -> [a] -> a | Undefined
       * @sig Number -> String -> String
       * @param {Number} offset
       * @param {*} list
       * @return {*}
       * @example
       *
       *      const list = ['foo', 'bar', 'baz', 'quux'];
       *      R.nth(1, list); //=> 'bar'
       *      R.nth(-1, list); //=> 'quux'
       *      R.nth(-99, list); //=> undefined
       *
       *      R.nth(2, 'abc'); //=> 'c'
       *      R.nth(3, 'abc'); //=> ''
       * @symb R.nth(-1, [a, b, c]) = c
       * @symb R.nth(0, [a, b, c]) = a
       * @symb R.nth(1, [a, b, c]) = b
       */

      var nth =
      /*#__PURE__*/
      _curry2(function nth(offset, list) {
        var idx = offset < 0 ? list.length + offset : offset;
        return _isString(list) ? list.charAt(idx) : list[idx];
      });

      var nth$1 = exports('nth', nth);

      /**
       * Retrieves the values at given paths of an object.
       *
       * @func
       * @memberOf R
       * @since v0.27.1
       * @category Object
       * @typedefn Idx = [String | Int]
       * @sig [Idx] -> {a} -> [a | Undefined]
       * @param {Array} pathsArray The array of paths to be fetched.
       * @param {Object} obj The object to retrieve the nested properties from.
       * @return {Array} A list consisting of values at paths specified by "pathsArray".
       * @see R.path
       * @example
       *
       *      R.paths([['a', 'b'], ['p', 0, 'q']], {a: {b: 2}, p: [{q: 3}]}); //=> [2, 3]
       *      R.paths([['a', 'b'], ['p', 'r']], {a: {b: 2}, p: [{q: 3}]}); //=> [2, undefined]
       */

      var paths =
      /*#__PURE__*/
      _curry2(function paths(pathsArray, obj) {
        return pathsArray.map(function (paths) {
          var val = obj;
          var idx = 0;
          var p;

          while (idx < paths.length) {
            if (val == null) {
              return;
            }

            p = paths[idx];
            val = _isInteger(p) ? nth$1(p, val) : val[p];
            idx += 1;
          }

          return val;
        });
      });

      var paths$1 = exports('paths', paths);

      /**
       * Retrieve the value at a given path.
       *
       * @func
       * @memberOf R
       * @since v0.2.0
       * @category Object
       * @typedefn Idx = String | Int
       * @sig [Idx] -> {a} -> a | Undefined
       * @param {Array} path The path to use.
       * @param {Object} obj The object to retrieve the nested property from.
       * @return {*} The data at `path`.
       * @see R.prop, R.nth
       * @example
       *
       *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
       *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
       *      R.path(['a', 'b', 0], {a: {b: [1, 2, 3]}}); //=> 1
       *      R.path(['a', 'b', -2], {a: {b: [1, 2, 3]}}); //=> 2
       */

      var path =
      /*#__PURE__*/
      _curry2(function path(pathAr, obj) {
        return paths$1([pathAr], obj)[0];
      });

      var path$1 = exports('path', path);

      /**
       * Returns a function that when supplied an object returns the indicated
       * property of that object, if it exists.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Object
       * @typedefn Idx = String | Int
       * @sig Idx -> {s: a} -> a | Undefined
       * @param {String|Number} p The property name or array index
       * @param {Object} obj The object to query
       * @return {*} The value at `obj.p`.
       * @see R.path, R.nth
       * @example
       *
       *      R.prop('x', {x: 100}); //=> 100
       *      R.prop('x', {}); //=> undefined
       *      R.prop(0, [100]); //=> 100
       *      R.compose(R.inc, R.prop('x'))({ x: 3 }) //=> 4
       */

      var prop =
      /*#__PURE__*/
      _curry2(function prop(p, obj) {
        return path$1([p], obj);
      });

      var prop$1 = exports('prop', prop);

      /**
       * Returns a new list by plucking the same named property off all objects in
       * the list supplied.
       *
       * `pluck` will work on
       * any [functor](https://github.com/fantasyland/fantasy-land#functor) in
       * addition to arrays, as it is equivalent to `R.map(R.prop(k), f)`.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig Functor f => k -> f {k: v} -> f v
       * @param {Number|String} key The key name to pluck off of each object.
       * @param {Array} f The array or functor to consider.
       * @return {Array} The list of values for the given key.
       * @see R.props
       * @example
       *
       *      var getAges = R.pluck('age');
       *      getAges([{name: 'fred', age: 29}, {name: 'wilma', age: 27}]); //=> [29, 27]
       *
       *      R.pluck(0, [[1, 2], [3, 4]]);               //=> [1, 3]
       *      R.pluck('val', {a: {val: 3}, b: {val: 5}}); //=> {a: 3, b: 5}
       * @symb R.pluck('x', [{x: 1, y: 2}, {x: 3, y: 4}, {x: 5, y: 6}]) = [1, 3, 5]
       * @symb R.pluck(0, [[1, 2], [3, 4], [5, 6]]) = [1, 3, 5]
       */

      var pluck =
      /*#__PURE__*/
      _curry2(function pluck(p, list) {
        return map$1(prop$1(p), list);
      });

      var pluck$1 = exports('pluck', pluck);

      /**
       * Returns a single item by iterating through the list, successively calling
       * the iterator function and passing it an accumulator value and the current
       * value from the array, and then passing the result to the next call.
       *
       * The iterator function receives two values: *(acc, value)*. It may use
       * [`R.reduced`](#reduced) to shortcut the iteration.
       *
       * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function
       * is *(value, acc)*.
       *
       * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
       * arrays), unlike the native `Array.prototype.reduce` method. For more details
       * on this behavior, see:
       * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
       *
       * Dispatches to the `reduce` method of the third argument, if present. When
       * doing so, it is up to the user to handle the [`R.reduced`](#reduced)
       * shortcuting, as this is not implemented by `reduce`.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig ((a, b) -> a) -> a -> [b] -> a
       * @param {Function} fn The iterator function. Receives two values, the accumulator and the
       *        current element from the array.
       * @param {*} acc The accumulator value.
       * @param {Array} list The list to iterate over.
       * @return {*} The final, accumulated value.
       * @see R.reduced, R.addIndex, R.reduceRight
       * @example
       *
       *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
       *      //          -               -10
       *      //         / \              / \
       *      //        -   4           -6   4
       *      //       / \              / \
       *      //      -   3   ==>     -3   3
       *      //     / \              / \
       *      //    -   2           -1   2
       *      //   / \              / \
       *      //  0   1            0   1
       *
       * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
       */

      var reduce =
      /*#__PURE__*/
      _curry3(_reduce);

      var reduce$1 = exports('reduce', reduce);

      /**
       * Takes a list of predicates and returns a predicate that returns true for a
       * given list of arguments if every one of the provided predicates is satisfied
       * by those arguments.
       *
       * The function returned is a curried function whose arity matches that of the
       * highest-arity predicate.
       *
       * @func
       * @memberOf R
       * @since v0.9.0
       * @category Logic
       * @sig [(*... -> Boolean)] -> (*... -> Boolean)
       * @param {Array} predicates An array of predicates to check
       * @return {Function} The combined predicate
       * @see R.anyPass
       * @example
       *
       *      const isQueen = R.propEq('rank', 'Q');
       *      const isSpade = R.propEq('suit', '♠︎');
       *      const isQueenOfSpades = R.allPass([isQueen, isSpade]);
       *
       *      isQueenOfSpades({rank: 'Q', suit: '♣︎'}); //=> false
       *      isQueenOfSpades({rank: 'Q', suit: '♠︎'}); //=> true
       */

      var allPass =
      /*#__PURE__*/
      _curry1(function allPass(preds) {
        return curryN$1(reduce$1(max$1, 0, pluck$1('length', preds)), function () {
          var idx = 0;
          var len = preds.length;

          while (idx < len) {
            if (!preds[idx].apply(this, arguments)) {
              return false;
            }

            idx += 1;
          }

          return true;
        });
      });

      var allPass$1 = exports('allPass', allPass);

      /**
       * Returns a function that always returns the given value. Note that for
       * non-primitives the value returned is a reference to the original value.
       *
       * This function is known as `const`, `constant`, or `K` (for K combinator) in
       * other languages and libraries.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Function
       * @sig a -> (* -> a)
       * @param {*} val The value to wrap in a function
       * @return {Function} A Function :: * -> val.
       * @example
       *
       *      const t = R.always('Tee');
       *      t(); //=> 'Tee'
       */

      var always =
      /*#__PURE__*/
      _curry1(function always(val) {
        return function () {
          return val;
        };
      });

      var always$1 = exports('always', always);

      /**
       * Returns `true` if both arguments are `true`; `false` otherwise.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Logic
       * @sig a -> b -> a | b
       * @param {Any} a
       * @param {Any} b
       * @return {Any} the first argument if it is falsy, otherwise the second argument.
       * @see R.both, R.xor
       * @example
       *
       *      R.and(true, true); //=> true
       *      R.and(true, false); //=> false
       *      R.and(false, true); //=> false
       *      R.and(false, false); //=> false
       */

      var and =
      /*#__PURE__*/
      _curry2(function and(a, b) {
        return a && b;
      });

      var and$1 = exports('and', and);

      var XAny =
      /*#__PURE__*/
      function () {
        function XAny(f, xf) {
          this.xf = xf;
          this.f = f;
          this.any = false;
        }

        XAny.prototype['@@transducer/init'] = _xfBase.init;

        XAny.prototype['@@transducer/result'] = function (result) {
          if (!this.any) {
            result = this.xf['@@transducer/step'](result, false);
          }

          return this.xf['@@transducer/result'](result);
        };

        XAny.prototype['@@transducer/step'] = function (result, input) {
          if (this.f(input)) {
            this.any = true;
            result = _reduced(this.xf['@@transducer/step'](result, true));
          }

          return result;
        };

        return XAny;
      }();

      var _xany =
      /*#__PURE__*/
      _curry2(function _xany(f, xf) {
        return new XAny(f, xf);
      });

      var _xany$1 = _xany;

      /**
       * Returns `true` if at least one of the elements of the list match the predicate,
       * `false` otherwise.
       *
       * Dispatches to the `any` method of the second argument, if present.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig (a -> Boolean) -> [a] -> Boolean
       * @param {Function} fn The predicate function.
       * @param {Array} list The array to consider.
       * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
       *         otherwise.
       * @see R.all, R.none, R.transduce
       * @example
       *
       *      const lessThan0 = R.flip(R.lt)(0);
       *      const lessThan2 = R.flip(R.lt)(2);
       *      R.any(lessThan0)([1, 2]); //=> false
       *      R.any(lessThan2)([1, 2]); //=> true
       */

      var any =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _dispatchable(['any'], _xany$1, function any(fn, list) {
        var idx = 0;

        while (idx < list.length) {
          if (fn(list[idx])) {
            return true;
          }

          idx += 1;
        }

        return false;
      }));

      var any$1 = exports('any', any);

      /**
       * Takes a list of predicates and returns a predicate that returns true for a
       * given list of arguments if at least one of the provided predicates is
       * satisfied by those arguments.
       *
       * The function returned is a curried function whose arity matches that of the
       * highest-arity predicate.
       *
       * @func
       * @memberOf R
       * @since v0.9.0
       * @category Logic
       * @sig [(*... -> Boolean)] -> (*... -> Boolean)
       * @param {Array} predicates An array of predicates to check
       * @return {Function} The combined predicate
       * @see R.allPass
       * @example
       *
       *      const isClub = R.propEq('suit', '♣');
       *      const isSpade = R.propEq('suit', '♠');
       *      const isBlackCard = R.anyPass([isClub, isSpade]);
       *
       *      isBlackCard({rank: '10', suit: '♣'}); //=> true
       *      isBlackCard({rank: 'Q', suit: '♠'}); //=> true
       *      isBlackCard({rank: 'Q', suit: '♦'}); //=> false
       */

      var anyPass =
      /*#__PURE__*/
      _curry1(function anyPass(preds) {
        return curryN$1(reduce$1(max$1, 0, pluck$1('length', preds)), function () {
          var idx = 0;
          var len = preds.length;

          while (idx < len) {
            if (preds[idx].apply(this, arguments)) {
              return true;
            }

            idx += 1;
          }

          return false;
        });
      });

      var anyPass$1 = exports('anyPass', anyPass);

      /**
       * ap applies a list of functions to a list of values.
       *
       * Dispatches to the `ap` method of the second argument, if present. Also
       * treats curried functions as applicatives.
       *
       * @func
       * @memberOf R
       * @since v0.3.0
       * @category Function
       * @sig [a -> b] -> [a] -> [b]
       * @sig Apply f => f (a -> b) -> f a -> f b
       * @sig (r -> a -> b) -> (r -> a) -> (r -> b)
       * @param {*} applyF
       * @param {*} applyX
       * @return {*}
       * @example
       *
       *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
       *      R.ap([R.concat('tasty '), R.toUpper], ['pizza', 'salad']); //=> ["tasty pizza", "tasty salad", "PIZZA", "SALAD"]
       *
       *      // R.ap can also be used as S combinator
       *      // when only two functions are passed
       *      R.ap(R.concat, R.toUpper)('Ramda') //=> 'RamdaRAMDA'
       * @symb R.ap([f, g], [a, b]) = [f(a), f(b), g(a), g(b)]
       */

      var ap =
      /*#__PURE__*/
      _curry2(function ap(applyF, applyX) {
        return typeof applyX['fantasy-land/ap'] === 'function' ? applyX['fantasy-land/ap'](applyF) : typeof applyF.ap === 'function' ? applyF.ap(applyX) : typeof applyF === 'function' ? function (x) {
          return applyF(x)(applyX(x));
        } : _reduce(function (acc, f) {
          return _concat(acc, map$1(f, applyX));
        }, [], applyF);
      });

      var ap$1 = exports('ap', ap);

      function _aperture(n, list) {
        var idx = 0;
        var limit = list.length - (n - 1);
        var acc = new Array(limit >= 0 ? limit : 0);

        while (idx < limit) {
          acc[idx] = Array.prototype.slice.call(list, idx, idx + n);
          idx += 1;
        }

        return acc;
      }

      var XAperture =
      /*#__PURE__*/
      function () {
        function XAperture(n, xf) {
          this.xf = xf;
          this.pos = 0;
          this.full = false;
          this.acc = new Array(n);
        }

        XAperture.prototype['@@transducer/init'] = _xfBase.init;

        XAperture.prototype['@@transducer/result'] = function (result) {
          this.acc = null;
          return this.xf['@@transducer/result'](result);
        };

        XAperture.prototype['@@transducer/step'] = function (result, input) {
          this.store(input);
          return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
        };

        XAperture.prototype.store = function (input) {
          this.acc[this.pos] = input;
          this.pos += 1;

          if (this.pos === this.acc.length) {
            this.pos = 0;
            this.full = true;
          }
        };

        XAperture.prototype.getCopy = function () {
          return _concat(Array.prototype.slice.call(this.acc, this.pos), Array.prototype.slice.call(this.acc, 0, this.pos));
        };

        return XAperture;
      }();

      var _xaperture =
      /*#__PURE__*/
      _curry2(function _xaperture(n, xf) {
        return new XAperture(n, xf);
      });

      var _xaperture$1 = _xaperture;

      /**
       * Returns a new list, composed of n-tuples of consecutive elements. If `n` is
       * greater than the length of the list, an empty list is returned.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.12.0
       * @category List
       * @sig Number -> [a] -> [[a]]
       * @param {Number} n The size of the tuples to create
       * @param {Array} list The list to split into `n`-length tuples
       * @return {Array} The resulting list of `n`-length tuples
       * @see R.transduce
       * @example
       *
       *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
       *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
       *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
       */

      var aperture =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _dispatchable([], _xaperture$1, _aperture));

      var aperture$1 = exports('aperture', aperture);

      /**
       * Returns a new list containing the contents of the given list, followed by
       * the given element.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig a -> [a] -> [a]
       * @param {*} el The element to add to the end of the new list.
       * @param {Array} list The list of elements to add a new item to.
       *        list.
       * @return {Array} A new list containing the elements of the old list followed by `el`.
       * @see R.prepend
       * @example
       *
       *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
       *      R.append('tests', []); //=> ['tests']
       *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
       */

      var append =
      /*#__PURE__*/
      _curry2(function append(el, list) {
        return _concat(list, [el]);
      });

      var append$1 = exports('append', append);

      /**
       * Applies function `fn` to the argument list `args`. This is useful for
       * creating a fixed-arity function from a variadic function. `fn` should be a
       * bound function if context is significant.
       *
       * @func
       * @memberOf R
       * @since v0.7.0
       * @category Function
       * @sig (*... -> a) -> [*] -> a
       * @param {Function} fn The function which will be called with `args`
       * @param {Array} args The arguments to call `fn` with
       * @return {*} result The result, equivalent to `fn(...args)`
       * @see R.call, R.unapply
       * @example
       *
       *      const nums = [1, 2, 3, -99, 42, 6, 7];
       *      R.apply(Math.max, nums); //=> 42
       * @symb R.apply(f, [a, b, c]) = f(a, b, c)
       */

      var apply =
      /*#__PURE__*/
      _curry2(function apply(fn, args) {
        return fn.apply(this, args);
      });

      var apply$1 = exports('apply', apply);

      /**
       * Returns a list of all the enumerable own properties of the supplied object.
       * Note that the order of the output array is not guaranteed across different
       * JS platforms.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Object
       * @sig {k: v} -> [v]
       * @param {Object} obj The object to extract values from
       * @return {Array} An array of the values of the object's own properties.
       * @see R.valuesIn, R.keys
       * @example
       *
       *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
       */

      var values =
      /*#__PURE__*/
      _curry1(function values(obj) {
        var props = keys$1(obj);
        var len = props.length;
        var vals = [];
        var idx = 0;

        while (idx < len) {
          vals[idx] = obj[props[idx]];
          idx += 1;
        }

        return vals;
      });

      var values$1 = exports('values', values);

      // delegating calls to .map

      function mapValues(fn, obj) {
        return keys$1(obj).reduce(function (acc, key) {
          acc[key] = fn(obj[key]);
          return acc;
        }, {});
      }
      /**
       * Given a spec object recursively mapping properties to functions, creates a
       * function producing an object of the same structure, by mapping each property
       * to the result of calling its associated function with the supplied arguments.
       *
       * @func
       * @memberOf R
       * @since v0.20.0
       * @category Function
       * @sig {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})
       * @param {Object} spec an object recursively mapping properties to functions for
       *        producing the values for these properties.
       * @return {Function} A function that returns an object of the same structure
       * as `spec', with each property set to the value returned by calling its
       * associated function with the supplied arguments.
       * @see R.converge, R.juxt
       * @example
       *
       *      const getMetrics = R.applySpec({
       *        sum: R.add,
       *        nested: { mul: R.multiply }
       *      });
       *      getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
       * @symb R.applySpec({ x: f, y: { z: g } })(a, b) = { x: f(a, b), y: { z: g(a, b) } }
       */


      var applySpec =
      /*#__PURE__*/
      _curry1(function applySpec(spec) {
        spec = mapValues(function (v) {
          return typeof v == 'function' ? v : applySpec(v);
        }, spec);
        return curryN$1(reduce$1(max$1, 0, pluck$1('length', values$1(spec))), function () {
          var args = arguments;
          return mapValues(function (f) {
            return apply$1(f, args);
          }, spec);
        });
      });

      var applySpec$1 = exports('applySpec', applySpec);

      /**
       * Takes a value and applies a function to it.
       *
       * This function is also known as the `thrush` combinator.
       *
       * @func
       * @memberOf R
       * @since v0.25.0
       * @category Function
       * @sig a -> (a -> b) -> b
       * @param {*} x The value
       * @param {Function} f The function to apply
       * @return {*} The result of applying `f` to `x`
       * @example
       *
       *      const t42 = R.applyTo(42);
       *      t42(R.identity); //=> 42
       *      t42(R.add(1)); //=> 43
       */

      var applyTo =
      /*#__PURE__*/
      _curry2(function applyTo(x, f) {
        return f(x);
      });

      var applyTo$1 = exports('applyTo', applyTo);

      /**
       * Makes an ascending comparator function out of a function that returns a value
       * that can be compared with `<` and `>`.
       *
       * @func
       * @memberOf R
       * @since v0.23.0
       * @category Function
       * @sig Ord b => (a -> b) -> a -> a -> Number
       * @param {Function} fn A function of arity one that returns a value that can be compared
       * @param {*} a The first item to be compared.
       * @param {*} b The second item to be compared.
       * @return {Number} `-1` if fn(a) < fn(b), `1` if fn(b) < fn(a), otherwise `0`
       * @see R.descend
       * @example
       *
       *      const byAge = R.ascend(R.prop('age'));
       *      const people = [
       *        { name: 'Emma', age: 70 },
       *        { name: 'Peter', age: 78 },
       *        { name: 'Mikhail', age: 62 },
       *      ];
       *      const peopleByYoungestFirst = R.sort(byAge, people);
       *        //=> [{ name: 'Mikhail', age: 62 },{ name: 'Emma', age: 70 }, { name: 'Peter', age: 78 }]
       */

      var ascend =
      /*#__PURE__*/
      _curry3(function ascend(fn, a, b) {
        var aa = fn(a);
        var bb = fn(b);
        return aa < bb ? -1 : aa > bb ? 1 : 0;
      });

      var ascend$1 = exports('ascend', ascend);

      /**
       * Makes a shallow clone of an object, setting or overriding the specified
       * property with the given value. Note that this copies and flattens prototype
       * properties onto the new object as well. All non-primitive properties are
       * copied by reference.
       *
       * @func
       * @memberOf R
       * @since v0.8.0
       * @category Object
       * @sig String -> a -> {k: v} -> {k: v}
       * @param {String} prop The property name to set
       * @param {*} val The new value
       * @param {Object} obj The object to clone
       * @return {Object} A new object equivalent to the original except for the changed property.
       * @see R.dissoc, R.pick
       * @example
       *
       *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
       */

      var assoc =
      /*#__PURE__*/
      _curry3(function assoc(prop, val, obj) {
        var result = {};

        for (var p in obj) {
          result[p] = obj[p];
        }

        result[prop] = val;
        return result;
      });

      var assoc$1 = exports('assoc', assoc);

      /**
       * Checks if the input value is `null` or `undefined`.
       *
       * @func
       * @memberOf R
       * @since v0.9.0
       * @category Type
       * @sig * -> Boolean
       * @param {*} x The value to test.
       * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
       * @example
       *
       *      R.isNil(null); //=> true
       *      R.isNil(undefined); //=> true
       *      R.isNil(0); //=> false
       *      R.isNil([]); //=> false
       */

      var isNil =
      /*#__PURE__*/
      _curry1(function isNil(x) {
        return x == null;
      });

      var isNil$1 = exports('isNil', isNil);

      /**
       * Makes a shallow clone of an object, setting or overriding the nodes required
       * to create the given path, and placing the specific value at the tail end of
       * that path. Note that this copies and flattens prototype properties onto the
       * new object as well. All non-primitive properties are copied by reference.
       *
       * @func
       * @memberOf R
       * @since v0.8.0
       * @category Object
       * @typedefn Idx = String | Int
       * @sig [Idx] -> a -> {a} -> {a}
       * @param {Array} path the path to set
       * @param {*} val The new value
       * @param {Object} obj The object to clone
       * @return {Object} A new object equivalent to the original except along the specified path.
       * @see R.dissocPath
       * @example
       *
       *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
       *
       *      // Any missing or non-object keys in path will be overridden
       *      R.assocPath(['a', 'b', 'c'], 42, {a: 5}); //=> {a: {b: {c: 42}}}
       */

      var assocPath =
      /*#__PURE__*/
      _curry3(function assocPath(path, val, obj) {
        if (path.length === 0) {
          return val;
        }

        var idx = path[0];

        if (path.length > 1) {
          var nextObj = !isNil$1(obj) && _has(idx, obj) ? obj[idx] : _isInteger(path[1]) ? [] : {};
          val = assocPath(Array.prototype.slice.call(path, 1), val, nextObj);
        }

        if (_isInteger(idx) && _isArray(obj)) {
          var arr = [].concat(obj);
          arr[idx] = val;
          return arr;
        } else {
          return assoc$1(idx, val, obj);
        }
      });

      var assocPath$1 = exports('assocPath', assocPath);

      /**
       * Wraps a function of any arity (including nullary) in a function that accepts
       * exactly `n` parameters. Any extraneous parameters will not be passed to the
       * supplied function.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Function
       * @sig Number -> (* -> a) -> (* -> a)
       * @param {Number} n The desired arity of the new function.
       * @param {Function} fn The function to wrap.
       * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
       *         arity `n`.
       * @see R.binary, R.unary
       * @example
       *
       *      const takesTwoArgs = (a, b) => [a, b];
       *
       *      takesTwoArgs.length; //=> 2
       *      takesTwoArgs(1, 2); //=> [1, 2]
       *
       *      const takesOneArg = R.nAry(1, takesTwoArgs);
       *      takesOneArg.length; //=> 1
       *      // Only `n` arguments are passed to the wrapped function
       *      takesOneArg(1, 2); //=> [1, undefined]
       * @symb R.nAry(0, f)(a, b) = f()
       * @symb R.nAry(1, f)(a, b) = f(a)
       * @symb R.nAry(2, f)(a, b) = f(a, b)
       */

      var nAry =
      /*#__PURE__*/
      _curry2(function nAry(n, fn) {
        switch (n) {
          case 0:
            return function () {
              return fn.call(this);
            };

          case 1:
            return function (a0) {
              return fn.call(this, a0);
            };

          case 2:
            return function (a0, a1) {
              return fn.call(this, a0, a1);
            };

          case 3:
            return function (a0, a1, a2) {
              return fn.call(this, a0, a1, a2);
            };

          case 4:
            return function (a0, a1, a2, a3) {
              return fn.call(this, a0, a1, a2, a3);
            };

          case 5:
            return function (a0, a1, a2, a3, a4) {
              return fn.call(this, a0, a1, a2, a3, a4);
            };

          case 6:
            return function (a0, a1, a2, a3, a4, a5) {
              return fn.call(this, a0, a1, a2, a3, a4, a5);
            };

          case 7:
            return function (a0, a1, a2, a3, a4, a5, a6) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
            };

          case 8:
            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
            };

          case 9:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
            };

          case 10:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
              return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            };

          default:
            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
        }
      });

      var nAry$1 = exports('nAry', nAry);

      /**
       * Wraps a function of any arity (including nullary) in a function that accepts
       * exactly 2 parameters. Any extraneous parameters will not be passed to the
       * supplied function.
       *
       * @func
       * @memberOf R
       * @since v0.2.0
       * @category Function
       * @sig (* -> c) -> (a, b -> c)
       * @param {Function} fn The function to wrap.
       * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
       *         arity 2.
       * @see R.nAry, R.unary
       * @example
       *
       *      const takesThreeArgs = function(a, b, c) {
       *        return [a, b, c];
       *      };
       *      takesThreeArgs.length; //=> 3
       *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
       *
       *      const takesTwoArgs = R.binary(takesThreeArgs);
       *      takesTwoArgs.length; //=> 2
       *      // Only 2 arguments are passed to the wrapped function
       *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
       * @symb R.binary(f)(a, b, c) = f(a, b)
       */

      var binary =
      /*#__PURE__*/
      _curry1(function binary(fn) {
        return nAry$1(2, fn);
      });

      var binary$1 = exports('binary', binary);

      function _isFunction(x) {
        var type = Object.prototype.toString.call(x);
        return type === '[object Function]' || type === '[object AsyncFunction]' || type === '[object GeneratorFunction]' || type === '[object AsyncGeneratorFunction]';
      }

      /**
       * "lifts" a function to be the specified arity, so that it may "map over" that
       * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
       *
       * @func
       * @memberOf R
       * @since v0.7.0
       * @category Function
       * @sig Number -> (*... -> *) -> ([*]... -> [*])
       * @param {Function} fn The function to lift into higher context
       * @return {Function} The lifted function.
       * @see R.lift, R.ap
       * @example
       *
       *      const madd3 = R.liftN(3, (...args) => R.sum(args));
       *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
       */

      var liftN =
      /*#__PURE__*/
      _curry2(function liftN(arity, fn) {
        var lifted = curryN$1(arity, fn);
        return curryN$1(arity, function () {
          return _reduce(ap$1, map$1(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));
        });
      });

      var liftN$1 = exports('liftN', liftN);

      /**
       * "lifts" a function of arity > 1 so that it may "map over" a list, Function or other
       * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
       *
       * @func
       * @memberOf R
       * @since v0.7.0
       * @category Function
       * @sig (*... -> *) -> ([*]... -> [*])
       * @param {Function} fn The function to lift into higher context
       * @return {Function} The lifted function.
       * @see R.liftN
       * @example
       *
       *      const madd3 = R.lift((a, b, c) => a + b + c);
       *
       *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
       *
       *      const madd5 = R.lift((a, b, c, d, e) => a + b + c + d + e);
       *
       *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
       */

      var lift =
      /*#__PURE__*/
      _curry1(function lift(fn) {
        return liftN$1(fn.length, fn);
      });

      var lift$1 = exports('lift', lift);

      /**
       * A function which calls the two provided functions and returns the `&&`
       * of the results.
       * It returns the result of the first function if it is false-y and the result
       * of the second function otherwise. Note that this is short-circuited,
       * meaning that the second function will not be invoked if the first returns a
       * false-y value.
       *
       * In addition to functions, `R.both` also accepts any fantasy-land compatible
       * applicative functor.
       *
       * @func
       * @memberOf R
       * @since v0.12.0
       * @category Logic
       * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
       * @param {Function} f A predicate
       * @param {Function} g Another predicate
       * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
       * @see R.and
       * @example
       *
       *      const gt10 = R.gt(R.__, 10)
       *      const lt20 = R.lt(R.__, 20)
       *      const f = R.both(gt10, lt20);
       *      f(15); //=> true
       *      f(30); //=> false
       *
       *      R.both(Maybe.Just(false), Maybe.Just(55)); // => Maybe.Just(false)
       *      R.both([false, false, 'a'], [11]); //=> [false, false, 11]
       */

      var both =
      /*#__PURE__*/
      _curry2(function both(f, g) {
        return _isFunction(f) ? function _both() {
          return f.apply(this, arguments) && g.apply(this, arguments);
        } : lift$1(and$1)(f, g);
      });

      var both$1 = exports('both', both);

      /**
       * Returns a curried equivalent of the provided function. The curried function
       * has two unusual capabilities. First, its arguments needn't be provided one
       * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
       * following are equivalent:
       *
       *   - `g(1)(2)(3)`
       *   - `g(1)(2, 3)`
       *   - `g(1, 2)(3)`
       *   - `g(1, 2, 3)`
       *
       * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
       * "gaps", allowing partial application of any combination of arguments,
       * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
       * the following are equivalent:
       *
       *   - `g(1, 2, 3)`
       *   - `g(_, 2, 3)(1)`
       *   - `g(_, _, 3)(1)(2)`
       *   - `g(_, _, 3)(1, 2)`
       *   - `g(_, 2)(1)(3)`
       *   - `g(_, 2)(1, 3)`
       *   - `g(_, 2)(_, 3)(1)`
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Function
       * @sig (* -> a) -> (* -> a)
       * @param {Function} fn The function to curry.
       * @return {Function} A new, curried function.
       * @see R.curryN, R.partial
       * @example
       *
       *      const addFourNumbers = (a, b, c, d) => a + b + c + d;
       *
       *      const curriedAddFourNumbers = R.curry(addFourNumbers);
       *      const f = curriedAddFourNumbers(1, 2);
       *      const g = f(3);
       *      g(4); //=> 10
       */

      var curry =
      /*#__PURE__*/
      _curry1(function curry(fn) {
        return curryN$1(fn.length, fn);
      });

      var curry$1 = exports('curry', curry);

      /**
       * Returns the result of calling its first argument with the remaining
       * arguments. This is occasionally useful as a converging function for
       * [`R.converge`](#converge): the first branch can produce a function while the
       * remaining branches produce values to be passed to that function as its
       * arguments.
       *
       * @func
       * @memberOf R
       * @since v0.9.0
       * @category Function
       * @sig (*... -> a),*... -> a
       * @param {Function} fn The function to apply to the remaining arguments.
       * @param {...*} args Any number of positional arguments.
       * @return {*}
       * @see R.apply
       * @example
       *
       *      R.call(R.add, 1, 2); //=> 3
       *
       *      const indentN = R.pipe(R.repeat(' '),
       *                           R.join(''),
       *                           R.replace(/^(?!$)/gm));
       *
       *      const format = R.converge(R.call, [
       *                                  R.pipe(R.prop('indent'), indentN),
       *                                  R.prop('value')
       *                              ]);
       *
       *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
       * @symb R.call(f, a, b) = f(a, b)
       */

      var call =
      /*#__PURE__*/
      curry$1(function call(fn) {
        return fn.apply(this, Array.prototype.slice.call(arguments, 1));
      });
      var call$1 = exports('call', call);

      /**
       * `_makeFlat` is a helper function that returns a one-level or fully recursive
       * function based on the flag passed in.
       *
       * @private
       */

      function _makeFlat(recursive) {
        return function flatt(list) {
          var value, jlen, j;
          var result = [];
          var idx = 0;
          var ilen = list.length;

          while (idx < ilen) {
            if (_isArrayLike$1(list[idx])) {
              value = recursive ? flatt(list[idx]) : list[idx];
              j = 0;
              jlen = value.length;

              while (j < jlen) {
                result[result.length] = value[j];
                j += 1;
              }
            } else {
              result[result.length] = list[idx];
            }

            idx += 1;
          }

          return result;
        };
      }

      function _forceReduced(x) {
        return {
          '@@transducer/value': x,
          '@@transducer/reduced': true
        };
      }

      var preservingReduced = function (xf) {
        return {
          '@@transducer/init': _xfBase.init,
          '@@transducer/result': function (result) {
            return xf['@@transducer/result'](result);
          },
          '@@transducer/step': function (result, input) {
            var ret = xf['@@transducer/step'](result, input);
            return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
          }
        };
      };

      var _flatCat = function _xcat(xf) {
        var rxf = preservingReduced(xf);
        return {
          '@@transducer/init': _xfBase.init,
          '@@transducer/result': function (result) {
            return rxf['@@transducer/result'](result);
          },
          '@@transducer/step': function (result, input) {
            return !_isArrayLike$1(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
          }
        };
      };

      var _flatCat$1 = _flatCat;

      var _xchain =
      /*#__PURE__*/
      _curry2(function _xchain(f, xf) {
        return map$1(f, _flatCat$1(xf));
      });

      var _xchain$1 = _xchain;

      /**
       * `chain` maps a function over a list and concatenates the results. `chain`
       * is also known as `flatMap` in some libraries.
       *
       * Dispatches to the `chain` method of the second argument, if present,
       * according to the [FantasyLand Chain spec](https://github.com/fantasyland/fantasy-land#chain).
       *
       * If second argument is a function, `chain(f, g)(x)` is equivalent to `f(g(x), x)`.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.3.0
       * @category List
       * @sig Chain m => (a -> m b) -> m a -> m b
       * @param {Function} fn The function to map with
       * @param {Array} list The list to map over
       * @return {Array} The result of flat-mapping `list` with `fn`
       * @example
       *
       *      const duplicate = n => [n, n];
       *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
       *
       *      R.chain(R.append, R.head)([1, 2, 3]); //=> [1, 2, 3, 1]
       */

      var chain =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _dispatchable(['fantasy-land/chain', 'chain'], _xchain$1, function chain(fn, monad) {
        if (typeof monad === 'function') {
          return function (x) {
            return fn(monad(x))(x);
          };
        }

        return _makeFlat(false)(map$1(fn, monad));
      }));

      var chain$1 = exports('chain', chain);

      /**
       * Restricts a number to be within a range.
       *
       * Also works for other ordered types such as Strings and Dates.
       *
       * @func
       * @memberOf R
       * @since v0.20.0
       * @category Relation
       * @sig Ord a => a -> a -> a -> a
       * @param {Number} minimum The lower limit of the clamp (inclusive)
       * @param {Number} maximum The upper limit of the clamp (inclusive)
       * @param {Number} value Value to be clamped
       * @return {Number} Returns `minimum` when `val < minimum`, `maximum` when `val > maximum`, returns `val` otherwise
       * @example
       *
       *      R.clamp(1, 10, -5) // => 1
       *      R.clamp(1, 10, 15) // => 10
       *      R.clamp(1, 10, 4)  // => 4
       */

      var clamp =
      /*#__PURE__*/
      _curry3(function clamp(min, max, value) {
        if (min > max) {
          throw new Error('min must not be greater than max in clamp(min, max, value)');
        }

        return value < min ? min : value > max ? max : value;
      });

      var clamp$1 = exports('clamp', clamp);

      function _cloneRegExp(pattern) {
        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
      }

      /**
       * Gives a single-word string description of the (native) type of a value,
       * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
       * attempt to distinguish user Object types any further, reporting them all as
       * 'Object'.
       *
       * @func
       * @memberOf R
       * @since v0.8.0
       * @category Type
       * @sig (* -> {*}) -> String
       * @param {*} val The value to test
       * @return {String}
       * @example
       *
       *      R.type({}); //=> "Object"
       *      R.type(1); //=> "Number"
       *      R.type(false); //=> "Boolean"
       *      R.type('s'); //=> "String"
       *      R.type(null); //=> "Null"
       *      R.type([]); //=> "Array"
       *      R.type(/[A-z]/); //=> "RegExp"
       *      R.type(() => {}); //=> "Function"
       *      R.type(undefined); //=> "Undefined"
       */

      var type =
      /*#__PURE__*/
      _curry1(function type(val) {
        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
      });

      var type$1 = exports('type', type);

      /**
       * Copies an object.
       *
       * @private
       * @param {*} value The value to be copied
       * @param {Array} refFrom Array containing the source references
       * @param {Array} refTo Array containing the copied source references
       * @param {Boolean} deep Whether or not to perform deep cloning.
       * @return {*} The copied value.
       */

      function _clone(value, refFrom, refTo, deep) {
        var copy = function copy(copiedValue) {
          var len = refFrom.length;
          var idx = 0;

          while (idx < len) {
            if (value === refFrom[idx]) {
              return refTo[idx];
            }

            idx += 1;
          }

          refFrom[idx + 1] = value;
          refTo[idx + 1] = copiedValue;

          for (var key in value) {
            copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
          }

          return copiedValue;
        };

        switch (type$1(value)) {
          case 'Object':
            return copy({});

          case 'Array':
            return copy([]);

          case 'Date':
            return new Date(value.valueOf());

          case 'RegExp':
            return _cloneRegExp(value);

          default:
            return value;
        }
      }

      /**
       * Creates a deep copy of the value which may contain (nested) `Array`s and
       * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are
       * assigned by reference rather than copied
       *
       * Dispatches to a `clone` method if present.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Object
       * @sig {*} -> {*}
       * @param {*} value The object or array to clone
       * @return {*} A deeply cloned copy of `val`
       * @example
       *
       *      const objects = [{}, {}, {}];
       *      const objectsClone = R.clone(objects);
       *      objects === objectsClone; //=> false
       *      objects[0] === objectsClone[0]; //=> false
       */

      var clone =
      /*#__PURE__*/
      _curry1(function clone(value) {
        return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], [], true);
      });

      var clone$1 = exports('clone', clone);

      /**
       * Makes a comparator function out of a function that reports whether the first
       * element is less than the second.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Function
       * @sig ((a, b) -> Boolean) -> ((a, b) -> Number)
       * @param {Function} pred A predicate function of arity two which will return `true` if the first argument
       * is less than the second, `false` otherwise
       * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`
       * @example
       *
       *      const byAge = R.comparator((a, b) => a.age < b.age);
       *      const people = [
       *        { name: 'Emma', age: 70 },
       *        { name: 'Peter', age: 78 },
       *        { name: 'Mikhail', age: 62 },
       *      ];
       *      const peopleByIncreasingAge = R.sort(byAge, people);
       *        //=> [{ name: 'Mikhail', age: 62 },{ name: 'Emma', age: 70 }, { name: 'Peter', age: 78 }]
       */

      var comparator =
      /*#__PURE__*/
      _curry1(function comparator(pred) {
        return function (a, b) {
          return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
        };
      });

      var comparator$1 = exports('comparator', comparator);

      /**
       * A function that returns the `!` of its argument. It will return `true` when
       * passed false-y value, and `false` when passed a truth-y one.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Logic
       * @sig * -> Boolean
       * @param {*} a any value
       * @return {Boolean} the logical inverse of passed argument.
       * @see R.complement
       * @example
       *
       *      R.not(true); //=> false
       *      R.not(false); //=> true
       *      R.not(0); //=> true
       *      R.not(1); //=> false
       */

      var not =
      /*#__PURE__*/
      _curry1(function not(a) {
        return !a;
      });

      var not$1 = exports('not', not);

      /**
       * Takes a function `f` and returns a function `g` such that if called with the same arguments
       * when `f` returns a "truthy" value, `g` returns `false` and when `f` returns a "falsy" value `g` returns `true`.
       *
       * `R.complement` may be applied to any functor
       *
       * @func
       * @memberOf R
       * @since v0.12.0
       * @category Logic
       * @sig (*... -> *) -> (*... -> Boolean)
       * @param {Function} f
       * @return {Function}
       * @see R.not
       * @example
       *
       *      const isNotNil = R.complement(R.isNil);
       *      isNil(null); //=> true
       *      isNotNil(null); //=> false
       *      isNil(7); //=> false
       *      isNotNil(7); //=> true
       */

      var complement =
      /*#__PURE__*/
      lift$1(not$1);
      var complement$1 = exports('complement', complement);

      function _pipe(f, g) {
        return function () {
          return g.call(this, f.apply(this, arguments));
        };
      }

      /**
       * This checks whether a function has a [methodname] function. If it isn't an
       * array it will execute that function otherwise it will default to the ramda
       * implementation.
       *
       * @private
       * @param {Function} fn ramda implemtation
       * @param {String} methodname property to check for a custom implementation
       * @return {Object} Whatever the return value of the method is.
       */

      function _checkForMethod(methodname, fn) {
        return function () {
          var length = arguments.length;

          if (length === 0) {
            return fn();
          }

          var obj = arguments[length - 1];
          return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
        };
      }

      /**
       * Returns the elements of the given list or string (or object with a `slice`
       * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
       *
       * Dispatches to the `slice` method of the third argument, if present.
       *
       * @func
       * @memberOf R
       * @since v0.1.4
       * @category List
       * @sig Number -> Number -> [a] -> [a]
       * @sig Number -> Number -> String -> String
       * @param {Number} fromIndex The start index (inclusive).
       * @param {Number} toIndex The end index (exclusive).
       * @param {*} list
       * @return {*}
       * @example
       *
       *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
       *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
       *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
       *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
       *      R.slice(0, 3, 'ramda');                     //=> 'ram'
       */

      var slice =
      /*#__PURE__*/
      _curry3(
      /*#__PURE__*/
      _checkForMethod('slice', function slice(fromIndex, toIndex, list) {
        return Array.prototype.slice.call(list, fromIndex, toIndex);
      }));

      var slice$1 = exports('slice', slice);

      /**
       * Returns all but the first element of the given list or string (or object
       * with a `tail` method).
       *
       * Dispatches to the `slice` method of the first argument, if present.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig [a] -> [a]
       * @sig String -> String
       * @param {*} list
       * @return {*}
       * @see R.head, R.init, R.last
       * @example
       *
       *      R.tail([1, 2, 3]);  //=> [2, 3]
       *      R.tail([1, 2]);     //=> [2]
       *      R.tail([1]);        //=> []
       *      R.tail([]);         //=> []
       *
       *      R.tail('abc');  //=> 'bc'
       *      R.tail('ab');   //=> 'b'
       *      R.tail('a');    //=> ''
       *      R.tail('');     //=> ''
       */

      var tail =
      /*#__PURE__*/
      _curry1(
      /*#__PURE__*/
      _checkForMethod('tail',
      /*#__PURE__*/
      slice$1(1, Infinity)));

      var tail$1 = exports('tail', tail);

      /**
       * Performs left-to-right function composition. The first argument may have
       * any arity; the remaining arguments must be unary.
       *
       * In some libraries this function is named `sequence`.
       *
       * **Note:** The result of pipe is not automatically curried.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Function
       * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
       * @param {...Function} functions
       * @return {Function}
       * @see R.compose
       * @example
       *
       *      const f = R.pipe(Math.pow, R.negate, R.inc);
       *
       *      f(3, 4); // -(3^4) + 1
       * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
       */

      function pipe() {
        if (arguments.length === 0) {
          throw new Error('pipe requires at least one argument');
        }

        return _arity(arguments[0].length, reduce$1(_pipe, arguments[0], tail$1(arguments)));
      }

      /**
       * Returns a new list or string with the elements or characters in reverse
       * order.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig [a] -> [a]
       * @sig String -> String
       * @param {Array|String} list
       * @return {Array|String}
       * @example
       *
       *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
       *      R.reverse([1, 2]);     //=> [2, 1]
       *      R.reverse([1]);        //=> [1]
       *      R.reverse([]);         //=> []
       *
       *      R.reverse('abc');      //=> 'cba'
       *      R.reverse('ab');       //=> 'ba'
       *      R.reverse('a');        //=> 'a'
       *      R.reverse('');         //=> ''
       */

      var reverse =
      /*#__PURE__*/
      _curry1(function reverse(list) {
        return _isString(list) ? list.split('').reverse().join('') : Array.prototype.slice.call(list, 0).reverse();
      });

      var reverse$1 = exports('reverse', reverse);

      /**
       * Performs right-to-left function composition. The last argument may have
       * any arity; the remaining arguments must be unary.
       *
       * **Note:** The result of compose is not automatically curried.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Function
       * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
       * @param {...Function} ...functions The functions to compose
       * @return {Function}
       * @see R.pipe
       * @example
       *
       *      const classyGreeting = (firstName, lastName) => "The name's " + lastName + ", " + firstName + " " + lastName
       *      const yellGreeting = R.compose(R.toUpper, classyGreeting);
       *      yellGreeting('James', 'Bond'); //=> "THE NAME'S BOND, JAMES BOND"
       *
       *      R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7
       *
       * @symb R.compose(f, g, h)(a, b) = f(g(h(a, b)))
       */

      function compose() {
        if (arguments.length === 0) {
          throw new Error('compose requires at least one argument');
        }

        return pipe.apply(this, reverse$1(arguments));
      }

      /**
       * Returns the right-to-left Kleisli composition of the provided functions,
       * each of which must return a value of a type supported by [`chain`](#chain).
       *
       * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), f)`.
       *
       * @func
       * @memberOf R
       * @since v0.16.0
       * @category Function
       * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (a -> m z)
       * @param {...Function} ...functions The functions to compose
       * @return {Function}
       * @see R.pipeK
       * @deprecated since v0.26.0
       * @example
       *
       *       //  get :: String -> Object -> Maybe *
       *       const get = R.curry((propName, obj) => Maybe(obj[propName]))
       *
       *       //  getStateCode :: Maybe String -> Maybe String
       *       const getStateCode = R.composeK(
       *         R.compose(Maybe.of, R.toUpper),
       *         get('state'),
       *         get('address'),
       *         get('user'),
       *       );
       *       getStateCode({"user":{"address":{"state":"ny"}}}); //=> Maybe.Just("NY")
       *       getStateCode({}); //=> Maybe.Nothing()
       * @symb R.composeK(f, g, h)(a) = R.chain(f, R.chain(g, h(a)))
       */

      function composeK() {
        if (arguments.length === 0) {
          throw new Error('composeK requires at least one argument');
        }

        var init = Array.prototype.slice.call(arguments);
        var last = init.pop();
        return compose(compose.apply(this, map$1(chain$1, init)), last);
      }

      function _pipeP(f, g) {
        return function () {
          var ctx = this;
          return f.apply(ctx, arguments).then(function (x) {
            return g.call(ctx, x);
          });
        };
      }

      /**
       * Performs left-to-right composition of one or more Promise-returning
       * functions. The first argument may have any arity; the remaining arguments
       * must be unary.
       *
       * @func
       * @memberOf R
       * @since v0.10.0
       * @category Function
       * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
       * @param {...Function} functions
       * @return {Function}
       * @see R.composeP
       * @deprecated since v0.26.0
       * @example
       *
       *      //  followersForUser :: String -> Promise [User]
       *      const followersForUser = R.pipeP(db.getUserById, db.getFollowers);
       */

      function pipeP() {
        if (arguments.length === 0) {
          throw new Error('pipeP requires at least one argument');
        }

        return _arity(arguments[0].length, reduce$1(_pipeP, arguments[0], tail$1(arguments)));
      }

      /**
       * Performs right-to-left composition of one or more Promise-returning
       * functions. The last arguments may have any arity; the remaining
       * arguments must be unary.
       *
       * @func
       * @memberOf R
       * @since v0.10.0
       * @category Function
       * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
       * @param {...Function} functions The functions to compose
       * @return {Function}
       * @see R.pipeP
       * @deprecated since v0.26.0
       * @example
       *
       *      const db = {
       *        users: {
       *          JOE: {
       *            name: 'Joe',
       *            followers: ['STEVE', 'SUZY']
       *          }
       *        }
       *      }
       *
       *      // We'll pretend to do a db lookup which returns a promise
       *      const lookupUser = (userId) => Promise.resolve(db.users[userId])
       *      const lookupFollowers = (user) => Promise.resolve(user.followers)
       *      lookupUser('JOE').then(lookupFollowers)
       *
       *      //  followersForUser :: String -> Promise [UserId]
       *      const followersForUser = R.composeP(lookupFollowers, lookupUser);
       *      followersForUser('JOE').then(followers => console.log('Followers:', followers))
       *      // Followers: ["STEVE","SUZY"]
       */

      function composeP() {
        if (arguments.length === 0) {
          throw new Error('composeP requires at least one argument');
        }

        return pipeP.apply(this, reverse$1(arguments));
      }

      /**
       * Returns the first element of the given list or string. In some libraries
       * this function is named `first`.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig [a] -> a | Undefined
       * @sig String -> String
       * @param {Array|String} list
       * @return {*}
       * @see R.tail, R.init, R.last
       * @example
       *
       *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
       *      R.head([]); //=> undefined
       *
       *      R.head('abc'); //=> 'a'
       *      R.head(''); //=> ''
       */

      var head =
      /*#__PURE__*/
      nth$1(0);
      var head$1 = exports('head', head);

      function _identity(x) {
        return x;
      }

      /**
       * A function that does nothing but return the parameter supplied to it. Good
       * as a default or placeholder function.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Function
       * @sig a -> a
       * @param {*} x The value to return.
       * @return {*} The input value, `x`.
       * @example
       *
       *      R.identity(1); //=> 1
       *
       *      const obj = {};
       *      R.identity(obj) === obj; //=> true
       * @symb R.identity(a) = a
       */

      var identity =
      /*#__PURE__*/
      _curry1(_identity);

      var identity$1 = exports('identity', identity);

      /**
       * Performs left-to-right function composition using transforming function. The first argument may have
       * any arity; the remaining arguments must be unary.
       *
       * **Note:** The result of pipeWith is not automatically curried. Transforming function is not used on the
       * first argument.
       *
       * @func
       * @memberOf R
       * @since v0.26.0
       * @category Function
       * @sig ((* -> *), [((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)]) -> ((a, b, ..., n) -> z)
       * @param {...Function} functions
       * @return {Function}
       * @see R.composeWith, R.pipe
       * @example
       *
       *      const pipeWhileNotNil = R.pipeWith((f, res) => R.isNil(res) ? res : f(res));
       *      const f = pipeWhileNotNil([Math.pow, R.negate, R.inc])
       *
       *      f(3, 4); // -(3^4) + 1
       * @symb R.pipeWith(f)([g, h, i])(...args) = f(i, f(h, g(...args)))
       */

      var pipeWith =
      /*#__PURE__*/
      _curry2(function pipeWith(xf, list) {
        if (list.length <= 0) {
          return identity$1;
        }

        var headList = head$1(list);
        var tailList = tail$1(list);
        return _arity(headList.length, function () {
          return _reduce(function (result, f) {
            return xf.call(this, f, result);
          }, headList.apply(this, arguments), tailList);
        });
      });

      var pipeWith$1 = exports('pipeWith', pipeWith);

      /**
       * Performs right-to-left function composition using transforming function. The last argument may have
       * any arity; the remaining arguments must be unary.
       *
       * **Note:** The result of compose is not automatically curried. Transforming function is not used on the
       * last argument.
       *
       * @func
       * @memberOf R
       * @since v0.26.0
       * @category Function
       * @sig ((* -> *), [(y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)]) -> ((a, b, ..., n) -> z)
       * @param {...Function} ...functions The functions to compose
       * @return {Function}
       * @see R.compose, R.pipeWith
       * @example
       *
       *      const composeWhileNotNil = R.composeWith((f, res) => R.isNil(res) ? res : f(res));
       *
       *      composeWhileNotNil([R.inc, R.prop('age')])({age: 1}) //=> 2
       *      composeWhileNotNil([R.inc, R.prop('age')])({}) //=> undefined
       *
       * @symb R.composeWith(f)([g, h, i])(...args) = f(g, f(h, i(...args)))
       */

      var composeWith =
      /*#__PURE__*/
      _curry2(function composeWith(xf, list) {
        return pipeWith$1.apply(this, [xf, reverse$1(list)]);
      });

      var composeWith$1 = exports('composeWith', composeWith);

      function _arrayFromIterator(iter) {
        var list = [];
        var next;

        while (!(next = iter.next()).done) {
          list.push(next.value);
        }

        return list;
      }

      function _includesWith(pred, x, list) {
        var idx = 0;
        var len = list.length;

        while (idx < len) {
          if (pred(x, list[idx])) {
            return true;
          }

          idx += 1;
        }

        return false;
      }

      function _functionName(f) {
        // String(x => x) evaluates to "x => x", so the pattern may not match.
        var match = String(f).match(/^function (\w*)/);
        return match == null ? '' : match[1];
      }

      // Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
      function _objectIs(a, b) {
        // SameValue algorithm
        if (a === b) {
          // Steps 1-5, 7-10
          // Steps 6.b-6.e: +0 != -0
          return a !== 0 || 1 / a === 1 / b;
        } else {
          // Step 6.a: NaN == NaN
          return a !== a && b !== b;
        }
      }

      var _objectIs$1 = typeof Object.is === 'function' ? Object.is : _objectIs;

      /**
       * private _uniqContentEquals function.
       * That function is checking equality of 2 iterator contents with 2 assumptions
       * - iterators lengths are the same
       * - iterators values are unique
       *
       * false-positive result will be returned for comparision of, e.g.
       * - [1,2,3] and [1,2,3,4]
       * - [1,1,1] and [1,2,3]
       * */

      function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
        var a = _arrayFromIterator(aIterator);

        var b = _arrayFromIterator(bIterator);

        function eq(_a, _b) {
          return _equals(_a, _b, stackA.slice(), stackB.slice());
        } // if *a* array contains any element that is not included in *b*


        return !_includesWith(function (b, aItem) {
          return !_includesWith(eq, aItem, b);
        }, b, a);
      }

      function _equals(a, b, stackA, stackB) {
        if (_objectIs$1(a, b)) {
          return true;
        }

        var typeA = type$1(a);

        if (typeA !== type$1(b)) {
          return false;
        }

        if (a == null || b == null) {
          return false;
        }

        if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {
          return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) && typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);
        }

        if (typeof a.equals === 'function' || typeof b.equals === 'function') {
          return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
        }

        switch (typeA) {
          case 'Arguments':
          case 'Array':
          case 'Object':
            if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
              return a === b;
            }

            break;

          case 'Boolean':
          case 'Number':
          case 'String':
            if (!(typeof a === typeof b && _objectIs$1(a.valueOf(), b.valueOf()))) {
              return false;
            }

            break;

          case 'Date':
            if (!_objectIs$1(a.valueOf(), b.valueOf())) {
              return false;
            }

            break;

          case 'Error':
            return a.name === b.name && a.message === b.message;

          case 'RegExp':
            if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
              return false;
            }

            break;
        }

        var idx = stackA.length - 1;

        while (idx >= 0) {
          if (stackA[idx] === a) {
            return stackB[idx] === b;
          }

          idx -= 1;
        }

        switch (typeA) {
          case 'Map':
            if (a.size !== b.size) {
              return false;
            }

            return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));

          case 'Set':
            if (a.size !== b.size) {
              return false;
            }

            return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));

          case 'Arguments':
          case 'Array':
          case 'Object':
          case 'Boolean':
          case 'Number':
          case 'String':
          case 'Date':
          case 'Error':
          case 'RegExp':
          case 'Int8Array':
          case 'Uint8Array':
          case 'Uint8ClampedArray':
          case 'Int16Array':
          case 'Uint16Array':
          case 'Int32Array':
          case 'Uint32Array':
          case 'Float32Array':
          case 'Float64Array':
          case 'ArrayBuffer':
            break;

          default:
            // Values of other types are only equal if identical.
            return false;
        }

        var keysA = keys$1(a);

        if (keysA.length !== keys$1(b).length) {
          return false;
        }

        var extendedStackA = stackA.concat([a]);
        var extendedStackB = stackB.concat([b]);
        idx = keysA.length - 1;

        while (idx >= 0) {
          var key = keysA[idx];

          if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
            return false;
          }

          idx -= 1;
        }

        return true;
      }

      /**
       * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
       * cyclical data structures.
       *
       * Dispatches symmetrically to the `equals` methods of both arguments, if
       * present.
       *
       * @func
       * @memberOf R
       * @since v0.15.0
       * @category Relation
       * @sig a -> b -> Boolean
       * @param {*} a
       * @param {*} b
       * @return {Boolean}
       * @example
       *
       *      R.equals(1, 1); //=> true
       *      R.equals(1, '1'); //=> false
       *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
       *
       *      const a = {}; a.v = a;
       *      const b = {}; b.v = b;
       *      R.equals(a, b); //=> true
       */

      var equals =
      /*#__PURE__*/
      _curry2(function equals(a, b) {
        return _equals(a, b, [], []);
      });

      var equals$1 = exports('equals', equals);

      function _indexOf(list, a, idx) {
        var inf, item; // Array.prototype.indexOf doesn't exist below IE9

        if (typeof list.indexOf === 'function') {
          switch (typeof a) {
            case 'number':
              if (a === 0) {
                // manually crawl the list to distinguish between +0 and -0
                inf = 1 / a;

                while (idx < list.length) {
                  item = list[idx];

                  if (item === 0 && 1 / item === inf) {
                    return idx;
                  }

                  idx += 1;
                }

                return -1;
              } else if (a !== a) {
                // NaN
                while (idx < list.length) {
                  item = list[idx];

                  if (typeof item === 'number' && item !== item) {
                    return idx;
                  }

                  idx += 1;
                }

                return -1;
              } // non-zero numbers can utilise Set


              return list.indexOf(a, idx);
            // all these types can utilise Set

            case 'string':
            case 'boolean':
            case 'function':
            case 'undefined':
              return list.indexOf(a, idx);

            case 'object':
              if (a === null) {
                // null can utilise Set
                return list.indexOf(a, idx);
              }

          }
        } // anything else not covered above, defer to R.equals


        while (idx < list.length) {
          if (equals$1(list[idx], a)) {
            return idx;
          }

          idx += 1;
        }

        return -1;
      }

      function _includes(a, list) {
        return _indexOf(list, a, 0) >= 0;
      }

      function _quote(s) {
        var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b') // \b matches word boundary; [\b] matches backspace
        .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');
        return '"' + escaped.replace(/"/g, '\\"') + '"';
      }

      /**
       * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
       */
      var pad = function pad(n) {
        return (n < 10 ? '0' : '') + n;
      };

      var _toISOString = typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
        return d.toISOString();
      } : function _toISOString(d) {
        return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
      };

      var _toISOString$1 = _toISOString;

      function _complement(f) {
        return function () {
          return !f.apply(this, arguments);
        };
      }

      function _filter(fn, list) {
        var idx = 0;
        var len = list.length;
        var result = [];

        while (idx < len) {
          if (fn(list[idx])) {
            result[result.length] = list[idx];
          }

          idx += 1;
        }

        return result;
      }

      function _isObject(x) {
        return Object.prototype.toString.call(x) === '[object Object]';
      }

      var XFilter =
      /*#__PURE__*/
      function () {
        function XFilter(f, xf) {
          this.xf = xf;
          this.f = f;
        }

        XFilter.prototype['@@transducer/init'] = _xfBase.init;
        XFilter.prototype['@@transducer/result'] = _xfBase.result;

        XFilter.prototype['@@transducer/step'] = function (result, input) {
          return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
        };

        return XFilter;
      }();

      var _xfilter =
      /*#__PURE__*/
      _curry2(function _xfilter(f, xf) {
        return new XFilter(f, xf);
      });

      var _xfilter$1 = _xfilter;

      /**
       * Takes a predicate and a `Filterable`, and returns a new filterable of the
       * same type containing the members of the given filterable which satisfy the
       * given predicate. Filterable objects include plain objects or any object
       * that has a filter method such as `Array`.
       *
       * Dispatches to the `filter` method of the second argument, if present.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig Filterable f => (a -> Boolean) -> f a -> f a
       * @param {Function} pred
       * @param {Array} filterable
       * @return {Array} Filterable
       * @see R.reject, R.transduce, R.addIndex
       * @example
       *
       *      const isEven = n => n % 2 === 0;
       *
       *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
       *
       *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
       */

      var filter =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _dispatchable(['filter'], _xfilter$1, function (pred, filterable) {
        return _isObject(filterable) ? _reduce(function (acc, key) {
          if (pred(filterable[key])) {
            acc[key] = filterable[key];
          }

          return acc;
        }, {}, keys$1(filterable)) : // else
        _filter(pred, filterable);
      }));

      var filter$1 = exports('filter', filter);

      /**
       * The complement of [`filter`](#filter).
       *
       * Acts as a transducer if a transformer is given in list position. Filterable
       * objects include plain objects or any object that has a filter method such
       * as `Array`.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig Filterable f => (a -> Boolean) -> f a -> f a
       * @param {Function} pred
       * @param {Array} filterable
       * @return {Array}
       * @see R.filter, R.transduce, R.addIndex
       * @example
       *
       *      const isOdd = (n) => n % 2 === 1;
       *
       *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
       *
       *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
       */

      var reject =
      /*#__PURE__*/
      _curry2(function reject(pred, filterable) {
        return filter$1(_complement(pred), filterable);
      });

      var reject$1 = exports('reject', reject);

      function _toString(x, seen) {
        var recur = function recur(y) {
          var xs = seen.concat([x]);
          return _includes(y, xs) ? '<Circular>' : _toString(y, xs);
        }; //  mapPairs :: (Object, [String]) -> [String]


        var mapPairs = function (obj, keys) {
          return _map(function (k) {
            return _quote(k) + ': ' + recur(obj[k]);
          }, keys.slice().sort());
        };

        switch (Object.prototype.toString.call(x)) {
          case '[object Arguments]':
            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';

          case '[object Array]':
            return '[' + _map(recur, x).concat(mapPairs(x, reject$1(function (k) {
              return /^\d+$/.test(k);
            }, keys$1(x)))).join(', ') + ']';

          case '[object Boolean]':
            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();

          case '[object Date]':
            return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString$1(x))) + ')';

          case '[object Null]':
            return 'null';

          case '[object Number]':
            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);

          case '[object String]':
            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);

          case '[object Undefined]':
            return 'undefined';

          default:
            if (typeof x.toString === 'function') {
              var repr = x.toString();

              if (repr !== '[object Object]') {
                return repr;
              }
            }

            return '{' + mapPairs(x, keys$1(x)).join(', ') + '}';
        }
      }

      /**
       * Returns the string representation of the given value. `eval`'ing the output
       * should result in a value equivalent to the input value. Many of the built-in
       * `toString` methods do not satisfy this requirement.
       *
       * If the given value is an `[object Object]` with a `toString` method other
       * than `Object.prototype.toString`, this method is invoked with no arguments
       * to produce the return value. This means user-defined constructor functions
       * can provide a suitable `toString` method. For example:
       *
       *     function Point(x, y) {
       *       this.x = x;
       *       this.y = y;
       *     }
       *
       *     Point.prototype.toString = function() {
       *       return 'new Point(' + this.x + ', ' + this.y + ')';
       *     };
       *
       *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
       *
       * @func
       * @memberOf R
       * @since v0.14.0
       * @category String
       * @sig * -> String
       * @param {*} val
       * @return {String}
       * @example
       *
       *      R.toString(42); //=> '42'
       *      R.toString('abc'); //=> '"abc"'
       *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
       *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
       *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
       */

      var toString =
      /*#__PURE__*/
      _curry1(function toString(val) {
        return _toString(val, []);
      });

      var toString$1 = exports('toString', toString);

      /**
       * Returns the result of concatenating the given lists or strings.
       *
       * Note: `R.concat` expects both arguments to be of the same type,
       * unlike the native `Array.prototype.concat` method. It will throw
       * an error if you `concat` an Array with a non-Array value.
       *
       * Dispatches to the `concat` method of the first argument, if present.
       * Can also concatenate two members of a [fantasy-land
       * compatible semigroup](https://github.com/fantasyland/fantasy-land#semigroup).
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig [a] -> [a] -> [a]
       * @sig String -> String -> String
       * @param {Array|String} firstList The first list
       * @param {Array|String} secondList The second list
       * @return {Array|String} A list consisting of the elements of `firstList` followed by the elements of
       * `secondList`.
       *
       * @example
       *
       *      R.concat('ABC', 'DEF'); // 'ABCDEF'
       *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
       *      R.concat([], []); //=> []
       */

      var concat =
      /*#__PURE__*/
      _curry2(function concat(a, b) {
        if (_isArray(a)) {
          if (_isArray(b)) {
            return a.concat(b);
          }

          throw new TypeError(toString$1(b) + ' is not an array');
        }

        if (_isString(a)) {
          if (_isString(b)) {
            return a + b;
          }

          throw new TypeError(toString$1(b) + ' is not a string');
        }

        if (a != null && _isFunction(a['fantasy-land/concat'])) {
          return a['fantasy-land/concat'](b);
        }

        if (a != null && _isFunction(a.concat)) {
          return a.concat(b);
        }

        throw new TypeError(toString$1(a) + ' does not have a method named "concat" or "fantasy-land/concat"');
      });

      var concat$1 = exports('concat', concat);

      /**
       * Returns a function, `fn`, which encapsulates `if/else, if/else, ...` logic.
       * `R.cond` takes a list of [predicate, transformer] pairs. All of the arguments
       * to `fn` are applied to each of the predicates in turn until one returns a
       * "truthy" value, at which point `fn` returns the result of applying its
       * arguments to the corresponding transformer. If none of the predicates
       * matches, `fn` returns undefined.
       *
       * @func
       * @memberOf R
       * @since v0.6.0
       * @category Logic
       * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
       * @param {Array} pairs A list of [predicate, transformer]
       * @return {Function}
       * @see R.ifElse, R.unless, R.when
       * @example
       *
       *      const fn = R.cond([
       *        [R.equals(0),   R.always('water freezes at 0°C')],
       *        [R.equals(100), R.always('water boils at 100°C')],
       *        [R.T,           temp => 'nothing special happens at ' + temp + '°C']
       *      ]);
       *      fn(0); //=> 'water freezes at 0°C'
       *      fn(50); //=> 'nothing special happens at 50°C'
       *      fn(100); //=> 'water boils at 100°C'
       */

      var cond =
      /*#__PURE__*/
      _curry1(function cond(pairs) {
        var arity = reduce$1(max$1, 0, map$1(function (pair) {
          return pair[0].length;
        }, pairs));
        return _arity(arity, function () {
          var idx = 0;

          while (idx < pairs.length) {
            if (pairs[idx][0].apply(this, arguments)) {
              return pairs[idx][1].apply(this, arguments);
            }

            idx += 1;
          }
        });
      });

      var cond$1 = exports('cond', cond);

      /**
       * Wraps a constructor function inside a curried function that can be called
       * with the same arguments and returns the same type. The arity of the function
       * returned is specified to allow using variadic constructor functions.
       *
       * @func
       * @memberOf R
       * @since v0.4.0
       * @category Function
       * @sig Number -> (* -> {*}) -> (* -> {*})
       * @param {Number} n The arity of the constructor function.
       * @param {Function} Fn The constructor function to wrap.
       * @return {Function} A wrapped, curried constructor function.
       * @example
       *
       *      // Variadic Constructor function
       *      function Salad() {
       *        this.ingredients = arguments;
       *      }
       *
       *      Salad.prototype.recipe = function() {
       *        const instructions = R.map(ingredient => 'Add a dollop of ' + ingredient, this.ingredients);
       *        return R.join('\n', instructions);
       *      };
       *
       *      const ThreeLayerSalad = R.constructN(3, Salad);
       *
       *      // Notice we no longer need the 'new' keyword, and the constructor is curried for 3 arguments.
       *      const salad = ThreeLayerSalad('Mayonnaise')('Potato Chips')('Ketchup');
       *
       *      console.log(salad.recipe());
       *      // Add a dollop of Mayonnaise
       *      // Add a dollop of Potato Chips
       *      // Add a dollop of Ketchup
       */

      var constructN =
      /*#__PURE__*/
      _curry2(function constructN(n, Fn) {
        if (n > 10) {
          throw new Error('Constructor with greater than ten arguments');
        }

        if (n === 0) {
          return function () {
            return new Fn();
          };
        }

        return curry$1(nAry$1(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
          switch (arguments.length) {
            case 1:
              return new Fn($0);

            case 2:
              return new Fn($0, $1);

            case 3:
              return new Fn($0, $1, $2);

            case 4:
              return new Fn($0, $1, $2, $3);

            case 5:
              return new Fn($0, $1, $2, $3, $4);

            case 6:
              return new Fn($0, $1, $2, $3, $4, $5);

            case 7:
              return new Fn($0, $1, $2, $3, $4, $5, $6);

            case 8:
              return new Fn($0, $1, $2, $3, $4, $5, $6, $7);

            case 9:
              return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);

            case 10:
              return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
          }
        }));
      });

      var constructN$1 = exports('constructN', constructN);

      /**
       * Wraps a constructor function inside a curried function that can be called
       * with the same arguments and returns the same type.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Function
       * @sig (* -> {*}) -> (* -> {*})
       * @param {Function} fn The constructor function to wrap.
       * @return {Function} A wrapped, curried constructor function.
       * @see R.invoker
       * @example
       *
       *      // Constructor function
       *      function Animal(kind) {
       *        this.kind = kind;
       *      };
       *      Animal.prototype.sighting = function() {
       *        return "It's a " + this.kind + "!";
       *      }
       *
       *      const AnimalConstructor = R.construct(Animal)
       *
       *      // Notice we no longer need the 'new' keyword:
       *      AnimalConstructor('Pig'); //=> {"kind": "Pig", "sighting": function (){...}};
       *
       *      const animalTypes = ["Lion", "Tiger", "Bear"];
       *      const animalSighting = R.invoker(0, 'sighting');
       *      const sightNewAnimal = R.compose(animalSighting, AnimalConstructor);
       *      R.map(sightNewAnimal, animalTypes); //=> ["It's a Lion!", "It's a Tiger!", "It's a Bear!"]
       */

      var construct =
      /*#__PURE__*/
      _curry1(function construct(Fn) {
        return constructN$1(Fn.length, Fn);
      });

      var construct$1 = exports('construct', construct);

      /**
       * Returns `true` if the specified value is equal, in [`R.equals`](#equals)
       * terms, to at least one element of the given list; `false` otherwise.
       * Works also with strings.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig a -> [a] -> Boolean
       * @param {Object} a The item to compare against.
       * @param {Array} list The array to consider.
       * @return {Boolean} `true` if an equivalent item is in the list, `false` otherwise.
       * @see R.includes
       * @deprecated since v0.26.0
       * @example
       *
       *      R.contains(3, [1, 2, 3]); //=> true
       *      R.contains(4, [1, 2, 3]); //=> false
       *      R.contains({ name: 'Fred' }, [{ name: 'Fred' }]); //=> true
       *      R.contains([42], [[42]]); //=> true
       *      R.contains('ba', 'banana'); //=>true
       */

      var contains =
      /*#__PURE__*/
      _curry2(_includes);

      var contains$1 = exports('contains', contains);

      /**
       * Accepts a converging function and a list of branching functions and returns
       * a new function. The arity of the new function is the same as the arity of
       * the longest branching function. When invoked, this new function is applied
       * to some arguments, and each branching function is applied to those same
       * arguments. The results of each branching function are passed as arguments
       * to the converging function to produce the return value.
       *
       * @func
       * @memberOf R
       * @since v0.4.2
       * @category Function
       * @sig ((x1, x2, ...) -> z) -> [((a, b, ...) -> x1), ((a, b, ...) -> x2), ...] -> (a -> b -> ... -> z)
       * @param {Function} after A function. `after` will be invoked with the return values of
       *        `fn1` and `fn2` as its arguments.
       * @param {Array} functions A list of functions.
       * @return {Function} A new function.
       * @see R.useWith
       * @example
       *
       *      const average = R.converge(R.divide, [R.sum, R.length])
       *      average([1, 2, 3, 4, 5, 6, 7]) //=> 4
       *
       *      const strangeConcat = R.converge(R.concat, [R.toUpper, R.toLower])
       *      strangeConcat("Yodel") //=> "YODELyodel"
       *
       * @symb R.converge(f, [g, h])(a, b) = f(g(a, b), h(a, b))
       */

      var converge =
      /*#__PURE__*/
      _curry2(function converge(after, fns) {
        return curryN$1(reduce$1(max$1, 0, pluck$1('length', fns)), function () {
          var args = arguments;
          var context = this;
          return after.apply(context, _map(function (fn) {
            return fn.apply(context, args);
          }, fns));
        });
      });

      var converge$1 = exports('converge', converge);

      var XReduceBy =
      /*#__PURE__*/
      function () {
        function XReduceBy(valueFn, valueAcc, keyFn, xf) {
          this.valueFn = valueFn;
          this.valueAcc = valueAcc;
          this.keyFn = keyFn;
          this.xf = xf;
          this.inputs = {};
        }

        XReduceBy.prototype['@@transducer/init'] = _xfBase.init;

        XReduceBy.prototype['@@transducer/result'] = function (result) {
          var key;

          for (key in this.inputs) {
            if (_has(key, this.inputs)) {
              result = this.xf['@@transducer/step'](result, this.inputs[key]);

              if (result['@@transducer/reduced']) {
                result = result['@@transducer/value'];
                break;
              }
            }
          }

          this.inputs = null;
          return this.xf['@@transducer/result'](result);
        };

        XReduceBy.prototype['@@transducer/step'] = function (result, input) {
          var key = this.keyFn(input);
          this.inputs[key] = this.inputs[key] || [key, this.valueAcc];
          this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
          return result;
        };

        return XReduceBy;
      }();

      var _xreduceBy =
      /*#__PURE__*/
      _curryN(4, [], function _xreduceBy(valueFn, valueAcc, keyFn, xf) {
        return new XReduceBy(valueFn, valueAcc, keyFn, xf);
      });

      var _xreduceBy$1 = _xreduceBy;

      /**
       * Groups the elements of the list according to the result of calling
       * the String-returning function `keyFn` on each element and reduces the elements
       * of each group to a single value via the reducer function `valueFn`.
       *
       * This function is basically a more general [`groupBy`](#groupBy) function.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.20.0
       * @category List
       * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
       * @param {Function} valueFn The function that reduces the elements of each group to a single
       *        value. Receives two values, accumulator for a particular group and the current element.
       * @param {*} acc The (initial) accumulator value for each group.
       * @param {Function} keyFn The function that maps the list's element into a key.
       * @param {Array} list The array to group.
       * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
       *         `valueFn` for elements which produced that key when passed to `keyFn`.
       * @see R.groupBy, R.reduce
       * @example
       *
       *      const groupNames = (acc, {name}) => acc.concat(name)
       *      const toGrade = ({score}) =>
       *        score < 65 ? 'F' :
       *        score < 70 ? 'D' :
       *        score < 80 ? 'C' :
       *        score < 90 ? 'B' : 'A'
       *
       *      var students = [
       *        {name: 'Abby', score: 83},
       *        {name: 'Bart', score: 62},
       *        {name: 'Curt', score: 88},
       *        {name: 'Dora', score: 92},
       *      ]
       *
       *      reduceBy(groupNames, [], toGrade, students)
       *      //=> {"A": ["Dora"], "B": ["Abby", "Curt"], "F": ["Bart"]}
       */

      var reduceBy =
      /*#__PURE__*/
      _curryN(4, [],
      /*#__PURE__*/
      _dispatchable([], _xreduceBy$1, function reduceBy(valueFn, valueAcc, keyFn, list) {
        return _reduce(function (acc, elt) {
          var key = keyFn(elt);
          acc[key] = valueFn(_has(key, acc) ? acc[key] : _clone(valueAcc, [], [], false), elt);
          return acc;
        }, {}, list);
      }));

      var reduceBy$1 = exports('reduceBy', reduceBy);

      /**
       * Counts the elements of a list according to how many match each value of a
       * key generated by the supplied function. Returns an object mapping the keys
       * produced by `fn` to the number of occurrences in the list. Note that all
       * keys are coerced to strings because of how JavaScript objects work.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Relation
       * @sig (a -> String) -> [a] -> {*}
       * @param {Function} fn The function used to map values to keys.
       * @param {Array} list The list to count elements from.
       * @return {Object} An object mapping keys to number of occurrences in the list.
       * @example
       *
       *      const numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
       *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
       *
       *      const letters = ['a', 'b', 'A', 'a', 'B', 'c'];
       *      R.countBy(R.toLower)(letters);   //=> {'a': 3, 'b': 2, 'c': 1}
       */

      var countBy =
      /*#__PURE__*/
      reduceBy$1(function (acc, elem) {
        return acc + 1;
      }, 0);
      var countBy$1 = exports('countBy', countBy);

      /**
       * Decrements its argument.
       *
       * @func
       * @memberOf R
       * @since v0.9.0
       * @category Math
       * @sig Number -> Number
       * @param {Number} n
       * @return {Number} n - 1
       * @see R.inc
       * @example
       *
       *      R.dec(42); //=> 41
       */

      var dec =
      /*#__PURE__*/
      add$1(-1);
      var dec$1 = exports('dec', dec);

      /**
       * Returns the second argument if it is not `null`, `undefined` or `NaN`;
       * otherwise the first argument is returned.
       *
       * @func
       * @memberOf R
       * @since v0.10.0
       * @category Logic
       * @sig a -> b -> a | b
       * @param {a} default The default value.
       * @param {b} val `val` will be returned instead of `default` unless `val` is `null`, `undefined` or `NaN`.
       * @return {*} The second value if it is not `null`, `undefined` or `NaN`, otherwise the default value
       * @example
       *
       *      const defaultTo42 = R.defaultTo(42);
       *
       *      defaultTo42(null);  //=> 42
       *      defaultTo42(undefined);  //=> 42
       *      defaultTo42(false);  //=> false
       *      defaultTo42('Ramda');  //=> 'Ramda'
       *      // parseInt('string') results in NaN
       *      defaultTo42(parseInt('string')); //=> 42
       */

      var defaultTo =
      /*#__PURE__*/
      _curry2(function defaultTo(d, v) {
        return v == null || v !== v ? d : v;
      });

      var defaultTo$1 = exports('defaultTo', defaultTo);

      /**
       * Makes a descending comparator function out of a function that returns a value
       * that can be compared with `<` and `>`.
       *
       * @func
       * @memberOf R
       * @since v0.23.0
       * @category Function
       * @sig Ord b => (a -> b) -> a -> a -> Number
       * @param {Function} fn A function of arity one that returns a value that can be compared
       * @param {*} a The first item to be compared.
       * @param {*} b The second item to be compared.
       * @return {Number} `-1` if fn(a) > fn(b), `1` if fn(b) > fn(a), otherwise `0`
       * @see R.ascend
       * @example
       *
       *      const byAge = R.descend(R.prop('age'));
       *      const people = [
       *        { name: 'Emma', age: 70 },
       *        { name: 'Peter', age: 78 },
       *        { name: 'Mikhail', age: 62 },
       *      ];
       *      const peopleByOldestFirst = R.sort(byAge, people);
       *        //=> [{ name: 'Peter', age: 78 }, { name: 'Emma', age: 70 }, { name: 'Mikhail', age: 62 }]
       */

      var descend =
      /*#__PURE__*/
      _curry3(function descend(fn, a, b) {
        var aa = fn(a);
        var bb = fn(b);
        return aa > bb ? -1 : aa < bb ? 1 : 0;
      });

      var descend$1 = exports('descend', descend);

      var _Set =
      /*#__PURE__*/
      function () {
        function _Set() {
          /* globals Set */
          this._nativeSet = typeof Set === 'function' ? new Set() : null;
          this._items = {};
        }

        // until we figure out why jsdoc chokes on this
        // @param item The item to add to the Set
        // @returns {boolean} true if the item did not exist prior, otherwise false
        //
        _Set.prototype.add = function (item) {
          return !hasOrAdd(item, true, this);
        }; //
        // @param item The item to check for existence in the Set
        // @returns {boolean} true if the item exists in the Set, otherwise false
        //


        _Set.prototype.has = function (item) {
          return hasOrAdd(item, false, this);
        }; //
        // Combines the logic for checking whether an item is a member of the set and
        // for adding a new item to the set.
        //
        // @param item       The item to check or add to the Set instance.
        // @param shouldAdd  If true, the item will be added to the set if it doesn't
        //                   already exist.
        // @param set        The set instance to check or add to.
        // @return {boolean} true if the item already existed, otherwise false.
        //


        return _Set;
      }();

      function hasOrAdd(item, shouldAdd, set) {
        var type = typeof item;
        var prevSize, newSize;

        switch (type) {
          case 'string':
          case 'number':
            // distinguish between +0 and -0
            if (item === 0 && 1 / item === -Infinity) {
              if (set._items['-0']) {
                return true;
              } else {
                if (shouldAdd) {
                  set._items['-0'] = true;
                }

                return false;
              }
            } // these types can all utilise the native Set


            if (set._nativeSet !== null) {
              if (shouldAdd) {
                prevSize = set._nativeSet.size;

                set._nativeSet.add(item);

                newSize = set._nativeSet.size;
                return newSize === prevSize;
              } else {
                return set._nativeSet.has(item);
              }
            } else {
              if (!(type in set._items)) {
                if (shouldAdd) {
                  set._items[type] = {};
                  set._items[type][item] = true;
                }

                return false;
              } else if (item in set._items[type]) {
                return true;
              } else {
                if (shouldAdd) {
                  set._items[type][item] = true;
                }

                return false;
              }
            }

          case 'boolean':
            // set._items['boolean'] holds a two element array
            // representing [ falseExists, trueExists ]
            if (type in set._items) {
              var bIdx = item ? 1 : 0;

              if (set._items[type][bIdx]) {
                return true;
              } else {
                if (shouldAdd) {
                  set._items[type][bIdx] = true;
                }

                return false;
              }
            } else {
              if (shouldAdd) {
                set._items[type] = item ? [false, true] : [true, false];
              }

              return false;
            }

          case 'function':
            // compare functions for reference equality
            if (set._nativeSet !== null) {
              if (shouldAdd) {
                prevSize = set._nativeSet.size;

                set._nativeSet.add(item);

                newSize = set._nativeSet.size;
                return newSize === prevSize;
              } else {
                return set._nativeSet.has(item);
              }
            } else {
              if (!(type in set._items)) {
                if (shouldAdd) {
                  set._items[type] = [item];
                }

                return false;
              }

              if (!_includes(item, set._items[type])) {
                if (shouldAdd) {
                  set._items[type].push(item);
                }

                return false;
              }

              return true;
            }

          case 'undefined':
            if (set._items[type]) {
              return true;
            } else {
              if (shouldAdd) {
                set._items[type] = true;
              }

              return false;
            }

          case 'object':
            if (item === null) {
              if (!set._items['null']) {
                if (shouldAdd) {
                  set._items['null'] = true;
                }

                return false;
              }

              return true;
            }

          /* falls through */

          default:
            // reduce the search size of heterogeneous sets by creating buckets
            // for each type.
            type = Object.prototype.toString.call(item);

            if (!(type in set._items)) {
              if (shouldAdd) {
                set._items[type] = [item];
              }

              return false;
            } // scan through all previously applied items


            if (!_includes(item, set._items[type])) {
              if (shouldAdd) {
                set._items[type].push(item);
              }

              return false;
            }

            return true;
        }
      } // A simple Set type that honours R.equals semantics


      var _Set$1 = _Set;

      /**
       * Finds the set (i.e. no duplicates) of all elements in the first list not
       * contained in the second list. Objects and Arrays are compared in terms of
       * value equality, not reference equality.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Relation
       * @sig [*] -> [*] -> [*]
       * @param {Array} list1 The first list.
       * @param {Array} list2 The second list.
       * @return {Array} The elements in `list1` that are not in `list2`.
       * @see R.differenceWith, R.symmetricDifference, R.symmetricDifferenceWith, R.without
       * @example
       *
       *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
       *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
       *      R.difference([{a: 1}, {b: 2}], [{a: 1}, {c: 3}]) //=> [{b: 2}]
       */

      var difference =
      /*#__PURE__*/
      _curry2(function difference(first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        var secondLen = second.length;
        var toFilterOut = new _Set$1();

        for (var i = 0; i < secondLen; i += 1) {
          toFilterOut.add(second[i]);
        }

        while (idx < firstLen) {
          if (toFilterOut.add(first[idx])) {
            out[out.length] = first[idx];
          }

          idx += 1;
        }

        return out;
      });

      var difference$1 = exports('difference', difference);

      /**
       * Finds the set (i.e. no duplicates) of all elements in the first list not
       * contained in the second list. Duplication is determined according to the
       * value returned by applying the supplied predicate to two list elements.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Relation
       * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
       * @param {Function} pred A predicate used to test whether two items are equal.
       * @param {Array} list1 The first list.
       * @param {Array} list2 The second list.
       * @return {Array} The elements in `list1` that are not in `list2`.
       * @see R.difference, R.symmetricDifference, R.symmetricDifferenceWith
       * @example
       *
       *      const cmp = (x, y) => x.a === y.a;
       *      const l1 = [{a: 1}, {a: 2}, {a: 3}];
       *      const l2 = [{a: 3}, {a: 4}];
       *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
       */

      var differenceWith =
      /*#__PURE__*/
      _curry3(function differenceWith(pred, first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;

        while (idx < firstLen) {
          if (!_includesWith(pred, first[idx], second) && !_includesWith(pred, first[idx], out)) {
            out.push(first[idx]);
          }

          idx += 1;
        }

        return out;
      });

      var differenceWith$1 = exports('differenceWith', differenceWith);

      /**
       * Returns a new object that does not contain a `prop` property.
       *
       * @func
       * @memberOf R
       * @since v0.10.0
       * @category Object
       * @sig String -> {k: v} -> {k: v}
       * @param {String} prop The name of the property to dissociate
       * @param {Object} obj The object to clone
       * @return {Object} A new object equivalent to the original but without the specified property
       * @see R.assoc, R.omit
       * @example
       *
       *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
       */

      var dissoc =
      /*#__PURE__*/
      _curry2(function dissoc(prop, obj) {
        var result = {};

        for (var p in obj) {
          result[p] = obj[p];
        }

        delete result[prop];
        return result;
      });

      var dissoc$1 = exports('dissoc', dissoc);

      /**
       * Removes the sub-list of `list` starting at index `start` and containing
       * `count` elements. _Note that this is not destructive_: it returns a copy of
       * the list with the changes.
       * <small>No lists have been harmed in the application of this function.</small>
       *
       * @func
       * @memberOf R
       * @since v0.2.2
       * @category List
       * @sig Number -> Number -> [a] -> [a]
       * @param {Number} start The position to start removing elements
       * @param {Number} count The number of elements to remove
       * @param {Array} list The list to remove from
       * @return {Array} A new Array with `count` elements from `start` removed.
       * @see R.without
       * @example
       *
       *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
       */

      var remove =
      /*#__PURE__*/
      _curry3(function remove(start, count, list) {
        var result = Array.prototype.slice.call(list, 0);
        result.splice(start, count);
        return result;
      });

      var remove$1 = exports('remove', remove);

      /**
       * Returns a new copy of the array with the element at the provided index
       * replaced with the given value.
       *
       * @func
       * @memberOf R
       * @since v0.14.0
       * @category List
       * @sig Number -> a -> [a] -> [a]
       * @param {Number} idx The index to update.
       * @param {*} x The value to exist at the given index of the returned array.
       * @param {Array|Arguments} list The source array-like object to be updated.
       * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
       * @see R.adjust
       * @example
       *
       *      R.update(1, '_', ['a', 'b', 'c']);      //=> ['a', '_', 'c']
       *      R.update(-1, '_', ['a', 'b', 'c']);     //=> ['a', 'b', '_']
       * @symb R.update(-1, a, [b, c]) = [b, a]
       * @symb R.update(0, a, [b, c]) = [a, c]
       * @symb R.update(1, a, [b, c]) = [b, a]
       */

      var update =
      /*#__PURE__*/
      _curry3(function update(idx, x, list) {
        return adjust$1(idx, always$1(x), list);
      });

      var update$1 = exports('update', update);

      /**
       * Makes a shallow clone of an object, omitting the property at the given path.
       * Note that this copies and flattens prototype properties onto the new object
       * as well. All non-primitive properties are copied by reference.
       *
       * @func
       * @memberOf R
       * @since v0.11.0
       * @category Object
       * @typedefn Idx = String | Int
       * @sig [Idx] -> {k: v} -> {k: v}
       * @param {Array} path The path to the value to omit
       * @param {Object} obj The object to clone
       * @return {Object} A new object without the property at path
       * @see R.assocPath
       * @example
       *
       *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
       */

      var dissocPath =
      /*#__PURE__*/
      _curry2(function dissocPath(path, obj) {
        switch (path.length) {
          case 0:
            return obj;

          case 1:
            return _isInteger(path[0]) && _isArray(obj) ? remove$1(path[0], 1, obj) : dissoc$1(path[0], obj);

          default:
            var head = path[0];
            var tail = Array.prototype.slice.call(path, 1);

            if (obj[head] == null) {
              return obj;
            } else if (_isInteger(head) && _isArray(obj)) {
              return update$1(head, dissocPath(tail, obj[head]), obj);
            } else {
              return assoc$1(head, dissocPath(tail, obj[head]), obj);
            }

        }
      });

      var dissocPath$1 = exports('dissocPath', dissocPath);

      /**
       * Divides two numbers. Equivalent to `a / b`.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Math
       * @sig Number -> Number -> Number
       * @param {Number} a The first value.
       * @param {Number} b The second value.
       * @return {Number} The result of `a / b`.
       * @see R.multiply
       * @example
       *
       *      R.divide(71, 100); //=> 0.71
       *
       *      const half = R.divide(R.__, 2);
       *      half(42); //=> 21
       *
       *      const reciprocal = R.divide(1);
       *      reciprocal(4);   //=> 0.25
       */

      var divide =
      /*#__PURE__*/
      _curry2(function divide(a, b) {
        return a / b;
      });

      var divide$1 = exports('divide', divide);

      var XDrop =
      /*#__PURE__*/
      function () {
        function XDrop(n, xf) {
          this.xf = xf;
          this.n = n;
        }

        XDrop.prototype['@@transducer/init'] = _xfBase.init;
        XDrop.prototype['@@transducer/result'] = _xfBase.result;

        XDrop.prototype['@@transducer/step'] = function (result, input) {
          if (this.n > 0) {
            this.n -= 1;
            return result;
          }

          return this.xf['@@transducer/step'](result, input);
        };

        return XDrop;
      }();

      var _xdrop =
      /*#__PURE__*/
      _curry2(function _xdrop(n, xf) {
        return new XDrop(n, xf);
      });

      var _xdrop$1 = _xdrop;

      /**
       * Returns all but the first `n` elements of the given list, string, or
       * transducer/transformer (or object with a `drop` method).
       *
       * Dispatches to the `drop` method of the second argument, if present.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig Number -> [a] -> [a]
       * @sig Number -> String -> String
       * @param {Number} n
       * @param {*} list
       * @return {*} A copy of list without the first `n` elements
       * @see R.take, R.transduce, R.dropLast, R.dropWhile
       * @example
       *
       *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
       *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
       *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
       *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
       *      R.drop(3, 'ramda');               //=> 'da'
       */

      var drop =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _dispatchable(['drop'], _xdrop$1, function drop(n, xs) {
        return slice$1(Math.max(0, n), Infinity, xs);
      }));

      var drop$1 = exports('drop', drop);

      var XTake =
      /*#__PURE__*/
      function () {
        function XTake(n, xf) {
          this.xf = xf;
          this.n = n;
          this.i = 0;
        }

        XTake.prototype['@@transducer/init'] = _xfBase.init;
        XTake.prototype['@@transducer/result'] = _xfBase.result;

        XTake.prototype['@@transducer/step'] = function (result, input) {
          this.i += 1;
          var ret = this.n === 0 ? result : this.xf['@@transducer/step'](result, input);
          return this.n >= 0 && this.i >= this.n ? _reduced(ret) : ret;
        };

        return XTake;
      }();

      var _xtake =
      /*#__PURE__*/
      _curry2(function _xtake(n, xf) {
        return new XTake(n, xf);
      });

      var _xtake$1 = _xtake;

      /**
       * Returns the first `n` elements of the given list, string, or
       * transducer/transformer (or object with a `take` method).
       *
       * Dispatches to the `take` method of the second argument, if present.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig Number -> [a] -> [a]
       * @sig Number -> String -> String
       * @param {Number} n
       * @param {*} list
       * @return {*}
       * @see R.drop
       * @example
       *
       *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
       *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
       *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
       *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
       *      R.take(3, 'ramda');               //=> 'ram'
       *
       *      const personnel = [
       *        'Dave Brubeck',
       *        'Paul Desmond',
       *        'Eugene Wright',
       *        'Joe Morello',
       *        'Gerry Mulligan',
       *        'Bob Bates',
       *        'Joe Dodge',
       *        'Ron Crotty'
       *      ];
       *
       *      const takeFive = R.take(5);
       *      takeFive(personnel);
       *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
       * @symb R.take(-1, [a, b]) = [a, b]
       * @symb R.take(0, [a, b]) = []
       * @symb R.take(1, [a, b]) = [a]
       * @symb R.take(2, [a, b]) = [a, b]
       */

      var take =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _dispatchable(['take'], _xtake$1, function take(n, xs) {
        return slice$1(0, n < 0 ? Infinity : n, xs);
      }));

      var take$1 = exports('take', take);

      function dropLast$2(n, xs) {
        return take$1(n < xs.length ? xs.length - n : 0, xs);
      }

      var XDropLast =
      /*#__PURE__*/
      function () {
        function XDropLast(n, xf) {
          this.xf = xf;
          this.pos = 0;
          this.full = false;
          this.acc = new Array(n);
        }

        XDropLast.prototype['@@transducer/init'] = _xfBase.init;

        XDropLast.prototype['@@transducer/result'] = function (result) {
          this.acc = null;
          return this.xf['@@transducer/result'](result);
        };

        XDropLast.prototype['@@transducer/step'] = function (result, input) {
          if (this.full) {
            result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
          }

          this.store(input);
          return result;
        };

        XDropLast.prototype.store = function (input) {
          this.acc[this.pos] = input;
          this.pos += 1;

          if (this.pos === this.acc.length) {
            this.pos = 0;
            this.full = true;
          }
        };

        return XDropLast;
      }();

      var _xdropLast =
      /*#__PURE__*/
      _curry2(function _xdropLast(n, xf) {
        return new XDropLast(n, xf);
      });

      var _xdropLast$1 = _xdropLast;

      /**
       * Returns a list containing all but the last `n` elements of the given `list`.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.16.0
       * @category List
       * @sig Number -> [a] -> [a]
       * @sig Number -> String -> String
       * @param {Number} n The number of elements of `list` to skip.
       * @param {Array} list The list of elements to consider.
       * @return {Array} A copy of the list with only the first `list.length - n` elements
       * @see R.takeLast, R.drop, R.dropWhile, R.dropLastWhile
       * @example
       *
       *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
       *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
       *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
       *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
       *      R.dropLast(3, 'ramda');               //=> 'ra'
       */

      var dropLast =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _dispatchable([], _xdropLast$1, dropLast$2));

      var dropLast$1 = exports('dropLast', dropLast);

      function dropLastWhile$2(pred, xs) {
        var idx = xs.length - 1;

        while (idx >= 0 && pred(xs[idx])) {
          idx -= 1;
        }

        return slice$1(0, idx + 1, xs);
      }

      var XDropLastWhile =
      /*#__PURE__*/
      function () {
        function XDropLastWhile(fn, xf) {
          this.f = fn;
          this.retained = [];
          this.xf = xf;
        }

        XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;

        XDropLastWhile.prototype['@@transducer/result'] = function (result) {
          this.retained = null;
          return this.xf['@@transducer/result'](result);
        };

        XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
          return this.f(input) ? this.retain(result, input) : this.flush(result, input);
        };

        XDropLastWhile.prototype.flush = function (result, input) {
          result = _reduce(this.xf['@@transducer/step'], result, this.retained);
          this.retained = [];
          return this.xf['@@transducer/step'](result, input);
        };

        XDropLastWhile.prototype.retain = function (result, input) {
          this.retained.push(input);
          return result;
        };

        return XDropLastWhile;
      }();

      var _xdropLastWhile =
      /*#__PURE__*/
      _curry2(function _xdropLastWhile(fn, xf) {
        return new XDropLastWhile(fn, xf);
      });

      var _xdropLastWhile$1 = _xdropLastWhile;

      /**
       * Returns a new list excluding all the tailing elements of a given list which
       * satisfy the supplied predicate function. It passes each value from the right
       * to the supplied predicate function, skipping elements until the predicate
       * function returns a `falsy` value. The predicate function is applied to one argument:
       * *(value)*.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.16.0
       * @category List
       * @sig (a -> Boolean) -> [a] -> [a]
       * @sig (a -> Boolean) -> String -> String
       * @param {Function} predicate The function to be called on each element
       * @param {Array} xs The collection to iterate over.
       * @return {Array} A new array without any trailing elements that return `falsy` values from the `predicate`.
       * @see R.takeLastWhile, R.addIndex, R.drop, R.dropWhile
       * @example
       *
       *      const lteThree = x => x <= 3;
       *
       *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
       *
       *      R.dropLastWhile(x => x !== 'd' , 'Ramda'); //=> 'Ramd'
       */

      var dropLastWhile =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _dispatchable([], _xdropLastWhile$1, dropLastWhile$2));

      var dropLastWhile$1 = exports('dropLastWhile', dropLastWhile);

      var XDropRepeatsWith =
      /*#__PURE__*/
      function () {
        function XDropRepeatsWith(pred, xf) {
          this.xf = xf;
          this.pred = pred;
          this.lastValue = undefined;
          this.seenFirstValue = false;
        }

        XDropRepeatsWith.prototype['@@transducer/init'] = _xfBase.init;
        XDropRepeatsWith.prototype['@@transducer/result'] = _xfBase.result;

        XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
          var sameAsLast = false;

          if (!this.seenFirstValue) {
            this.seenFirstValue = true;
          } else if (this.pred(this.lastValue, input)) {
            sameAsLast = true;
          }

          this.lastValue = input;
          return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
        };

        return XDropRepeatsWith;
      }();

      var _xdropRepeatsWith =
      /*#__PURE__*/
      _curry2(function _xdropRepeatsWith(pred, xf) {
        return new XDropRepeatsWith(pred, xf);
      });

      var _xdropRepeatsWith$1 = _xdropRepeatsWith;

      /**
       * Returns the last element of the given list or string.
       *
       * @func
       * @memberOf R
       * @since v0.1.4
       * @category List
       * @sig [a] -> a | Undefined
       * @sig String -> String
       * @param {*} list
       * @return {*}
       * @see R.init, R.head, R.tail
       * @example
       *
       *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
       *      R.last([]); //=> undefined
       *
       *      R.last('abc'); //=> 'c'
       *      R.last(''); //=> ''
       */

      var last =
      /*#__PURE__*/
      nth$1(-1);
      var last$1 = exports('last', last);

      /**
       * Returns a new list without any consecutively repeating elements. Equality is
       * determined by applying the supplied predicate to each pair of consecutive elements. The
       * first element in a series of equal elements will be preserved.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.14.0
       * @category List
       * @sig ((a, a) -> Boolean) -> [a] -> [a]
       * @param {Function} pred A predicate used to test whether two items are equal.
       * @param {Array} list The array to consider.
       * @return {Array} `list` without repeating elements.
       * @see R.transduce
       * @example
       *
       *      const l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
       *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
       */

      var dropRepeatsWith =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _dispatchable([], _xdropRepeatsWith$1, function dropRepeatsWith(pred, list) {
        var result = [];
        var idx = 1;
        var len = list.length;

        if (len !== 0) {
          result[0] = list[0];

          while (idx < len) {
            if (!pred(last$1(result), list[idx])) {
              result[result.length] = list[idx];
            }

            idx += 1;
          }
        }

        return result;
      }));

      var dropRepeatsWith$1 = exports('dropRepeatsWith', dropRepeatsWith);

      /**
       * Returns a new list without any consecutively repeating elements.
       * [`R.equals`](#equals) is used to determine equality.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.14.0
       * @category List
       * @sig [a] -> [a]
       * @param {Array} list The array to consider.
       * @return {Array} `list` without repeating elements.
       * @see R.transduce
       * @example
       *
       *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
       */

      var dropRepeats =
      /*#__PURE__*/
      _curry1(
      /*#__PURE__*/
      _dispatchable([],
      /*#__PURE__*/
      _xdropRepeatsWith$1(equals$1),
      /*#__PURE__*/
      dropRepeatsWith$1(equals$1)));

      var dropRepeats$1 = exports('dropRepeats', dropRepeats);

      var XDropWhile =
      /*#__PURE__*/
      function () {
        function XDropWhile(f, xf) {
          this.xf = xf;
          this.f = f;
        }

        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;

        XDropWhile.prototype['@@transducer/step'] = function (result, input) {
          if (this.f) {
            if (this.f(input)) {
              return result;
            }

            this.f = null;
          }

          return this.xf['@@transducer/step'](result, input);
        };

        return XDropWhile;
      }();

      var _xdropWhile =
      /*#__PURE__*/
      _curry2(function _xdropWhile(f, xf) {
        return new XDropWhile(f, xf);
      });

      var _xdropWhile$1 = _xdropWhile;

      /**
       * Returns a new list excluding the leading elements of a given list which
       * satisfy the supplied predicate function. It passes each value to the supplied
       * predicate function, skipping elements while the predicate function returns
       * `true`. The predicate function is applied to one argument: *(value)*.
       *
       * Dispatches to the `dropWhile` method of the second argument, if present.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.9.0
       * @category List
       * @sig (a -> Boolean) -> [a] -> [a]
       * @sig (a -> Boolean) -> String -> String
       * @param {Function} fn The function called per iteration.
       * @param {Array} xs The collection to iterate over.
       * @return {Array} A new array.
       * @see R.takeWhile, R.transduce, R.addIndex
       * @example
       *
       *      const lteTwo = x => x <= 2;
       *
       *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
       *
       *      R.dropWhile(x => x !== 'd' , 'Ramda'); //=> 'da'
       */

      var dropWhile =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _dispatchable(['dropWhile'], _xdropWhile$1, function dropWhile(pred, xs) {
        var idx = 0;
        var len = xs.length;

        while (idx < len && pred(xs[idx])) {
          idx += 1;
        }

        return slice$1(idx, Infinity, xs);
      }));

      var dropWhile$1 = exports('dropWhile', dropWhile);

      /**
       * Returns `true` if one or both of its arguments are `true`. Returns `false`
       * if both arguments are `false`.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Logic
       * @sig a -> b -> a | b
       * @param {Any} a
       * @param {Any} b
       * @return {Any} the first argument if truthy, otherwise the second argument.
       * @see R.either, R.xor
       * @example
       *
       *      R.or(true, true); //=> true
       *      R.or(true, false); //=> true
       *      R.or(false, true); //=> true
       *      R.or(false, false); //=> false
       */

      var or =
      /*#__PURE__*/
      _curry2(function or(a, b) {
        return a || b;
      });

      var or$1 = exports('or', or);

      /**
       * A function wrapping calls to the two functions in an `||` operation,
       * returning the result of the first function if it is truth-y and the result
       * of the second function otherwise. Note that this is short-circuited,
       * meaning that the second function will not be invoked if the first returns a
       * truth-y value.
       *
       * In addition to functions, `R.either` also accepts any fantasy-land compatible
       * applicative functor.
       *
       * @func
       * @memberOf R
       * @since v0.12.0
       * @category Logic
       * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
       * @param {Function} f a predicate
       * @param {Function} g another predicate
       * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
       * @see R.or
       * @example
       *
       *      const gt10 = x => x > 10;
       *      const even = x => x % 2 === 0;
       *      const f = R.either(gt10, even);
       *      f(101); //=> true
       *      f(8); //=> true
       *
       *      R.either(Maybe.Just(false), Maybe.Just(55)); // => Maybe.Just(55)
       *      R.either([false, false, 'a'], [11]) // => [11, 11, "a"]
       */

      var either =
      /*#__PURE__*/
      _curry2(function either(f, g) {
        return _isFunction(f) ? function _either() {
          return f.apply(this, arguments) || g.apply(this, arguments);
        } : lift$1(or$1)(f, g);
      });

      var either$1 = exports('either', either);

      /**
       * Returns the empty value of its argument's type. Ramda defines the empty
       * value of Array (`[]`), Object (`{}`), String (`''`), and Arguments. Other
       * types are supported if they define `<Type>.empty`,
       * `<Type>.prototype.empty` or implement the
       * [FantasyLand Monoid spec](https://github.com/fantasyland/fantasy-land#monoid).
       *
       * Dispatches to the `empty` method of the first argument, if present.
       *
       * @func
       * @memberOf R
       * @since v0.3.0
       * @category Function
       * @sig a -> a
       * @param {*} x
       * @return {*}
       * @example
       *
       *      R.empty(Just(42));      //=> Nothing()
       *      R.empty([1, 2, 3]);     //=> []
       *      R.empty('unicorns');    //=> ''
       *      R.empty({x: 1, y: 2});  //=> {}
       */

      var empty =
      /*#__PURE__*/
      _curry1(function empty(x) {
        return x != null && typeof x['fantasy-land/empty'] === 'function' ? x['fantasy-land/empty']() : x != null && x.constructor != null && typeof x.constructor['fantasy-land/empty'] === 'function' ? x.constructor['fantasy-land/empty']() : x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments$1(x) ? function () {
          return arguments;
        }() : void 0 // else
        ;
      });

      var empty$1 = exports('empty', empty);

      /**
       * Returns a new list containing the last `n` elements of the given list.
       * If `n > list.length`, returns a list of `list.length` elements.
       *
       * @func
       * @memberOf R
       * @since v0.16.0
       * @category List
       * @sig Number -> [a] -> [a]
       * @sig Number -> String -> String
       * @param {Number} n The number of elements to return.
       * @param {Array} xs The collection to consider.
       * @return {Array}
       * @see R.dropLast
       * @example
       *
       *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
       *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
       *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
       *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
       *      R.takeLast(3, 'ramda');               //=> 'mda'
       */

      var takeLast =
      /*#__PURE__*/
      _curry2(function takeLast(n, xs) {
        return drop$1(n >= 0 ? xs.length - n : 0, xs);
      });

      var takeLast$1 = exports('takeLast', takeLast);

      /**
       * Checks if a list ends with the provided sublist.
       *
       * Similarly, checks if a string ends with the provided substring.
       *
       * @func
       * @memberOf R
       * @since v0.24.0
       * @category List
       * @sig [a] -> [a] -> Boolean
       * @sig String -> String -> Boolean
       * @param {*} suffix
       * @param {*} list
       * @return {Boolean}
       * @see R.startsWith
       * @example
       *
       *      R.endsWith('c', 'abc')                //=> true
       *      R.endsWith('b', 'abc')                //=> false
       *      R.endsWith(['c'], ['a', 'b', 'c'])    //=> true
       *      R.endsWith(['b'], ['a', 'b', 'c'])    //=> false
       */

      var endsWith =
      /*#__PURE__*/
      _curry2(function (suffix, list) {
        return equals$1(takeLast$1(suffix.length, list), suffix);
      });

      var endsWith$1 = exports('endsWith', endsWith);

      /**
       * Takes a function and two values in its domain and returns `true` if the
       * values map to the same value in the codomain; `false` otherwise.
       *
       * @func
       * @memberOf R
       * @since v0.18.0
       * @category Relation
       * @sig (a -> b) -> a -> a -> Boolean
       * @param {Function} f
       * @param {*} x
       * @param {*} y
       * @return {Boolean}
       * @example
       *
       *      R.eqBy(Math.abs, 5, -5); //=> true
       */

      var eqBy =
      /*#__PURE__*/
      _curry3(function eqBy(f, x, y) {
        return equals$1(f(x), f(y));
      });

      var eqBy$1 = exports('eqBy', eqBy);

      /**
       * Reports whether two objects have the same value, in [`R.equals`](#equals)
       * terms, for the specified property. Useful as a curried predicate.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Object
       * @sig k -> {k: v} -> {k: v} -> Boolean
       * @param {String} prop The name of the property to compare
       * @param {Object} obj1
       * @param {Object} obj2
       * @return {Boolean}
       *
       * @example
       *
       *      const o1 = { a: 1, b: 2, c: 3, d: 4 };
       *      const o2 = { a: 10, b: 20, c: 3, d: 40 };
       *      R.eqProps('a', o1, o2); //=> false
       *      R.eqProps('c', o1, o2); //=> true
       */

      var eqProps =
      /*#__PURE__*/
      _curry3(function eqProps(prop, obj1, obj2) {
        return equals$1(obj1[prop], obj2[prop]);
      });

      var eqProps$1 = exports('eqProps', eqProps);

      /**
       * Creates a new object by recursively evolving a shallow copy of `object`,
       * according to the `transformation` functions. All non-primitive properties
       * are copied by reference.
       *
       * A `transformation` function will not be invoked if its corresponding key
       * does not exist in the evolved object.
       *
       * @func
       * @memberOf R
       * @since v0.9.0
       * @category Object
       * @sig {k: (v -> v)} -> {k: v} -> {k: v}
       * @param {Object} transformations The object specifying transformation functions to apply
       *        to the object.
       * @param {Object} object The object to be transformed.
       * @return {Object} The transformed object.
       * @example
       *
       *      const tomato = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
       *      const transformations = {
       *        firstName: R.trim,
       *        lastName: R.trim, // Will not get invoked.
       *        data: {elapsed: R.add(1), remaining: R.add(-1)}
       *      };
       *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
       */

      var evolve =
      /*#__PURE__*/
      _curry2(function evolve(transformations, object) {
        var result = object instanceof Array ? [] : {};
        var transformation, key, type;

        for (key in object) {
          transformation = transformations[key];
          type = typeof transformation;
          result[key] = type === 'function' ? transformation(object[key]) : transformation && type === 'object' ? evolve(transformation, object[key]) : object[key];
        }

        return result;
      });

      var evolve$1 = exports('evolve', evolve);

      var XFind =
      /*#__PURE__*/
      function () {
        function XFind(f, xf) {
          this.xf = xf;
          this.f = f;
          this.found = false;
        }

        XFind.prototype['@@transducer/init'] = _xfBase.init;

        XFind.prototype['@@transducer/result'] = function (result) {
          if (!this.found) {
            result = this.xf['@@transducer/step'](result, void 0);
          }

          return this.xf['@@transducer/result'](result);
        };

        XFind.prototype['@@transducer/step'] = function (result, input) {
          if (this.f(input)) {
            this.found = true;
            result = _reduced(this.xf['@@transducer/step'](result, input));
          }

          return result;
        };

        return XFind;
      }();

      var _xfind =
      /*#__PURE__*/
      _curry2(function _xfind(f, xf) {
        return new XFind(f, xf);
      });

      var _xfind$1 = _xfind;

      /**
       * Returns the first element of the list which matches the predicate, or
       * `undefined` if no element matches.
       *
       * Dispatches to the `find` method of the second argument, if present.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig (a -> Boolean) -> [a] -> a | undefined
       * @param {Function} fn The predicate function used to determine if the element is the
       *        desired one.
       * @param {Array} list The array to consider.
       * @return {Object} The element found, or `undefined`.
       * @see R.transduce
       * @example
       *
       *      const xs = [{a: 1}, {a: 2}, {a: 3}];
       *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
       *      R.find(R.propEq('a', 4))(xs); //=> undefined
       */

      var find =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _dispatchable(['find'], _xfind$1, function find(fn, list) {
        var idx = 0;
        var len = list.length;

        while (idx < len) {
          if (fn(list[idx])) {
            return list[idx];
          }

          idx += 1;
        }
      }));

      var find$1 = exports('find', find);

      var XFindIndex =
      /*#__PURE__*/
      function () {
        function XFindIndex(f, xf) {
          this.xf = xf;
          this.f = f;
          this.idx = -1;
          this.found = false;
        }

        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;

        XFindIndex.prototype['@@transducer/result'] = function (result) {
          if (!this.found) {
            result = this.xf['@@transducer/step'](result, -1);
          }

          return this.xf['@@transducer/result'](result);
        };

        XFindIndex.prototype['@@transducer/step'] = function (result, input) {
          this.idx += 1;

          if (this.f(input)) {
            this.found = true;
            result = _reduced(this.xf['@@transducer/step'](result, this.idx));
          }

          return result;
        };

        return XFindIndex;
      }();

      var _xfindIndex =
      /*#__PURE__*/
      _curry2(function _xfindIndex(f, xf) {
        return new XFindIndex(f, xf);
      });

      var _xfindIndex$1 = _xfindIndex;

      /**
       * Returns the index of the first element of the list which matches the
       * predicate, or `-1` if no element matches.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.1.1
       * @category List
       * @sig (a -> Boolean) -> [a] -> Number
       * @param {Function} fn The predicate function used to determine if the element is the
       * desired one.
       * @param {Array} list The array to consider.
       * @return {Number} The index of the element found, or `-1`.
       * @see R.transduce
       * @example
       *
       *      const xs = [{a: 1}, {a: 2}, {a: 3}];
       *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
       *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
       */

      var findIndex =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _dispatchable([], _xfindIndex$1, function findIndex(fn, list) {
        var idx = 0;
        var len = list.length;

        while (idx < len) {
          if (fn(list[idx])) {
            return idx;
          }

          idx += 1;
        }

        return -1;
      }));

      var findIndex$1 = exports('findIndex', findIndex);

      var XFindLast =
      /*#__PURE__*/
      function () {
        function XFindLast(f, xf) {
          this.xf = xf;
          this.f = f;
        }

        XFindLast.prototype['@@transducer/init'] = _xfBase.init;

        XFindLast.prototype['@@transducer/result'] = function (result) {
          return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
        };

        XFindLast.prototype['@@transducer/step'] = function (result, input) {
          if (this.f(input)) {
            this.last = input;
          }

          return result;
        };

        return XFindLast;
      }();

      var _xfindLast =
      /*#__PURE__*/
      _curry2(function _xfindLast(f, xf) {
        return new XFindLast(f, xf);
      });

      var _xfindLast$1 = _xfindLast;

      /**
       * Returns the last element of the list which matches the predicate, or
       * `undefined` if no element matches.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.1.1
       * @category List
       * @sig (a -> Boolean) -> [a] -> a | undefined
       * @param {Function} fn The predicate function used to determine if the element is the
       * desired one.
       * @param {Array} list The array to consider.
       * @return {Object} The element found, or `undefined`.
       * @see R.transduce
       * @example
       *
       *      const xs = [{a: 1, b: 0}, {a:1, b: 1}];
       *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
       *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
       */

      var findLast =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _dispatchable([], _xfindLast$1, function findLast(fn, list) {
        var idx = list.length - 1;

        while (idx >= 0) {
          if (fn(list[idx])) {
            return list[idx];
          }

          idx -= 1;
        }
      }));

      var findLast$1 = exports('findLast', findLast);

      var XFindLastIndex =
      /*#__PURE__*/
      function () {
        function XFindLastIndex(f, xf) {
          this.xf = xf;
          this.f = f;
          this.idx = -1;
          this.lastIdx = -1;
        }

        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;

        XFindLastIndex.prototype['@@transducer/result'] = function (result) {
          return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
        };

        XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
          this.idx += 1;

          if (this.f(input)) {
            this.lastIdx = this.idx;
          }

          return result;
        };

        return XFindLastIndex;
      }();

      var _xfindLastIndex =
      /*#__PURE__*/
      _curry2(function _xfindLastIndex(f, xf) {
        return new XFindLastIndex(f, xf);
      });

      var _xfindLastIndex$1 = _xfindLastIndex;

      /**
       * Returns the index of the last element of the list which matches the
       * predicate, or `-1` if no element matches.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.1.1
       * @category List
       * @sig (a -> Boolean) -> [a] -> Number
       * @param {Function} fn The predicate function used to determine if the element is the
       * desired one.
       * @param {Array} list The array to consider.
       * @return {Number} The index of the element found, or `-1`.
       * @see R.transduce
       * @example
       *
       *      const xs = [{a: 1, b: 0}, {a:1, b: 1}];
       *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
       *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
       */

      var findLastIndex =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _dispatchable([], _xfindLastIndex$1, function findLastIndex(fn, list) {
        var idx = list.length - 1;

        while (idx >= 0) {
          if (fn(list[idx])) {
            return idx;
          }

          idx -= 1;
        }

        return -1;
      }));

      var findLastIndex$1 = exports('findLastIndex', findLastIndex);

      /**
       * Returns a new list by pulling every item out of it (and all its sub-arrays)
       * and putting them in a new array, depth-first.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig [a] -> [b]
       * @param {Array} list The array to consider.
       * @return {Array} The flattened list.
       * @see R.unnest
       * @example
       *
       *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
       *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
       */

      var flatten =
      /*#__PURE__*/
      _curry1(
      /*#__PURE__*/
      _makeFlat(true));

      var flatten$1 = exports('flatten', flatten);

      /**
       * Returns a new function much like the supplied one, except that the first two
       * arguments' order is reversed.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Function
       * @sig ((a, b, c, ...) -> z) -> (b -> a -> c -> ... -> z)
       * @param {Function} fn The function to invoke with its first two parameters reversed.
       * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
       * @example
       *
       *      const mergeThree = (a, b, c) => [].concat(a, b, c);
       *
       *      mergeThree(1, 2, 3); //=> [1, 2, 3]
       *
       *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
       * @symb R.flip(f)(a, b, c) = f(b, a, c)
       */

      var flip =
      /*#__PURE__*/
      _curry1(function flip(fn) {
        return curryN$1(fn.length, function (a, b) {
          var args = Array.prototype.slice.call(arguments, 0);
          args[0] = b;
          args[1] = a;
          return fn.apply(this, args);
        });
      });

      var flip$1 = exports('flip', flip);

      /**
       * Iterate over an input `list`, calling a provided function `fn` for each
       * element in the list.
       *
       * `fn` receives one argument: *(value)*.
       *
       * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
       * arrays), unlike the native `Array.prototype.forEach` method. For more
       * details on this behavior, see:
       * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
       *
       * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
       * the original array. In some libraries this function is named `each`.
       *
       * Dispatches to the `forEach` method of the second argument, if present.
       *
       * @func
       * @memberOf R
       * @since v0.1.1
       * @category List
       * @sig (a -> *) -> [a] -> [a]
       * @param {Function} fn The function to invoke. Receives one argument, `value`.
       * @param {Array} list The list to iterate over.
       * @return {Array} The original list.
       * @see R.addIndex
       * @example
       *
       *      const printXPlusFive = x => console.log(x + 5);
       *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
       *      // logs 6
       *      // logs 7
       *      // logs 8
       * @symb R.forEach(f, [a, b, c]) = [a, b, c]
       */

      var forEach =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _checkForMethod('forEach', function forEach(fn, list) {
        var len = list.length;
        var idx = 0;

        while (idx < len) {
          fn(list[idx]);
          idx += 1;
        }

        return list;
      }));

      var forEach$1 = exports('forEach', forEach);

      /**
       * Iterate over an input `object`, calling a provided function `fn` for each
       * key and value in the object.
       *
       * `fn` receives three argument: *(value, key, obj)*.
       *
       * @func
       * @memberOf R
       * @since v0.23.0
       * @category Object
       * @sig ((a, String, StrMap a) -> Any) -> StrMap a -> StrMap a
       * @param {Function} fn The function to invoke. Receives three argument, `value`, `key`, `obj`.
       * @param {Object} obj The object to iterate over.
       * @return {Object} The original object.
       * @example
       *
       *      const printKeyConcatValue = (value, key) => console.log(key + ':' + value);
       *      R.forEachObjIndexed(printKeyConcatValue, {x: 1, y: 2}); //=> {x: 1, y: 2}
       *      // logs x:1
       *      // logs y:2
       * @symb R.forEachObjIndexed(f, {x: a, y: b}) = {x: a, y: b}
       */

      var forEachObjIndexed =
      /*#__PURE__*/
      _curry2(function forEachObjIndexed(fn, obj) {
        var keyList = keys$1(obj);
        var idx = 0;

        while (idx < keyList.length) {
          var key = keyList[idx];
          fn(obj[key], key, obj);
          idx += 1;
        }

        return obj;
      });

      var forEachObjIndexed$1 = exports('forEachObjIndexed', forEachObjIndexed);

      /**
       * Creates a new object from a list key-value pairs. If a key appears in
       * multiple pairs, the rightmost pair is included in the object.
       *
       * @func
       * @memberOf R
       * @since v0.3.0
       * @category List
       * @sig [[k,v]] -> {k: v}
       * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
       * @return {Object} The object made by pairing up `keys` and `values`.
       * @see R.toPairs, R.pair
       * @example
       *
       *      R.fromPairs([['a', 1], ['b', 2], ['c', 3]]); //=> {a: 1, b: 2, c: 3}
       */

      var fromPairs =
      /*#__PURE__*/
      _curry1(function fromPairs(pairs) {
        var result = {};
        var idx = 0;

        while (idx < pairs.length) {
          result[pairs[idx][0]] = pairs[idx][1];
          idx += 1;
        }

        return result;
      });

      var fromPairs$1 = exports('fromPairs', fromPairs);

      /**
       * Splits a list into sub-lists stored in an object, based on the result of
       * calling a String-returning function on each element, and grouping the
       * results according to values returned.
       *
       * Dispatches to the `groupBy` method of the second argument, if present.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig (a -> String) -> [a] -> {String: [a]}
       * @param {Function} fn Function :: a -> String
       * @param {Array} list The array to group
       * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
       *         that produced that key when passed to `fn`.
       * @see R.reduceBy, R.transduce
       * @example
       *
       *      const byGrade = R.groupBy(function(student) {
       *        const score = student.score;
       *        return score < 65 ? 'F' :
       *               score < 70 ? 'D' :
       *               score < 80 ? 'C' :
       *               score < 90 ? 'B' : 'A';
       *      });
       *      const students = [{name: 'Abby', score: 84},
       *                      {name: 'Eddy', score: 58},
       *                      // ...
       *                      {name: 'Jack', score: 69}];
       *      byGrade(students);
       *      // {
       *      //   'A': [{name: 'Dianne', score: 99}],
       *      //   'B': [{name: 'Abby', score: 84}]
       *      //   // ...,
       *      //   'F': [{name: 'Eddy', score: 58}]
       *      // }
       */

      var groupBy =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _checkForMethod('groupBy',
      /*#__PURE__*/
      reduceBy$1(function (acc, item) {
        if (acc == null) {
          acc = [];
        }

        acc.push(item);
        return acc;
      }, null)));

      var groupBy$1 = exports('groupBy', groupBy);

      /**
       * Takes a list and returns a list of lists where each sublist's elements are
       * all satisfied pairwise comparison according to the provided function.
       * Only adjacent elements are passed to the comparison function.
       *
       * @func
       * @memberOf R
       * @since v0.21.0
       * @category List
       * @sig ((a, a) → Boolean) → [a] → [[a]]
       * @param {Function} fn Function for determining whether two given (adjacent)
       *        elements should be in the same group
       * @param {Array} list The array to group. Also accepts a string, which will be
       *        treated as a list of characters.
       * @return {List} A list that contains sublists of elements,
       *         whose concatenations are equal to the original list.
       * @example
       *
       * R.groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])
       * //=> [[0], [1, 1], [2], [3], [5], [8], [13], [21]]
       *
       * R.groupWith((a, b) => a + 1 === b, [0, 1, 1, 2, 3, 5, 8, 13, 21])
       * //=> [[0, 1], [1, 2, 3], [5], [8], [13], [21]]
       *
       * R.groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])
       * //=> [[0], [1, 1], [2], [3, 5], [8], [13, 21]]
       *
       * R.groupWith(R.eqBy(isVowel), 'aestiou')
       * //=> ['ae', 'st', 'iou']
       */

      var groupWith =
      /*#__PURE__*/
      _curry2(function (fn, list) {
        var res = [];
        var idx = 0;
        var len = list.length;

        while (idx < len) {
          var nextidx = idx + 1;

          while (nextidx < len && fn(list[nextidx - 1], list[nextidx])) {
            nextidx += 1;
          }

          res.push(list.slice(idx, nextidx));
          idx = nextidx;
        }

        return res;
      });

      var groupWith$1 = exports('groupWith', groupWith);

      /**
       * Returns `true` if the first argument is greater than the second; `false`
       * otherwise.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Relation
       * @sig Ord a => a -> a -> Boolean
       * @param {*} a
       * @param {*} b
       * @return {Boolean}
       * @see R.lt
       * @example
       *
       *      R.gt(2, 1); //=> true
       *      R.gt(2, 2); //=> false
       *      R.gt(2, 3); //=> false
       *      R.gt('a', 'z'); //=> false
       *      R.gt('z', 'a'); //=> true
       */

      var gt =
      /*#__PURE__*/
      _curry2(function gt(a, b) {
        return a > b;
      });

      var gt$1 = exports('gt', gt);

      /**
       * Returns `true` if the first argument is greater than or equal to the second;
       * `false` otherwise.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Relation
       * @sig Ord a => a -> a -> Boolean
       * @param {Number} a
       * @param {Number} b
       * @return {Boolean}
       * @see R.lte
       * @example
       *
       *      R.gte(2, 1); //=> true
       *      R.gte(2, 2); //=> true
       *      R.gte(2, 3); //=> false
       *      R.gte('a', 'z'); //=> false
       *      R.gte('z', 'a'); //=> true
       */

      var gte =
      /*#__PURE__*/
      _curry2(function gte(a, b) {
        return a >= b;
      });

      var gte$1 = exports('gte', gte);

      /**
       * Returns whether or not a path exists in an object. Only the object's
       * own properties are checked.
       *
       * @func
       * @memberOf R
       * @since v0.26.0
       * @category Object
       * @typedefn Idx = String | Int
       * @sig [Idx] -> {a} -> Boolean
       * @param {Array} path The path to use.
       * @param {Object} obj The object to check the path in.
       * @return {Boolean} Whether the path exists.
       * @see R.has
       * @example
       *
       *      R.hasPath(['a', 'b'], {a: {b: 2}});         // => true
       *      R.hasPath(['a', 'b'], {a: {b: undefined}}); // => true
       *      R.hasPath(['a', 'b'], {a: {c: 2}});         // => false
       *      R.hasPath(['a', 'b'], {});                  // => false
       */

      var hasPath =
      /*#__PURE__*/
      _curry2(function hasPath(_path, obj) {
        if (_path.length === 0 || isNil$1(obj)) {
          return false;
        }

        var val = obj;
        var idx = 0;

        while (idx < _path.length) {
          if (!isNil$1(val) && _has(_path[idx], val)) {
            val = val[_path[idx]];
            idx += 1;
          } else {
            return false;
          }
        }

        return true;
      });

      var hasPath$1 = exports('hasPath', hasPath);

      /**
       * Returns whether or not an object has an own property with the specified name
       *
       * @func
       * @memberOf R
       * @since v0.7.0
       * @category Object
       * @sig s -> {s: x} -> Boolean
       * @param {String} prop The name of the property to check for.
       * @param {Object} obj The object to query.
       * @return {Boolean} Whether the property exists.
       * @example
       *
       *      const hasName = R.has('name');
       *      hasName({name: 'alice'});   //=> true
       *      hasName({name: 'bob'});     //=> true
       *      hasName({});                //=> false
       *
       *      const point = {x: 0, y: 0};
       *      const pointHas = R.has(R.__, point);
       *      pointHas('x');  //=> true
       *      pointHas('y');  //=> true
       *      pointHas('z');  //=> false
       */

      var has =
      /*#__PURE__*/
      _curry2(function has(prop, obj) {
        return hasPath$1([prop], obj);
      });

      var has$1 = exports('has', has);

      /**
       * Returns whether or not an object or its prototype chain has a property with
       * the specified name
       *
       * @func
       * @memberOf R
       * @since v0.7.0
       * @category Object
       * @sig s -> {s: x} -> Boolean
       * @param {String} prop The name of the property to check for.
       * @param {Object} obj The object to query.
       * @return {Boolean} Whether the property exists.
       * @example
       *
       *      function Rectangle(width, height) {
       *        this.width = width;
       *        this.height = height;
       *      }
       *      Rectangle.prototype.area = function() {
       *        return this.width * this.height;
       *      };
       *
       *      const square = new Rectangle(2, 2);
       *      R.hasIn('width', square);  //=> true
       *      R.hasIn('area', square);  //=> true
       */

      var hasIn =
      /*#__PURE__*/
      _curry2(function hasIn(prop, obj) {
        return prop in obj;
      });

      var hasIn$1 = exports('hasIn', hasIn);

      /**
       * Returns true if its arguments are identical, false otherwise. Values are
       * identical if they reference the same memory. `NaN` is identical to `NaN`;
       * `0` and `-0` are not identical.
       *
       * Note this is merely a curried version of ES6 `Object.is`.
       *
       * @func
       * @memberOf R
       * @since v0.15.0
       * @category Relation
       * @sig a -> a -> Boolean
       * @param {*} a
       * @param {*} b
       * @return {Boolean}
       * @example
       *
       *      const o = {};
       *      R.identical(o, o); //=> true
       *      R.identical(1, 1); //=> true
       *      R.identical(1, '1'); //=> false
       *      R.identical([], []); //=> false
       *      R.identical(0, -0); //=> false
       *      R.identical(NaN, NaN); //=> true
       */

      var identical =
      /*#__PURE__*/
      _curry2(_objectIs$1);

      var identical$1 = exports('identical', identical);

      /**
       * Creates a function that will process either the `onTrue` or the `onFalse`
       * function depending upon the result of the `condition` predicate.
       *
       * @func
       * @memberOf R
       * @since v0.8.0
       * @category Logic
       * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
       * @param {Function} condition A predicate function
       * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
       * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
       * @return {Function} A new function that will process either the `onTrue` or the `onFalse`
       *                    function depending upon the result of the `condition` predicate.
       * @see R.unless, R.when, R.cond
       * @example
       *
       *      const incCount = R.ifElse(
       *        R.has('count'),
       *        R.over(R.lensProp('count'), R.inc),
       *        R.assoc('count', 1)
       *      );
       *      incCount({});           //=> { count: 1 }
       *      incCount({ count: 1 }); //=> { count: 2 }
       */

      var ifElse =
      /*#__PURE__*/
      _curry3(function ifElse(condition, onTrue, onFalse) {
        return curryN$1(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
          return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
        });
      });

      var ifElse$1 = exports('ifElse', ifElse);

      /**
       * Increments its argument.
       *
       * @func
       * @memberOf R
       * @since v0.9.0
       * @category Math
       * @sig Number -> Number
       * @param {Number} n
       * @return {Number} n + 1
       * @see R.dec
       * @example
       *
       *      R.inc(42); //=> 43
       */

      var inc =
      /*#__PURE__*/
      add$1(1);
      var inc$1 = exports('inc', inc);

      /**
       * Returns `true` if the specified value is equal, in [`R.equals`](#equals)
       * terms, to at least one element of the given list; `false` otherwise.
       * Works also with strings.
       *
       * @func
       * @memberOf R
       * @since v0.26.0
       * @category List
       * @sig a -> [a] -> Boolean
       * @param {Object} a The item to compare against.
       * @param {Array} list The array to consider.
       * @return {Boolean} `true` if an equivalent item is in the list, `false` otherwise.
       * @see R.any
       * @example
       *
       *      R.includes(3, [1, 2, 3]); //=> true
       *      R.includes(4, [1, 2, 3]); //=> false
       *      R.includes({ name: 'Fred' }, [{ name: 'Fred' }]); //=> true
       *      R.includes([42], [[42]]); //=> true
       *      R.includes('ba', 'banana'); //=>true
       */

      var includes =
      /*#__PURE__*/
      _curry2(_includes);

      var includes$1 = exports('includes', includes);

      /**
       * Given a function that generates a key, turns a list of objects into an
       * object indexing the objects by the given key. Note that if multiple
       * objects generate the same value for the indexing key only the last value
       * will be included in the generated object.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.19.0
       * @category List
       * @sig (a -> String) -> [{k: v}] -> {k: {k: v}}
       * @param {Function} fn Function :: a -> String
       * @param {Array} array The array of objects to index
       * @return {Object} An object indexing each array element by the given property.
       * @example
       *
       *      const list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
       *      R.indexBy(R.prop('id'), list);
       *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
       */

      var indexBy =
      /*#__PURE__*/
      reduceBy$1(function (acc, elem) {
        return elem;
      }, null);
      var indexBy$1 = exports('indexBy', indexBy);

      /**
       * Returns the position of the first occurrence of an item in an array, or -1
       * if the item is not included in the array. [`R.equals`](#equals) is used to
       * determine equality.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig a -> [a] -> Number
       * @param {*} target The item to find.
       * @param {Array} xs The array to search in.
       * @return {Number} the index of the target, or -1 if the target is not found.
       * @see R.lastIndexOf
       * @example
       *
       *      R.indexOf(3, [1,2,3,4]); //=> 2
       *      R.indexOf(10, [1,2,3,4]); //=> -1
       */

      var indexOf =
      /*#__PURE__*/
      _curry2(function indexOf(target, xs) {
        return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
      });

      var indexOf$1 = exports('indexOf', indexOf);

      /**
       * Returns all but the last element of the given list or string.
       *
       * @func
       * @memberOf R
       * @since v0.9.0
       * @category List
       * @sig [a] -> [a]
       * @sig String -> String
       * @param {*} list
       * @return {*}
       * @see R.last, R.head, R.tail
       * @example
       *
       *      R.init([1, 2, 3]);  //=> [1, 2]
       *      R.init([1, 2]);     //=> [1]
       *      R.init([1]);        //=> []
       *      R.init([]);         //=> []
       *
       *      R.init('abc');  //=> 'ab'
       *      R.init('ab');   //=> 'a'
       *      R.init('a');    //=> ''
       *      R.init('');     //=> ''
       */

      var init =
      /*#__PURE__*/
      slice$1(0, -1);
      var init$1 = exports('init', init);

      /**
       * Takes a predicate `pred`, a list `xs`, and a list `ys`, and returns a list
       * `xs'` comprising each of the elements of `xs` which is equal to one or more
       * elements of `ys` according to `pred`.
       *
       * `pred` must be a binary function expecting an element from each list.
       *
       * `xs`, `ys`, and `xs'` are treated as sets, semantically, so ordering should
       * not be significant, but since `xs'` is ordered the implementation guarantees
       * that its values are in the same order as they appear in `xs`. Duplicates are
       * not removed, so `xs'` may contain duplicates if `xs` contains duplicates.
       *
       * @func
       * @memberOf R
       * @since v0.24.0
       * @category Relation
       * @sig ((a, b) -> Boolean) -> [a] -> [b] -> [a]
       * @param {Function} pred
       * @param {Array} xs
       * @param {Array} ys
       * @return {Array}
       * @see R.intersection
       * @example
       *
       *      R.innerJoin(
       *        (record, id) => record.id === id,
       *        [{id: 824, name: 'Richie Furay'},
       *         {id: 956, name: 'Dewey Martin'},
       *         {id: 313, name: 'Bruce Palmer'},
       *         {id: 456, name: 'Stephen Stills'},
       *         {id: 177, name: 'Neil Young'}],
       *        [177, 456, 999]
       *      );
       *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
       */

      var innerJoin =
      /*#__PURE__*/
      _curry3(function innerJoin(pred, xs, ys) {
        return _filter(function (x) {
          return _includesWith(pred, x, ys);
        }, xs);
      });

      var innerJoin$1 = exports('innerJoin', innerJoin);

      /**
       * Inserts the supplied element into the list, at the specified `index`. _Note that

       * this is not destructive_: it returns a copy of the list with the changes.
       * <small>No lists have been harmed in the application of this function.</small>
       *
       * @func
       * @memberOf R
       * @since v0.2.2
       * @category List
       * @sig Number -> a -> [a] -> [a]
       * @param {Number} index The position to insert the element
       * @param {*} elt The element to insert into the Array
       * @param {Array} list The list to insert into
       * @return {Array} A new Array with `elt` inserted at `index`.
       * @example
       *
       *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
       */

      var insert =
      /*#__PURE__*/
      _curry3(function insert(idx, elt, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        var result = Array.prototype.slice.call(list, 0);
        result.splice(idx, 0, elt);
        return result;
      });

      var insert$1 = exports('insert', insert);

      /**
       * Inserts the sub-list into the list, at the specified `index`. _Note that this is not
       * destructive_: it returns a copy of the list with the changes.
       * <small>No lists have been harmed in the application of this function.</small>
       *
       * @func
       * @memberOf R
       * @since v0.9.0
       * @category List
       * @sig Number -> [a] -> [a] -> [a]
       * @param {Number} index The position to insert the sub-list
       * @param {Array} elts The sub-list to insert into the Array
       * @param {Array} list The list to insert the sub-list into
       * @return {Array} A new Array with `elts` inserted starting at `index`.
       * @example
       *
       *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
       */

      var insertAll =
      /*#__PURE__*/
      _curry3(function insertAll(idx, elts, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        return [].concat(Array.prototype.slice.call(list, 0, idx), elts, Array.prototype.slice.call(list, idx));
      });

      var insertAll$1 = exports('insertAll', insertAll);

      /**
       * Returns a new list containing only one copy of each element in the original
       * list, based upon the value returned by applying the supplied function to
       * each list element. Prefers the first item if the supplied function produces
       * the same value on two items. [`R.equals`](#equals) is used for comparison.
       *
       * @func
       * @memberOf R
       * @since v0.16.0
       * @category List
       * @sig (a -> b) -> [a] -> [a]
       * @param {Function} fn A function used to produce a value to use during comparisons.
       * @param {Array} list The array to consider.
       * @return {Array} The list of unique items.
       * @example
       *
       *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
       */

      var uniqBy =
      /*#__PURE__*/
      _curry2(function uniqBy(fn, list) {
        var set = new _Set$1();
        var result = [];
        var idx = 0;
        var appliedItem, item;

        while (idx < list.length) {
          item = list[idx];
          appliedItem = fn(item);

          if (set.add(appliedItem)) {
            result.push(item);
          }

          idx += 1;
        }

        return result;
      });

      var uniqBy$1 = exports('uniqBy', uniqBy);

      /**
       * Returns a new list containing only one copy of each element in the original
       * list. [`R.equals`](#equals) is used to determine equality.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig [a] -> [a]
       * @param {Array} list The array to consider.
       * @return {Array} The list of unique items.
       * @example
       *
       *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
       *      R.uniq([1, '1']);     //=> [1, '1']
       *      R.uniq([[42], [42]]); //=> [[42]]
       */

      var uniq =
      /*#__PURE__*/
      uniqBy$1(identity$1);
      var uniq$1 = exports('uniq', uniq);

      /**
       * Combines two lists into a set (i.e. no duplicates) composed of those
       * elements common to both lists.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Relation
       * @sig [*] -> [*] -> [*]
       * @param {Array} list1 The first list.
       * @param {Array} list2 The second list.
       * @return {Array} The list of elements found in both `list1` and `list2`.
       * @see R.innerJoin
       * @example
       *
       *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
       */

      var intersection =
      /*#__PURE__*/
      _curry2(function intersection(list1, list2) {
        var lookupList, filteredList;

        if (list1.length > list2.length) {
          lookupList = list1;
          filteredList = list2;
        } else {
          lookupList = list2;
          filteredList = list1;
        }

        return uniq$1(_filter(flip$1(_includes)(lookupList), filteredList));
      });

      var intersection$1 = exports('intersection', intersection);

      /**
       * Creates a new list with the separator interposed between elements.
       *
       * Dispatches to the `intersperse` method of the second argument, if present.
       *
       * @func
       * @memberOf R
       * @since v0.14.0
       * @category List
       * @sig a -> [a] -> [a]
       * @param {*} separator The element to add to the list.
       * @param {Array} list The list to be interposed.
       * @return {Array} The new list.
       * @example
       *
       *      R.intersperse('a', ['b', 'n', 'n', 's']); //=> ['b', 'a', 'n', 'a', 'n', 'a', 's']
       */

      var intersperse =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _checkForMethod('intersperse', function intersperse(separator, list) {
        var out = [];
        var idx = 0;
        var length = list.length;

        while (idx < length) {
          if (idx === length - 1) {
            out.push(list[idx]);
          } else {
            out.push(list[idx], separator);
          }

          idx += 1;
        }

        return out;
      }));

      var intersperse$1 = exports('intersperse', intersperse);

      function _objectAssign(target) {
        if (target == null) {
          throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        var idx = 1;
        var length = arguments.length;

        while (idx < length) {
          var source = arguments[idx];

          if (source != null) {
            for (var nextKey in source) {
              if (_has(nextKey, source)) {
                output[nextKey] = source[nextKey];
              }
            }
          }

          idx += 1;
        }

        return output;
      }

      var _objectAssign$1 = typeof Object.assign === 'function' ? Object.assign : _objectAssign;

      /**
       * Creates an object containing a single key:value pair.
       *
       * @func
       * @memberOf R
       * @since v0.18.0
       * @category Object
       * @sig String -> a -> {String:a}
       * @param {String} key
       * @param {*} val
       * @return {Object}
       * @see R.pair
       * @example
       *
       *      const matchPhrases = R.compose(
       *        R.objOf('must'),
       *        R.map(R.objOf('match_phrase'))
       *      );
       *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
       */

      var objOf =
      /*#__PURE__*/
      _curry2(function objOf(key, val) {
        var obj = {};
        obj[key] = val;
        return obj;
      });

      var objOf$1 = exports('objOf', objOf);

      var _stepCatArray = {
        '@@transducer/init': Array,
        '@@transducer/step': function (xs, x) {
          xs.push(x);
          return xs;
        },
        '@@transducer/result': _identity
      };
      var _stepCatString = {
        '@@transducer/init': String,
        '@@transducer/step': function (a, b) {
          return a + b;
        },
        '@@transducer/result': _identity
      };
      var _stepCatObject = {
        '@@transducer/init': Object,
        '@@transducer/step': function (result, input) {
          return _objectAssign$1(result, _isArrayLike$1(input) ? objOf$1(input[0], input[1]) : input);
        },
        '@@transducer/result': _identity
      };
      function _stepCat(obj) {
        if (_isTransformer(obj)) {
          return obj;
        }

        if (_isArrayLike$1(obj)) {
          return _stepCatArray;
        }

        if (typeof obj === 'string') {
          return _stepCatString;
        }

        if (typeof obj === 'object') {
          return _stepCatObject;
        }

        throw new Error('Cannot create transformer for ' + obj);
      }

      /**
       * Transforms the items of the list with the transducer and appends the
       * transformed items to the accumulator using an appropriate iterator function
       * based on the accumulator type.
       *
       * The accumulator can be an array, string, object or a transformer. Iterated
       * items will be appended to arrays and concatenated to strings. Objects will
       * be merged directly or 2-item arrays will be merged as key, value pairs.
       *
       * The accumulator can also be a transformer object that provides a 2-arity
       * reducing iterator function, step, 0-arity initial value function, init, and
       * 1-arity result extraction function result. The step function is used as the
       * iterator function in reduce. The result function is used to convert the
       * final accumulator into the return type and in most cases is R.identity. The
       * init function is used to provide the initial accumulator.
       *
       * The iteration is performed with [`R.reduce`](#reduce) after initializing the
       * transducer.
       *
       * @func
       * @memberOf R
       * @since v0.12.0
       * @category List
       * @sig a -> (b -> b) -> [c] -> a
       * @param {*} acc The initial accumulator value.
       * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
       * @param {Array} list The list to iterate over.
       * @return {*} The final, accumulated value.
       * @see R.transduce
       * @example
       *
       *      const numbers = [1, 2, 3, 4];
       *      const transducer = R.compose(R.map(R.add(1)), R.take(2));
       *
       *      R.into([], transducer, numbers); //=> [2, 3]
       *
       *      const intoArray = R.into([]);
       *      intoArray(transducer, numbers); //=> [2, 3]
       */

      var into =
      /*#__PURE__*/
      _curry3(function into(acc, xf, list) {
        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);
      });

      var into$1 = exports('into', into);

      /**
       * Same as [`R.invertObj`](#invertObj), however this accounts for objects with
       * duplicate values by putting the values into an array.
       *
       * @func
       * @memberOf R
       * @since v0.9.0
       * @category Object
       * @sig {s: x} -> {x: [ s, ... ]}
       * @param {Object} obj The object or array to invert
       * @return {Object} out A new object with keys in an array.
       * @see R.invertObj
       * @example
       *
       *      const raceResultsByFirstName = {
       *        first: 'alice',
       *        second: 'jake',
       *        third: 'alice',
       *      };
       *      R.invert(raceResultsByFirstName);
       *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
       */

      var invert =
      /*#__PURE__*/
      _curry1(function invert(obj) {
        var props = keys$1(obj);
        var len = props.length;
        var idx = 0;
        var out = {};

        while (idx < len) {
          var key = props[idx];
          var val = obj[key];
          var list = _has(val, out) ? out[val] : out[val] = [];
          list[list.length] = key;
          idx += 1;
        }

        return out;
      });

      var invert$1 = exports('invert', invert);

      /**
       * Returns a new object with the keys of the given object as values, and the
       * values of the given object, which are coerced to strings, as keys. Note
       * that the last key found is preferred when handling the same value.
       *
       * @func
       * @memberOf R
       * @since v0.9.0
       * @category Object
       * @sig {s: x} -> {x: s}
       * @param {Object} obj The object or array to invert
       * @return {Object} out A new object
       * @see R.invert
       * @example
       *
       *      const raceResults = {
       *        first: 'alice',
       *        second: 'jake'
       *      };
       *      R.invertObj(raceResults);
       *      //=> { 'alice': 'first', 'jake':'second' }
       *
       *      // Alternatively:
       *      const raceResults = ['alice', 'jake'];
       *      R.invertObj(raceResults);
       *      //=> { 'alice': '0', 'jake':'1' }
       */

      var invertObj =
      /*#__PURE__*/
      _curry1(function invertObj(obj) {
        var props = keys$1(obj);
        var len = props.length;
        var idx = 0;
        var out = {};

        while (idx < len) {
          var key = props[idx];
          out[obj[key]] = key;
          idx += 1;
        }

        return out;
      });

      var invertObj$1 = exports('invertObj', invertObj);

      /**
       * Turns a named method with a specified arity into a function that can be
       * called directly supplied with arguments and a target object.
       *
       * The returned function is curried and accepts `arity + 1` parameters where
       * the final parameter is the target object.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Function
       * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
       * @param {Number} arity Number of arguments the returned function should take
       *        before the target object.
       * @param {String} method Name of any of the target object's methods to call.
       * @return {Function} A new curried function.
       * @see R.construct
       * @example
       *
       *      const sliceFrom = R.invoker(1, 'slice');
       *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
       *      const sliceFrom6 = R.invoker(2, 'slice')(6);
       *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
       *
       *      const dog = {
       *        speak: async () => 'Woof!'
       *      };
       *      const speak = R.invoker(0, 'speak');
       *      speak(dog).then(console.log) //~> 'Woof!'
       *
       * @symb R.invoker(0, 'method')(o) = o['method']()
       * @symb R.invoker(1, 'method')(a, o) = o['method'](a)
       * @symb R.invoker(2, 'method')(a, b, o) = o['method'](a, b)
       */

      var invoker =
      /*#__PURE__*/
      _curry2(function invoker(arity, method) {
        return curryN$1(arity + 1, function () {
          var target = arguments[arity];

          if (target != null && _isFunction(target[method])) {
            return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));
          }

          throw new TypeError(toString$1(target) + ' does not have a method named "' + method + '"');
        });
      });

      var invoker$1 = exports('invoker', invoker);

      /**
       * See if an object (`val`) is an instance of the supplied constructor. This
       * function will check up the inheritance chain, if any.
       *
       * @func
       * @memberOf R
       * @since v0.3.0
       * @category Type
       * @sig (* -> {*}) -> a -> Boolean
       * @param {Object} ctor A constructor
       * @param {*} val The value to test
       * @return {Boolean}
       * @example
       *
       *      R.is(Object, {}); //=> true
       *      R.is(Number, 1); //=> true
       *      R.is(Object, 1); //=> false
       *      R.is(String, 's'); //=> true
       *      R.is(String, new String('')); //=> true
       *      R.is(Object, new String('')); //=> true
       *      R.is(Object, 's'); //=> false
       *      R.is(Number, {}); //=> false
       */

      var is =
      /*#__PURE__*/
      _curry2(function is(Ctor, val) {
        return val != null && val.constructor === Ctor || val instanceof Ctor;
      });

      var is$1 = exports('is', is);

      /**
       * Returns `true` if the given value is its type's empty value; `false`
       * otherwise.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Logic
       * @sig a -> Boolean
       * @param {*} x
       * @return {Boolean}
       * @see R.empty
       * @example
       *
       *      R.isEmpty([1, 2, 3]);   //=> false
       *      R.isEmpty([]);          //=> true
       *      R.isEmpty('');          //=> true
       *      R.isEmpty(null);        //=> false
       *      R.isEmpty({});          //=> true
       *      R.isEmpty({length: 0}); //=> false
       */

      var isEmpty =
      /*#__PURE__*/
      _curry1(function isEmpty(x) {
        return x != null && equals$1(x, empty$1(x));
      });

      var isEmpty$1 = exports('isEmpty', isEmpty);

      /**
       * Returns a string made by inserting the `separator` between each element and
       * concatenating all the elements into a single string.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig String -> [a] -> String
       * @param {Number|String} separator The string used to separate the elements.
       * @param {Array} xs The elements to join into a string.
       * @return {String} str The string made by concatenating `xs` with `separator`.
       * @see R.split
       * @example
       *
       *      const spacer = R.join(' ');
       *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
       *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
       */

      var join =
      /*#__PURE__*/
      invoker$1(1, 'join');
      var join$1 = exports('join', join);

      /**
       * juxt applies a list of functions to a list of values.
       *
       * @func
       * @memberOf R
       * @since v0.19.0
       * @category Function
       * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
       * @param {Array} fns An array of functions
       * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
       * @see R.applySpec
       * @example
       *
       *      const getRange = R.juxt([Math.min, Math.max]);
       *      getRange(3, 4, 9, -3); //=> [-3, 9]
       * @symb R.juxt([f, g, h])(a, b) = [f(a, b), g(a, b), h(a, b)]
       */

      var juxt =
      /*#__PURE__*/
      _curry1(function juxt(fns) {
        return converge$1(function () {
          return Array.prototype.slice.call(arguments, 0);
        }, fns);
      });

      var juxt$1 = exports('juxt', juxt);

      /**
       * Returns a list containing the names of all the properties of the supplied
       * object, including prototype properties.
       * Note that the order of the output array is not guaranteed to be consistent
       * across different JS platforms.
       *
       * @func
       * @memberOf R
       * @since v0.2.0
       * @category Object
       * @sig {k: v} -> [k]
       * @param {Object} obj The object to extract properties from
       * @return {Array} An array of the object's own and prototype properties.
       * @see R.keys, R.valuesIn
       * @example
       *
       *      const F = function() { this.x = 'X'; };
       *      F.prototype.y = 'Y';
       *      const f = new F();
       *      R.keysIn(f); //=> ['x', 'y']
       */

      var keysIn =
      /*#__PURE__*/
      _curry1(function keysIn(obj) {
        var prop;
        var ks = [];

        for (prop in obj) {
          ks[ks.length] = prop;
        }

        return ks;
      });

      var keysIn$1 = exports('keysIn', keysIn);

      /**
       * Returns the position of the last occurrence of an item in an array, or -1 if
       * the item is not included in the array. [`R.equals`](#equals) is used to
       * determine equality.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig a -> [a] -> Number
       * @param {*} target The item to find.
       * @param {Array} xs The array to search in.
       * @return {Number} the index of the target, or -1 if the target is not found.
       * @see R.indexOf
       * @example
       *
       *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
       *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
       */

      var lastIndexOf =
      /*#__PURE__*/
      _curry2(function lastIndexOf(target, xs) {
        if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
          return xs.lastIndexOf(target);
        } else {
          var idx = xs.length - 1;

          while (idx >= 0) {
            if (equals$1(xs[idx], target)) {
              return idx;
            }

            idx -= 1;
          }

          return -1;
        }
      });

      var lastIndexOf$1 = exports('lastIndexOf', lastIndexOf);

      function _isNumber(x) {
        return Object.prototype.toString.call(x) === '[object Number]';
      }

      /**
       * Returns the number of elements in the array by returning `list.length`.
       *
       * @func
       * @memberOf R
       * @since v0.3.0
       * @category List
       * @sig [a] -> Number
       * @param {Array} list The array to inspect.
       * @return {Number} The length of the array.
       * @example
       *
       *      R.length([]); //=> 0
       *      R.length([1, 2, 3]); //=> 3
       */

      var length =
      /*#__PURE__*/
      _curry1(function length(list) {
        return list != null && _isNumber(list.length) ? list.length : NaN;
      });

      var length$1 = exports('length', length);

      /**
       * Returns a lens for the given getter and setter functions. The getter "gets"
       * the value of the focus; the setter "sets" the value of the focus. The setter
       * should not mutate the data structure.
       *
       * @func
       * @memberOf R
       * @since v0.8.0
       * @category Object
       * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
       * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
       * @param {Function} getter
       * @param {Function} setter
       * @return {Lens}
       * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
       * @example
       *
       *      const xLens = R.lens(R.prop('x'), R.assoc('x'));
       *
       *      R.view(xLens, {x: 1, y: 2});            //=> 1
       *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
       *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
       */

      var lens =
      /*#__PURE__*/
      _curry2(function lens(getter, setter) {
        return function (toFunctorFn) {
          return function (target) {
            return map$1(function (focus) {
              return setter(focus, target);
            }, toFunctorFn(getter(target)));
          };
        };
      });

      var lens$1 = exports('lens', lens);

      /**
       * Returns a lens whose focus is the specified index.
       *
       * @func
       * @memberOf R
       * @since v0.14.0
       * @category Object
       * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
       * @sig Number -> Lens s a
       * @param {Number} n
       * @return {Lens}
       * @see R.view, R.set, R.over, R.nth
       * @example
       *
       *      const headLens = R.lensIndex(0);
       *
       *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
       *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
       *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
       */

      var lensIndex =
      /*#__PURE__*/
      _curry1(function lensIndex(n) {
        return lens$1(nth$1(n), update$1(n));
      });

      var lensIndex$1 = exports('lensIndex', lensIndex);

      /**
       * Returns a lens whose focus is the specified path.
       *
       * @func
       * @memberOf R
       * @since v0.19.0
       * @category Object
       * @typedefn Idx = String | Int
       * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
       * @sig [Idx] -> Lens s a
       * @param {Array} path The path to use.
       * @return {Lens}
       * @see R.view, R.set, R.over
       * @example
       *
       *      const xHeadYLens = R.lensPath(['x', 0, 'y']);
       *
       *      R.view(xHeadYLens, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
       *      //=> 2
       *      R.set(xHeadYLens, 1, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
       *      //=> {x: [{y: 1, z: 3}, {y: 4, z: 5}]}
       *      R.over(xHeadYLens, R.negate, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
       *      //=> {x: [{y: -2, z: 3}, {y: 4, z: 5}]}
       */

      var lensPath =
      /*#__PURE__*/
      _curry1(function lensPath(p) {
        return lens$1(path$1(p), assocPath$1(p));
      });

      var lensPath$1 = exports('lensPath', lensPath);

      /**
       * Returns a lens whose focus is the specified property.
       *
       * @func
       * @memberOf R
       * @since v0.14.0
       * @category Object
       * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
       * @sig String -> Lens s a
       * @param {String} k
       * @return {Lens}
       * @see R.view, R.set, R.over
       * @example
       *
       *      const xLens = R.lensProp('x');
       *
       *      R.view(xLens, {x: 1, y: 2});            //=> 1
       *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
       *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
       */

      var lensProp =
      /*#__PURE__*/
      _curry1(function lensProp(k) {
        return lens$1(prop$1(k), assoc$1(k));
      });

      var lensProp$1 = exports('lensProp', lensProp);

      /**
       * Returns `true` if the first argument is less than the second; `false`
       * otherwise.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Relation
       * @sig Ord a => a -> a -> Boolean
       * @param {*} a
       * @param {*} b
       * @return {Boolean}
       * @see R.gt
       * @example
       *
       *      R.lt(2, 1); //=> false
       *      R.lt(2, 2); //=> false
       *      R.lt(2, 3); //=> true
       *      R.lt('a', 'z'); //=> true
       *      R.lt('z', 'a'); //=> false
       */

      var lt =
      /*#__PURE__*/
      _curry2(function lt(a, b) {
        return a < b;
      });

      var lt$1 = exports('lt', lt);

      /**
       * Returns `true` if the first argument is less than or equal to the second;
       * `false` otherwise.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Relation
       * @sig Ord a => a -> a -> Boolean
       * @param {Number} a
       * @param {Number} b
       * @return {Boolean}
       * @see R.gte
       * @example
       *
       *      R.lte(2, 1); //=> false
       *      R.lte(2, 2); //=> true
       *      R.lte(2, 3); //=> true
       *      R.lte('a', 'z'); //=> true
       *      R.lte('z', 'a'); //=> false
       */

      var lte =
      /*#__PURE__*/
      _curry2(function lte(a, b) {
        return a <= b;
      });

      var lte$1 = exports('lte', lte);

      /**
       * The `mapAccum` function behaves like a combination of map and reduce; it
       * applies a function to each element of a list, passing an accumulating
       * parameter from left to right, and returning a final value of this
       * accumulator together with the new list.
       *
       * The iterator function receives two arguments, *acc* and *value*, and should
       * return a tuple *[acc, value]*.
       *
       * @func
       * @memberOf R
       * @since v0.10.0
       * @category List
       * @sig ((acc, x) -> (acc, y)) -> acc -> [x] -> (acc, [y])
       * @param {Function} fn The function to be called on every element of the input `list`.
       * @param {*} acc The accumulator value.
       * @param {Array} list The list to iterate over.
       * @return {*} The final, accumulated value.
       * @see R.scan, R.addIndex, R.mapAccumRight
       * @example
       *
       *      const digits = ['1', '2', '3', '4'];
       *      const appender = (a, b) => [a + b, a + b];
       *
       *      R.mapAccum(appender, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
       * @symb R.mapAccum(f, a, [b, c, d]) = [
       *   f(f(f(a, b)[0], c)[0], d)[0],
       *   [
       *     f(a, b)[1],
       *     f(f(a, b)[0], c)[1],
       *     f(f(f(a, b)[0], c)[0], d)[1]
       *   ]
       * ]
       */

      var mapAccum =
      /*#__PURE__*/
      _curry3(function mapAccum(fn, acc, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        var tuple = [acc];

        while (idx < len) {
          tuple = fn(tuple[0], list[idx]);
          result[idx] = tuple[1];
          idx += 1;
        }

        return [tuple[0], result];
      });

      var mapAccum$1 = exports('mapAccum', mapAccum);

      /**
       * The `mapAccumRight` function behaves like a combination of map and reduce; it
       * applies a function to each element of a list, passing an accumulating
       * parameter from right to left, and returning a final value of this
       * accumulator together with the new list.
       *
       * Similar to [`mapAccum`](#mapAccum), except moves through the input list from
       * the right to the left.
       *
       * The iterator function receives two arguments, *acc* and *value*, and should
       * return a tuple *[acc, value]*.
       *
       * @func
       * @memberOf R
       * @since v0.10.0
       * @category List
       * @sig ((acc, x) -> (acc, y)) -> acc -> [x] -> (acc, [y])
       * @param {Function} fn The function to be called on every element of the input `list`.
       * @param {*} acc The accumulator value.
       * @param {Array} list The list to iterate over.
       * @return {*} The final, accumulated value.
       * @see R.addIndex, R.mapAccum
       * @example
       *
       *      const digits = ['1', '2', '3', '4'];
       *      const appender = (a, b) => [b + a, b + a];
       *
       *      R.mapAccumRight(appender, 5, digits); //=> ['12345', ['12345', '2345', '345', '45']]
       * @symb R.mapAccumRight(f, a, [b, c, d]) = [
       *   f(f(f(a, d)[0], c)[0], b)[0],
       *   [
       *     f(a, d)[1],
       *     f(f(a, d)[0], c)[1],
       *     f(f(f(a, d)[0], c)[0], b)[1]
       *   ]
       * ]
       */

      var mapAccumRight =
      /*#__PURE__*/
      _curry3(function mapAccumRight(fn, acc, list) {
        var idx = list.length - 1;
        var result = [];
        var tuple = [acc];

        while (idx >= 0) {
          tuple = fn(tuple[0], list[idx]);
          result[idx] = tuple[1];
          idx -= 1;
        }

        return [tuple[0], result];
      });

      var mapAccumRight$1 = exports('mapAccumRight', mapAccumRight);

      /**
       * An Object-specific version of [`map`](#map). The function is applied to three
       * arguments: *(value, key, obj)*. If only the value is significant, use
       * [`map`](#map) instead.
       *
       * @func
       * @memberOf R
       * @since v0.9.0
       * @category Object
       * @sig ((*, String, Object) -> *) -> Object -> Object
       * @param {Function} fn
       * @param {Object} obj
       * @return {Object}
       * @see R.map
       * @example
       *
       *      const xyz = { x: 1, y: 2, z: 3 };
       *      const prependKeyAndDouble = (num, key, obj) => key + (num * 2);
       *
       *      R.mapObjIndexed(prependKeyAndDouble, xyz); //=> { x: 'x2', y: 'y4', z: 'z6' }
       */

      var mapObjIndexed =
      /*#__PURE__*/
      _curry2(function mapObjIndexed(fn, obj) {
        return _reduce(function (acc, key) {
          acc[key] = fn(obj[key], key, obj);
          return acc;
        }, {}, keys$1(obj));
      });

      var mapObjIndexed$1 = exports('mapObjIndexed', mapObjIndexed);

      /**
       * Tests a regular expression against a String. Note that this function will
       * return an empty array when there are no matches. This differs from
       * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
       * which returns `null` when there are no matches.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category String
       * @sig RegExp -> String -> [String | Undefined]
       * @param {RegExp} rx A regular expression.
       * @param {String} str The string to match against
       * @return {Array} The list of matches or empty array.
       * @see R.test
       * @example
       *
       *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
       *      R.match(/a/, 'b'); //=> []
       *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
       */

      var match =
      /*#__PURE__*/
      _curry2(function match(rx, str) {
        return str.match(rx) || [];
      });

      var match$1 = exports('match', match);

      /**
       * `mathMod` behaves like the modulo operator should mathematically, unlike the
       * `%` operator (and by extension, [`R.modulo`](#modulo)). So while
       * `-17 % 5` is `-2`, `mathMod(-17, 5)` is `3`. `mathMod` requires Integer
       * arguments, and returns NaN when the modulus is zero or negative.
       *
       * @func
       * @memberOf R
       * @since v0.3.0
       * @category Math
       * @sig Number -> Number -> Number
       * @param {Number} m The dividend.
       * @param {Number} p the modulus.
       * @return {Number} The result of `b mod a`.
       * @see R.modulo
       * @example
       *
       *      R.mathMod(-17, 5);  //=> 3
       *      R.mathMod(17, 5);   //=> 2
       *      R.mathMod(17, -5);  //=> NaN
       *      R.mathMod(17, 0);   //=> NaN
       *      R.mathMod(17.2, 5); //=> NaN
       *      R.mathMod(17, 5.3); //=> NaN
       *
       *      const clock = R.mathMod(R.__, 12);
       *      clock(15); //=> 3
       *      clock(24); //=> 0
       *
       *      const seventeenMod = R.mathMod(17);
       *      seventeenMod(3);  //=> 2
       *      seventeenMod(4);  //=> 1
       *      seventeenMod(10); //=> 7
       */

      var mathMod =
      /*#__PURE__*/
      _curry2(function mathMod(m, p) {
        if (!_isInteger(m)) {
          return NaN;
        }

        if (!_isInteger(p) || p < 1) {
          return NaN;
        }

        return (m % p + p) % p;
      });

      var mathMod$1 = exports('mathMod', mathMod);

      /**
       * Takes a function and two values, and returns whichever value produces the
       * larger result when passed to the provided function.
       *
       * @func
       * @memberOf R
       * @since v0.8.0
       * @category Relation
       * @sig Ord b => (a -> b) -> a -> a -> a
       * @param {Function} f
       * @param {*} a
       * @param {*} b
       * @return {*}
       * @see R.max, R.minBy
       * @example
       *
       *      //  square :: Number -> Number
       *      const square = n => n * n;
       *
       *      R.maxBy(square, -3, 2); //=> -3
       *
       *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
       *      R.reduce(R.maxBy(square), 0, []); //=> 0
       */

      var maxBy =
      /*#__PURE__*/
      _curry3(function maxBy(f, a, b) {
        return f(b) > f(a) ? b : a;
      });

      var maxBy$1 = exports('maxBy', maxBy);

      /**
       * Adds together all the elements of a list.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Math
       * @sig [Number] -> Number
       * @param {Array} list An array of numbers
       * @return {Number} The sum of all the numbers in the list.
       * @see R.reduce
       * @example
       *
       *      R.sum([2,4,6,8,100,1]); //=> 121
       */

      var sum =
      /*#__PURE__*/
      reduce$1(add$1, 0);
      var sum$1 = exports('sum', sum);

      /**
       * Returns the mean of the given list of numbers.
       *
       * @func
       * @memberOf R
       * @since v0.14.0
       * @category Math
       * @sig [Number] -> Number
       * @param {Array} list
       * @return {Number}
       * @see R.median
       * @example
       *
       *      R.mean([2, 7, 9]); //=> 6
       *      R.mean([]); //=> NaN
       */

      var mean =
      /*#__PURE__*/
      _curry1(function mean(list) {
        return sum$1(list) / list.length;
      });

      var mean$1 = exports('mean', mean);

      /**
       * Returns the median of the given list of numbers.
       *
       * @func
       * @memberOf R
       * @since v0.14.0
       * @category Math
       * @sig [Number] -> Number
       * @param {Array} list
       * @return {Number}
       * @see R.mean
       * @example
       *
       *      R.median([2, 9, 7]); //=> 7
       *      R.median([7, 2, 10, 9]); //=> 8
       *      R.median([]); //=> NaN
       */

      var median =
      /*#__PURE__*/
      _curry1(function median(list) {
        var len = list.length;

        if (len === 0) {
          return NaN;
        }

        var width = 2 - len % 2;
        var idx = (len - width) / 2;
        return mean$1(Array.prototype.slice.call(list, 0).sort(function (a, b) {
          return a < b ? -1 : a > b ? 1 : 0;
        }).slice(idx, idx + width));
      });

      var median$1 = exports('median', median);

      /**
       * Creates a new function that, when invoked, caches the result of calling `fn`
       * for a given argument set and returns the result. Subsequent calls to the
       * memoized `fn` with the same argument set will not result in an additional
       * call to `fn`; instead, the cached result for that set of arguments will be
       * returned.
       *
       *
       * @func
       * @memberOf R
       * @since v0.24.0
       * @category Function
       * @sig (*... -> String) -> (*... -> a) -> (*... -> a)
       * @param {Function} fn The function to generate the cache key.
       * @param {Function} fn The function to memoize.
       * @return {Function} Memoized version of `fn`.
       * @example
       *
       *      let count = 0;
       *      const factorial = R.memoizeWith(R.identity, n => {
       *        count += 1;
       *        return R.product(R.range(1, n + 1));
       *      });
       *      factorial(5); //=> 120
       *      factorial(5); //=> 120
       *      factorial(5); //=> 120
       *      count; //=> 1
       */

      var memoizeWith =
      /*#__PURE__*/
      _curry2(function memoizeWith(mFn, fn) {
        var cache = {};
        return _arity(fn.length, function () {
          var key = mFn.apply(this, arguments);

          if (!_has(key, cache)) {
            cache[key] = fn.apply(this, arguments);
          }

          return cache[key];
        });
      });

      var memoizeWith$1 = exports('memoizeWith', memoizeWith);

      /**
       * Create a new object with the own properties of the first object merged with
       * the own properties of the second object. If a key exists in both objects,
       * the value from the second object will be used.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Object
       * @sig {k: v} -> {k: v} -> {k: v}
       * @param {Object} l
       * @param {Object} r
       * @return {Object}
       * @see R.mergeRight, R.mergeDeepRight, R.mergeWith, R.mergeWithKey
       * @deprecated since v0.26.0
       * @example
       *
       *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
       *      //=> { 'name': 'fred', 'age': 40 }
       *
       *      const withDefaults = R.merge({x: 0, y: 0});
       *      withDefaults({y: 2}); //=> {x: 0, y: 2}
       * @symb R.merge(a, b) = {...a, ...b}
       */

      var merge =
      /*#__PURE__*/
      _curry2(function merge(l, r) {
        return _objectAssign$1({}, l, r);
      });

      var merge$1 = exports('merge', merge);

      /**
       * Merges a list of objects together into one object.
       *
       * @func
       * @memberOf R
       * @since v0.10.0
       * @category List
       * @sig [{k: v}] -> {k: v}
       * @param {Array} list An array of objects
       * @return {Object} A merged object.
       * @see R.reduce
       * @example
       *
       *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
       *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
       * @symb R.mergeAll([{ x: 1 }, { y: 2 }, { z: 3 }]) = { x: 1, y: 2, z: 3 }
       */

      var mergeAll =
      /*#__PURE__*/
      _curry1(function mergeAll(list) {
        return _objectAssign$1.apply(null, [{}].concat(list));
      });

      var mergeAll$1 = exports('mergeAll', mergeAll);

      /**
       * Creates a new object with the own properties of the two provided objects. If
       * a key exists in both objects, the provided function is applied to the key
       * and the values associated with the key in each object, with the result being
       * used as the value associated with the key in the returned object.
       *
       * @func
       * @memberOf R
       * @since v0.19.0
       * @category Object
       * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
       * @param {Function} fn
       * @param {Object} l
       * @param {Object} r
       * @return {Object}
       * @see R.mergeDeepWithKey, R.merge, R.mergeWith
       * @example
       *
       *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
       *      R.mergeWithKey(concatValues,
       *                     { a: true, thing: 'foo', values: [10, 20] },
       *                     { b: true, thing: 'bar', values: [15, 35] });
       *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
       * @symb R.mergeWithKey(f, { x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: f('y', 2, 5), z: 3 }
       */

      var mergeWithKey =
      /*#__PURE__*/
      _curry3(function mergeWithKey(fn, l, r) {
        var result = {};
        var k;

        for (k in l) {
          if (_has(k, l)) {
            result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
          }
        }

        for (k in r) {
          if (_has(k, r) && !_has(k, result)) {
            result[k] = r[k];
          }
        }

        return result;
      });

      var mergeWithKey$1 = exports('mergeWithKey', mergeWithKey);

      /**
       * Creates a new object with the own properties of the two provided objects.
       * If a key exists in both objects:
       * - and both associated values are also objects then the values will be
       *   recursively merged.
       * - otherwise the provided function is applied to the key and associated values
       *   using the resulting value as the new value associated with the key.
       * If a key only exists in one object, the value will be associated with the key
       * of the resulting object.
       *
       * @func
       * @memberOf R
       * @since v0.24.0
       * @category Object
       * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
       * @param {Function} fn
       * @param {Object} lObj
       * @param {Object} rObj
       * @return {Object}
       * @see R.mergeWithKey, R.mergeDeepWith
       * @example
       *
       *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
       *      R.mergeDeepWithKey(concatValues,
       *                         { a: true, c: { thing: 'foo', values: [10, 20] }},
       *                         { b: true, c: { thing: 'bar', values: [15, 35] }});
       *      //=> { a: true, b: true, c: { thing: 'bar', values: [10, 20, 15, 35] }}
       */

      var mergeDeepWithKey =
      /*#__PURE__*/
      _curry3(function mergeDeepWithKey(fn, lObj, rObj) {
        return mergeWithKey$1(function (k, lVal, rVal) {
          if (_isObject(lVal) && _isObject(rVal)) {
            return mergeDeepWithKey(fn, lVal, rVal);
          } else {
            return fn(k, lVal, rVal);
          }
        }, lObj, rObj);
      });

      var mergeDeepWithKey$1 = exports('mergeDeepWithKey', mergeDeepWithKey);

      /**
       * Creates a new object with the own properties of the first object merged with
       * the own properties of the second object. If a key exists in both objects:
       * - and both values are objects, the two values will be recursively merged
       * - otherwise the value from the first object will be used.
       *
       * @func
       * @memberOf R
       * @since v0.24.0
       * @category Object
       * @sig {a} -> {a} -> {a}
       * @param {Object} lObj
       * @param {Object} rObj
       * @return {Object}
       * @see R.merge, R.mergeDeepRight, R.mergeDeepWith, R.mergeDeepWithKey
       * @example
       *
       *      R.mergeDeepLeft({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
       *                      { age: 40, contact: { email: 'baa@example.com' }});
       *      //=> { name: 'fred', age: 10, contact: { email: 'moo@example.com' }}
       */

      var mergeDeepLeft =
      /*#__PURE__*/
      _curry2(function mergeDeepLeft(lObj, rObj) {
        return mergeDeepWithKey$1(function (k, lVal, rVal) {
          return lVal;
        }, lObj, rObj);
      });

      var mergeDeepLeft$1 = exports('mergeDeepLeft', mergeDeepLeft);

      /**
       * Creates a new object with the own properties of the first object merged with
       * the own properties of the second object. If a key exists in both objects:
       * - and both values are objects, the two values will be recursively merged
       * - otherwise the value from the second object will be used.
       *
       * @func
       * @memberOf R
       * @since v0.24.0
       * @category Object
       * @sig {a} -> {a} -> {a}
       * @param {Object} lObj
       * @param {Object} rObj
       * @return {Object}
       * @see R.merge, R.mergeDeepLeft, R.mergeDeepWith, R.mergeDeepWithKey
       * @example
       *
       *      R.mergeDeepRight({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
       *                       { age: 40, contact: { email: 'baa@example.com' }});
       *      //=> { name: 'fred', age: 40, contact: { email: 'baa@example.com' }}
       */

      var mergeDeepRight =
      /*#__PURE__*/
      _curry2(function mergeDeepRight(lObj, rObj) {
        return mergeDeepWithKey$1(function (k, lVal, rVal) {
          return rVal;
        }, lObj, rObj);
      });

      var mergeDeepRight$1 = exports('mergeDeepRight', mergeDeepRight);

      /**
       * Creates a new object with the own properties of the two provided objects.
       * If a key exists in both objects:
       * - and both associated values are also objects then the values will be
       *   recursively merged.
       * - otherwise the provided function is applied to associated values using the
       *   resulting value as the new value associated with the key.
       * If a key only exists in one object, the value will be associated with the key
       * of the resulting object.
       *
       * @func
       * @memberOf R
       * @since v0.24.0
       * @category Object
       * @sig ((a, a) -> a) -> {a} -> {a} -> {a}
       * @param {Function} fn
       * @param {Object} lObj
       * @param {Object} rObj
       * @return {Object}
       * @see R.mergeWith, R.mergeDeepWithKey
       * @example
       *
       *      R.mergeDeepWith(R.concat,
       *                      { a: true, c: { values: [10, 20] }},
       *                      { b: true, c: { values: [15, 35] }});
       *      //=> { a: true, b: true, c: { values: [10, 20, 15, 35] }}
       */

      var mergeDeepWith =
      /*#__PURE__*/
      _curry3(function mergeDeepWith(fn, lObj, rObj) {
        return mergeDeepWithKey$1(function (k, lVal, rVal) {
          return fn(lVal, rVal);
        }, lObj, rObj);
      });

      var mergeDeepWith$1 = exports('mergeDeepWith', mergeDeepWith);

      /**
       * Create a new object with the own properties of the first object merged with
       * the own properties of the second object. If a key exists in both objects,
       * the value from the first object will be used.
       *
       * @func
       * @memberOf R
       * @since v0.26.0
       * @category Object
       * @sig {k: v} -> {k: v} -> {k: v}
       * @param {Object} l
       * @param {Object} r
       * @return {Object}
       * @see R.mergeRight, R.mergeDeepLeft, R.mergeWith, R.mergeWithKey
       * @example
       *
       *      R.mergeLeft({ 'age': 40 }, { 'name': 'fred', 'age': 10 });
       *      //=> { 'name': 'fred', 'age': 40 }
       *
       *      const resetToDefault = R.mergeLeft({x: 0});
       *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
       * @symb R.mergeLeft(a, b) = {...b, ...a}
       */

      var mergeLeft =
      /*#__PURE__*/
      _curry2(function mergeLeft(l, r) {
        return _objectAssign$1({}, r, l);
      });

      var mergeLeft$1 = exports('mergeLeft', mergeLeft);

      /**
       * Create a new object with the own properties of the first object merged with
       * the own properties of the second object. If a key exists in both objects,
       * the value from the second object will be used.
       *
       * @func
       * @memberOf R
       * @since v0.26.0
       * @category Object
       * @sig {k: v} -> {k: v} -> {k: v}
       * @param {Object} l
       * @param {Object} r
       * @return {Object}
       * @see R.mergeLeft, R.mergeDeepRight, R.mergeWith, R.mergeWithKey
       * @example
       *
       *      R.mergeRight({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
       *      //=> { 'name': 'fred', 'age': 40 }
       *
       *      const withDefaults = R.mergeRight({x: 0, y: 0});
       *      withDefaults({y: 2}); //=> {x: 0, y: 2}
       * @symb R.mergeRight(a, b) = {...a, ...b}
       */

      var mergeRight =
      /*#__PURE__*/
      _curry2(function mergeRight(l, r) {
        return _objectAssign$1({}, l, r);
      });

      var mergeRight$1 = exports('mergeRight', mergeRight);

      /**
       * Creates a new object with the own properties of the two provided objects. If
       * a key exists in both objects, the provided function is applied to the values
       * associated with the key in each object, with the result being used as the
       * value associated with the key in the returned object.
       *
       * @func
       * @memberOf R
       * @since v0.19.0
       * @category Object
       * @sig ((a, a) -> a) -> {a} -> {a} -> {a}
       * @param {Function} fn
       * @param {Object} l
       * @param {Object} r
       * @return {Object}
       * @see R.mergeDeepWith, R.merge, R.mergeWithKey
       * @example
       *
       *      R.mergeWith(R.concat,
       *                  { a: true, values: [10, 20] },
       *                  { b: true, values: [15, 35] });
       *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
       */

      var mergeWith =
      /*#__PURE__*/
      _curry3(function mergeWith(fn, l, r) {
        return mergeWithKey$1(function (_, _l, _r) {
          return fn(_l, _r);
        }, l, r);
      });

      var mergeWith$1 = exports('mergeWith', mergeWith);

      /**
       * Returns the smaller of its two arguments.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Relation
       * @sig Ord a => a -> a -> a
       * @param {*} a
       * @param {*} b
       * @return {*}
       * @see R.minBy, R.max
       * @example
       *
       *      R.min(789, 123); //=> 123
       *      R.min('a', 'b'); //=> 'a'
       */

      var min =
      /*#__PURE__*/
      _curry2(function min(a, b) {
        return b < a ? b : a;
      });

      var min$1 = exports('min', min);

      /**
       * Takes a function and two values, and returns whichever value produces the
       * smaller result when passed to the provided function.
       *
       * @func
       * @memberOf R
       * @since v0.8.0
       * @category Relation
       * @sig Ord b => (a -> b) -> a -> a -> a
       * @param {Function} f
       * @param {*} a
       * @param {*} b
       * @return {*}
       * @see R.min, R.maxBy
       * @example
       *
       *      //  square :: Number -> Number
       *      const square = n => n * n;
       *
       *      R.minBy(square, -3, 2); //=> 2
       *
       *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
       *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
       */

      var minBy =
      /*#__PURE__*/
      _curry3(function minBy(f, a, b) {
        return f(b) < f(a) ? b : a;
      });

      var minBy$1 = exports('minBy', minBy);

      /**
       * Divides the first parameter by the second and returns the remainder. Note
       * that this function preserves the JavaScript-style behavior for modulo. For
       * mathematical modulo see [`mathMod`](#mathMod).
       *
       * @func
       * @memberOf R
       * @since v0.1.1
       * @category Math
       * @sig Number -> Number -> Number
       * @param {Number} a The value to the divide.
       * @param {Number} b The pseudo-modulus
       * @return {Number} The result of `b % a`.
       * @see R.mathMod
       * @example
       *
       *      R.modulo(17, 3); //=> 2
       *      // JS behavior:
       *      R.modulo(-17, 3); //=> -2
       *      R.modulo(17, -3); //=> 2
       *
       *      const isOdd = R.modulo(R.__, 2);
       *      isOdd(42); //=> 0
       *      isOdd(21); //=> 1
       */

      var modulo =
      /*#__PURE__*/
      _curry2(function modulo(a, b) {
        return a % b;
      });

      var modulo$1 = exports('modulo', modulo);

      /**
       * Move an item, at index `from`, to index `to`, in a list of elements.
       * A new list will be created containing the new elements order.
       *
       * @func
       * @memberOf R
       * @since v0.27.1
       * @category List
       * @sig Number -> Number -> [a] -> [a]
       * @param {Number} from The source index
       * @param {Number} to The destination index
       * @param {Array} list The list which will serve to realise the move
       * @return {Array} The new list reordered
       * @example
       *
       *      R.move(0, 2, ['a', 'b', 'c', 'd', 'e', 'f']); //=> ['b', 'c', 'a', 'd', 'e', 'f']
       *      R.move(-1, 0, ['a', 'b', 'c', 'd', 'e', 'f']); //=> ['f', 'a', 'b', 'c', 'd', 'e'] list rotation
       */

      var move =
      /*#__PURE__*/
      _curry3(function (from, to, list) {
        var length = list.length;
        var result = list.slice();
        var positiveFrom = from < 0 ? length + from : from;
        var positiveTo = to < 0 ? length + to : to;
        var item = result.splice(positiveFrom, 1);
        return positiveFrom < 0 || positiveFrom >= list.length || positiveTo < 0 || positiveTo >= list.length ? list : [].concat(result.slice(0, positiveTo)).concat(item).concat(result.slice(positiveTo, list.length));
      });

      var move$1 = exports('move', move);

      /**
       * Multiplies two numbers. Equivalent to `a * b` but curried.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Math
       * @sig Number -> Number -> Number
       * @param {Number} a The first value.
       * @param {Number} b The second value.
       * @return {Number} The result of `a * b`.
       * @see R.divide
       * @example
       *
       *      const double = R.multiply(2);
       *      const triple = R.multiply(3);
       *      double(3);       //=>  6
       *      triple(4);       //=> 12
       *      R.multiply(2, 5);  //=> 10
       */

      var multiply =
      /*#__PURE__*/
      _curry2(function multiply(a, b) {
        return a * b;
      });

      var multiply$1 = exports('multiply', multiply);

      /**
       * Negates its argument.
       *
       * @func
       * @memberOf R
       * @since v0.9.0
       * @category Math
       * @sig Number -> Number
       * @param {Number} n
       * @return {Number}
       * @example
       *
       *      R.negate(42); //=> -42
       */

      var negate =
      /*#__PURE__*/
      _curry1(function negate(n) {
        return -n;
      });

      var negate$1 = exports('negate', negate);

      /**
       * Returns `true` if no elements of the list match the predicate, `false`
       * otherwise.
       *
       * Dispatches to the `all` method of the second argument, if present.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.12.0
       * @category List
       * @sig (a -> Boolean) -> [a] -> Boolean
       * @param {Function} fn The predicate function.
       * @param {Array} list The array to consider.
       * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
       * @see R.all, R.any
       * @example
       *
       *      const isEven = n => n % 2 === 0;
       *      const isOdd = n => n % 2 === 1;
       *
       *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
       *      R.none(isOdd, [1, 3, 5, 7, 8, 11]); //=> false
       */

      var none =
      /*#__PURE__*/
      _curry2(function none(fn, input) {
        return all$1(_complement(fn), input);
      });

      var none$1 = exports('none', none);

      /**
       * Returns a function which returns its nth argument.
       *
       * @func
       * @memberOf R
       * @since v0.9.0
       * @category Function
       * @sig Number -> *... -> *
       * @param {Number} n
       * @return {Function}
       * @example
       *
       *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
       *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
       * @symb R.nthArg(-1)(a, b, c) = c
       * @symb R.nthArg(0)(a, b, c) = a
       * @symb R.nthArg(1)(a, b, c) = b
       */

      var nthArg =
      /*#__PURE__*/
      _curry1(function nthArg(n) {
        var arity = n < 0 ? 1 : n + 1;
        return curryN$1(arity, function () {
          return nth$1(n, arguments);
        });
      });

      var nthArg$1 = exports('nthArg', nthArg);

      /**
       * `o` is a curried composition function that returns a unary function.
       * Like [`compose`](#compose), `o` performs right-to-left function composition.
       * Unlike [`compose`](#compose), the rightmost function passed to `o` will be
       * invoked with only one argument. Also, unlike [`compose`](#compose), `o` is
       * limited to accepting only 2 unary functions. The name o was chosen because
       * of its similarity to the mathematical composition operator ∘.
       *
       * @func
       * @memberOf R
       * @since v0.24.0
       * @category Function
       * @sig (b -> c) -> (a -> b) -> a -> c
       * @param {Function} f
       * @param {Function} g
       * @return {Function}
       * @see R.compose, R.pipe
       * @example
       *
       *      const classyGreeting = name => "The name's " + name.last + ", " + name.first + " " + name.last
       *      const yellGreeting = R.o(R.toUpper, classyGreeting);
       *      yellGreeting({first: 'James', last: 'Bond'}); //=> "THE NAME'S BOND, JAMES BOND"
       *
       *      R.o(R.multiply(10), R.add(10))(-4) //=> 60
       *
       * @symb R.o(f, g, x) = f(g(x))
       */

      var o =
      /*#__PURE__*/
      _curry3(function o(f, g, x) {
        return f(g(x));
      });

      var o$1 = exports('o', o);

      function _of(x) {
        return [x];
      }

      /**
       * Returns a singleton array containing the value provided.
       *
       * Note this `of` is different from the ES6 `of`; See
       * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
       *
       * @func
       * @memberOf R
       * @since v0.3.0
       * @category Function
       * @sig a -> [a]
       * @param {*} x any value
       * @return {Array} An array wrapping `x`.
       * @example
       *
       *      R.of(null); //=> [null]
       *      R.of([42]); //=> [[42]]
       */

      var of =
      /*#__PURE__*/
      _curry1(_of);

      var of$1 = exports('of', of);

      /**
       * Returns a partial copy of an object omitting the keys specified.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Object
       * @sig [String] -> {String: *} -> {String: *}
       * @param {Array} names an array of String property names to omit from the new object
       * @param {Object} obj The object to copy from
       * @return {Object} A new object with properties from `names` not on it.
       * @see R.pick
       * @example
       *
       *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
       */

      var omit =
      /*#__PURE__*/
      _curry2(function omit(names, obj) {
        var result = {};
        var index = {};
        var idx = 0;
        var len = names.length;

        while (idx < len) {
          index[names[idx]] = 1;
          idx += 1;
        }

        for (var prop in obj) {
          if (!index.hasOwnProperty(prop)) {
            result[prop] = obj[prop];
          }
        }

        return result;
      });

      var omit$1 = exports('omit', omit);

      /**
       * Accepts a function `fn` and returns a function that guards invocation of
       * `fn` such that `fn` can only ever be called once, no matter how many times
       * the returned function is invoked. The first value calculated is returned in
       * subsequent invocations.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Function
       * @sig (a... -> b) -> (a... -> b)
       * @param {Function} fn The function to wrap in a call-only-once wrapper.
       * @return {Function} The wrapped function.
       * @example
       *
       *      const addOneOnce = R.once(x => x + 1);
       *      addOneOnce(10); //=> 11
       *      addOneOnce(addOneOnce(50)); //=> 11
       */

      var once =
      /*#__PURE__*/
      _curry1(function once(fn) {
        var called = false;
        var result;
        return _arity(fn.length, function () {
          if (called) {
            return result;
          }

          called = true;
          result = fn.apply(this, arguments);
          return result;
        });
      });

      var once$1 = exports('once', once);

      function _assertPromise(name, p) {
        if (p == null || !_isFunction(p.then)) {
          throw new TypeError('`' + name + '` expected a Promise, received ' + _toString(p, []));
        }
      }

      /**
       * Returns the result of applying the onFailure function to the value inside
       * a failed promise. This is useful for handling rejected promises
       * inside function compositions.
       *
       * @func
       * @memberOf R
       * @since v0.26.0
       * @category Function
       * @sig (e -> b) -> (Promise e a) -> (Promise e b)
       * @sig (e -> (Promise f b)) -> (Promise e a) -> (Promise f b)
       * @param {Function} onFailure The function to apply. Can return a value or a promise of a value.
       * @param {Promise} p
       * @return {Promise} The result of calling `p.then(null, onFailure)`
       * @see R.then
       * @example
       *
       *      var failedFetch = (id) => Promise.reject('bad ID');
       *      var useDefault = () => ({ firstName: 'Bob', lastName: 'Loblaw' })
       *
       *      //recoverFromFailure :: String -> Promise ({firstName, lastName})
       *      var recoverFromFailure = R.pipe(
       *        failedFetch,
       *        R.otherwise(useDefault),
       *        R.then(R.pick(['firstName', 'lastName'])),
       *      );
       *      recoverFromFailure(12345).then(console.log)
       */

      var otherwise =
      /*#__PURE__*/
      _curry2(function otherwise(f, p) {
        _assertPromise('otherwise', p);

        return p.then(null, f);
      });

      var otherwise$1 = exports('otherwise', otherwise);

      // transforms the held value with the provided function.

      var Identity = function (x) {
        return {
          value: x,
          map: function (f) {
            return Identity(f(x));
          }
        };
      };
      /**
       * Returns the result of "setting" the portion of the given data structure
       * focused by the given lens to the result of applying the given function to
       * the focused value.
       *
       * @func
       * @memberOf R
       * @since v0.16.0
       * @category Object
       * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
       * @sig Lens s a -> (a -> a) -> s -> s
       * @param {Lens} lens
       * @param {*} v
       * @param {*} x
       * @return {*}
       * @see R.prop, R.lensIndex, R.lensProp
       * @example
       *
       *      const headLens = R.lensIndex(0);
       *
       *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
       */


      var over =
      /*#__PURE__*/
      _curry3(function over(lens, f, x) {
        // The value returned by the getter function is first transformed with `f`,
        // then set as the value of an `Identity`. This is then mapped over with the
        // setter function of the lens.
        return lens(function (y) {
          return Identity(f(y));
        })(x).value;
      });

      var over$1 = exports('over', over);

      /**
       * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
       *
       * @func
       * @memberOf R
       * @since v0.18.0
       * @category List
       * @sig a -> b -> (a,b)
       * @param {*} fst
       * @param {*} snd
       * @return {Array}
       * @see R.objOf, R.of
       * @example
       *
       *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
       */

      var pair =
      /*#__PURE__*/
      _curry2(function pair(fst, snd) {
        return [fst, snd];
      });

      var pair$1 = exports('pair', pair);

      function _createPartialApplicator(concat) {
        return _curry2(function (fn, args) {
          return _arity(Math.max(0, fn.length - args.length), function () {
            return fn.apply(this, concat(args, arguments));
          });
        });
      }

      /**
       * Takes a function `f` and a list of arguments, and returns a function `g`.
       * When applied, `g` returns the result of applying `f` to the arguments
       * provided initially followed by the arguments provided to `g`.
       *
       * @func
       * @memberOf R
       * @since v0.10.0
       * @category Function
       * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
       * @param {Function} f
       * @param {Array} args
       * @return {Function}
       * @see R.partialRight, R.curry
       * @example
       *
       *      const multiply2 = (a, b) => a * b;
       *      const double = R.partial(multiply2, [2]);
       *      double(2); //=> 4
       *
       *      const greet = (salutation, title, firstName, lastName) =>
       *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
       *
       *      const sayHello = R.partial(greet, ['Hello']);
       *      const sayHelloToMs = R.partial(sayHello, ['Ms.']);
       *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
       * @symb R.partial(f, [a, b])(c, d) = f(a, b, c, d)
       */

      var partial =
      /*#__PURE__*/
      _createPartialApplicator(_concat);

      var partial$1 = exports('partial', partial);

      /**
       * Takes a function `f` and a list of arguments, and returns a function `g`.
       * When applied, `g` returns the result of applying `f` to the arguments
       * provided to `g` followed by the arguments provided initially.
       *
       * @func
       * @memberOf R
       * @since v0.10.0
       * @category Function
       * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
       * @param {Function} f
       * @param {Array} args
       * @return {Function}
       * @see R.partial
       * @example
       *
       *      const greet = (salutation, title, firstName, lastName) =>
       *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
       *
       *      const greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
       *
       *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
       * @symb R.partialRight(f, [a, b])(c, d) = f(c, d, a, b)
       */

      var partialRight =
      /*#__PURE__*/
      _createPartialApplicator(
      /*#__PURE__*/
      flip$1(_concat));

      var partialRight$1 = exports('partialRight', partialRight);

      /**
       * Takes a predicate and a list or other `Filterable` object and returns the
       * pair of filterable objects of the same type of elements which do and do not
       * satisfy, the predicate, respectively. Filterable objects include plain objects or any object
       * that has a filter method such as `Array`.
       *
       * @func
       * @memberOf R
       * @since v0.1.4
       * @category List
       * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]
       * @param {Function} pred A predicate to determine which side the element belongs to.
       * @param {Array} filterable the list (or other filterable) to partition.
       * @return {Array} An array, containing first the subset of elements that satisfy the
       *         predicate, and second the subset of elements that do not satisfy.
       * @see R.filter, R.reject
       * @example
       *
       *      R.partition(R.includes('s'), ['sss', 'ttt', 'foo', 'bars']);
       *      // => [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
       *
       *      R.partition(R.includes('s'), { a: 'sss', b: 'ttt', foo: 'bars' });
       *      // => [ { a: 'sss', foo: 'bars' }, { b: 'ttt' }  ]
       */

      var partition =
      /*#__PURE__*/
      juxt$1([filter$1, reject$1]);
      var partition$1 = exports('partition', partition);

      /**
       * Determines whether a nested path on an object has a specific value, in
       * [`R.equals`](#equals) terms. Most likely used to filter a list.
       *
       * @func
       * @memberOf R
       * @since v0.7.0
       * @category Relation
       * @typedefn Idx = String | Int
       * @sig [Idx] -> a -> {a} -> Boolean
       * @param {Array} path The path of the nested property to use
       * @param {*} val The value to compare the nested property with
       * @param {Object} obj The object to check the nested property in
       * @return {Boolean} `true` if the value equals the nested object property,
       *         `false` otherwise.
       * @example
       *
       *      const user1 = { address: { zipCode: 90210 } };
       *      const user2 = { address: { zipCode: 55555 } };
       *      const user3 = { name: 'Bob' };
       *      const users = [ user1, user2, user3 ];
       *      const isFamous = R.pathEq(['address', 'zipCode'], 90210);
       *      R.filter(isFamous, users); //=> [ user1 ]
       */

      var pathEq =
      /*#__PURE__*/
      _curry3(function pathEq(_path, val, obj) {
        return equals$1(path$1(_path, obj), val);
      });

      var pathEq$1 = exports('pathEq', pathEq);

      /**
       * If the given, non-null object has a value at the given path, returns the
       * value at that path. Otherwise returns the provided default value.
       *
       * @func
       * @memberOf R
       * @since v0.18.0
       * @category Object
       * @typedefn Idx = String | Int
       * @sig a -> [Idx] -> {a} -> a
       * @param {*} d The default value.
       * @param {Array} p The path to use.
       * @param {Object} obj The object to retrieve the nested property from.
       * @return {*} The data at `path` of the supplied object or the default value.
       * @example
       *
       *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
       *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
       */

      var pathOr =
      /*#__PURE__*/
      _curry3(function pathOr(d, p, obj) {
        return defaultTo$1(d, path$1(p, obj));
      });

      var pathOr$1 = exports('pathOr', pathOr);

      /**
       * Returns `true` if the specified object property at given path satisfies the
       * given predicate; `false` otherwise.
       *
       * @func
       * @memberOf R
       * @since v0.19.0
       * @category Logic
       * @typedefn Idx = String | Int
       * @sig (a -> Boolean) -> [Idx] -> {a} -> Boolean
       * @param {Function} pred
       * @param {Array} propPath
       * @param {*} obj
       * @return {Boolean}
       * @see R.propSatisfies, R.path
       * @example
       *
       *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
       *      R.pathSatisfies(R.is(Object), [], {x: {y: 2}}); //=> true
       */

      var pathSatisfies =
      /*#__PURE__*/
      _curry3(function pathSatisfies(pred, propPath, obj) {
        return pred(path$1(propPath, obj));
      });

      var pathSatisfies$1 = exports('pathSatisfies', pathSatisfies);

      /**
       * Returns a partial copy of an object containing only the keys specified. If
       * the key does not exist, the property is ignored.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Object
       * @sig [k] -> {k: v} -> {k: v}
       * @param {Array} names an array of String property names to copy onto a new object
       * @param {Object} obj The object to copy from
       * @return {Object} A new object with only properties from `names` on it.
       * @see R.omit, R.props
       * @example
       *
       *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
       *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
       */

      var pick =
      /*#__PURE__*/
      _curry2(function pick(names, obj) {
        var result = {};
        var idx = 0;

        while (idx < names.length) {
          if (names[idx] in obj) {
            result[names[idx]] = obj[names[idx]];
          }

          idx += 1;
        }

        return result;
      });

      var pick$1 = exports('pick', pick);

      /**
       * Similar to `pick` except that this one includes a `key: undefined` pair for
       * properties that don't exist.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Object
       * @sig [k] -> {k: v} -> {k: v}
       * @param {Array} names an array of String property names to copy onto a new object
       * @param {Object} obj The object to copy from
       * @return {Object} A new object with only properties from `names` on it.
       * @see R.pick
       * @example
       *
       *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
       *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
       */

      var pickAll =
      /*#__PURE__*/
      _curry2(function pickAll(names, obj) {
        var result = {};
        var idx = 0;
        var len = names.length;

        while (idx < len) {
          var name = names[idx];
          result[name] = obj[name];
          idx += 1;
        }

        return result;
      });

      var pickAll$1 = exports('pickAll', pickAll);

      /**
       * Returns a partial copy of an object containing only the keys that satisfy
       * the supplied predicate.
       *
       * @func
       * @memberOf R
       * @since v0.8.0
       * @category Object
       * @sig ((v, k) -> Boolean) -> {k: v} -> {k: v}
       * @param {Function} pred A predicate to determine whether or not a key
       *        should be included on the output object.
       * @param {Object} obj The object to copy from
       * @return {Object} A new object with only properties that satisfy `pred`
       *         on it.
       * @see R.pick, R.filter
       * @example
       *
       *      const isUpperCase = (val, key) => key.toUpperCase() === key;
       *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
       */

      var pickBy =
      /*#__PURE__*/
      _curry2(function pickBy(test, obj) {
        var result = {};

        for (var prop in obj) {
          if (test(obj[prop], prop, obj)) {
            result[prop] = obj[prop];
          }
        }

        return result;
      });

      var pickBy$1 = exports('pickBy', pickBy);

      /**
       * Returns the left-to-right Kleisli composition of the provided functions,
       * each of which must return a value of a type supported by [`chain`](#chain).
       *
       * `R.pipeK(f, g, h)` is equivalent to `R.pipe(f, R.chain(g), R.chain(h))`.
       *
       * @func
       * @memberOf R
       * @since v0.16.0
       * @category Function
       * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (a -> m z)
       * @param {...Function}
       * @return {Function}
       * @see R.composeK
       * @deprecated since v0.26.0
       * @example
       *
       *      //  parseJson :: String -> Maybe *
       *      //  get :: String -> Object -> Maybe *
       *
       *      //  getStateCode :: Maybe String -> Maybe String
       *      const getStateCode = R.pipeK(
       *        parseJson,
       *        get('user'),
       *        get('address'),
       *        get('state'),
       *        R.compose(Maybe.of, R.toUpper)
       *      );
       *
       *      getStateCode('{"user":{"address":{"state":"ny"}}}');
       *      //=> Just('NY')
       *      getStateCode('[Invalid JSON]');
       *      //=> Nothing()
       * @symb R.pipeK(f, g, h)(a) = R.chain(h, R.chain(g, f(a)))
       */

      function pipeK() {
        if (arguments.length === 0) {
          throw new Error('pipeK requires at least one argument');
        }

        return composeK.apply(this, reverse$1(arguments));
      }

      /**
       * Returns a new list with the given element at the front, followed by the
       * contents of the list.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig a -> [a] -> [a]
       * @param {*} el The item to add to the head of the output list.
       * @param {Array} list The array to add to the tail of the output list.
       * @return {Array} A new array.
       * @see R.append
       * @example
       *
       *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
       */

      var prepend =
      /*#__PURE__*/
      _curry2(function prepend(el, list) {
        return _concat([el], list);
      });

      var prepend$1 = exports('prepend', prepend);

      /**
       * Multiplies together all the elements of a list.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Math
       * @sig [Number] -> Number
       * @param {Array} list An array of numbers
       * @return {Number} The product of all the numbers in the list.
       * @see R.reduce
       * @example
       *
       *      R.product([2,4,6,8,100,1]); //=> 38400
       */

      var product =
      /*#__PURE__*/
      reduce$1(multiply$1, 1);
      var product$1 = exports('product', product);

      /**
       * Accepts a function `fn` and a list of transformer functions and returns a
       * new curried function. When the new function is invoked, it calls the
       * function `fn` with parameters consisting of the result of calling each
       * supplied handler on successive arguments to the new function.
       *
       * If more arguments are passed to the returned function than transformer
       * functions, those arguments are passed directly to `fn` as additional
       * parameters. If you expect additional arguments that don't need to be
       * transformed, although you can ignore them, it's best to pass an identity
       * function so that the new function reports the correct arity.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Function
       * @sig ((x1, x2, ...) -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
       * @param {Function} fn The function to wrap.
       * @param {Array} transformers A list of transformer functions
       * @return {Function} The wrapped function.
       * @see R.converge
       * @example
       *
       *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
       *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
       *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
       *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
       * @symb R.useWith(f, [g, h])(a, b) = f(g(a), h(b))
       */

      var useWith =
      /*#__PURE__*/
      _curry2(function useWith(fn, transformers) {
        return curryN$1(transformers.length, function () {
          var args = [];
          var idx = 0;

          while (idx < transformers.length) {
            args.push(transformers[idx].call(this, arguments[idx]));
            idx += 1;
          }

          return fn.apply(this, args.concat(Array.prototype.slice.call(arguments, transformers.length)));
        });
      });

      var useWith$1 = exports('useWith', useWith);

      /**
       * Reasonable analog to SQL `select` statement.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Object
       * @category Relation
       * @sig [k] -> [{k: v}] -> [{k: v}]
       * @param {Array} props The property names to project
       * @param {Array} objs The objects to query
       * @return {Array} An array of objects with just the `props` properties.
       * @example
       *
       *      const abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
       *      const fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
       *      const kids = [abby, fred];
       *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
       */

      var project =
      /*#__PURE__*/
      useWith$1(_map, [pickAll$1, identity$1]); // passing `identity` gives correct arity

      var project$1 = exports('project', project);

      /**
       * Returns `true` if the specified object property is equal, in
       * [`R.equals`](#equals) terms, to the given value; `false` otherwise.
       * You can test multiple properties with [`R.whereEq`](#whereEq).
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Relation
       * @sig String -> a -> Object -> Boolean
       * @param {String} name
       * @param {*} val
       * @param {*} obj
       * @return {Boolean}
       * @see R.whereEq, R.propSatisfies, R.equals
       * @example
       *
       *      const abby = {name: 'Abby', age: 7, hair: 'blond'};
       *      const fred = {name: 'Fred', age: 12, hair: 'brown'};
       *      const rusty = {name: 'Rusty', age: 10, hair: 'brown'};
       *      const alois = {name: 'Alois', age: 15, disposition: 'surly'};
       *      const kids = [abby, fred, rusty, alois];
       *      const hasBrownHair = R.propEq('hair', 'brown');
       *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
       */

      var propEq =
      /*#__PURE__*/
      _curry3(function propEq(name, val, obj) {
        return equals$1(val, obj[name]);
      });

      var propEq$1 = exports('propEq', propEq);

      /**
       * Returns `true` if the specified object property is of the given type;
       * `false` otherwise.
       *
       * @func
       * @memberOf R
       * @since v0.16.0
       * @category Type
       * @sig Type -> String -> Object -> Boolean
       * @param {Function} type
       * @param {String} name
       * @param {*} obj
       * @return {Boolean}
       * @see R.is, R.propSatisfies
       * @example
       *
       *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
       *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
       *      R.propIs(Number, 'x', {});            //=> false
       */

      var propIs =
      /*#__PURE__*/
      _curry3(function propIs(type, name, obj) {
        return is$1(type, obj[name]);
      });

      var propIs$1 = exports('propIs', propIs);

      /**
       * If the given, non-null object has an own property with the specified name,
       * returns the value of that property. Otherwise returns the provided default
       * value.
       *
       * @func
       * @memberOf R
       * @since v0.6.0
       * @category Object
       * @sig a -> String -> Object -> a
       * @param {*} val The default value.
       * @param {String} p The name of the property to return.
       * @param {Object} obj The object to query.
       * @return {*} The value of given property of the supplied object or the default value.
       * @example
       *
       *      const alice = {
       *        name: 'ALICE',
       *        age: 101
       *      };
       *      const favorite = R.prop('favoriteLibrary');
       *      const favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
       *
       *      favorite(alice);  //=> undefined
       *      favoriteWithDefault(alice);  //=> 'Ramda'
       */

      var propOr =
      /*#__PURE__*/
      _curry3(function propOr(val, p, obj) {
        return pathOr$1(val, [p], obj);
      });

      var propOr$1 = exports('propOr', propOr);

      /**
       * Returns `true` if the specified object property satisfies the given
       * predicate; `false` otherwise. You can test multiple properties with
       * [`R.where`](#where).
       *
       * @func
       * @memberOf R
       * @since v0.16.0
       * @category Logic
       * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
       * @param {Function} pred
       * @param {String} name
       * @param {*} obj
       * @return {Boolean}
       * @see R.where, R.propEq, R.propIs
       * @example
       *
       *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
       */

      var propSatisfies =
      /*#__PURE__*/
      _curry3(function propSatisfies(pred, name, obj) {
        return pred(obj[name]);
      });

      var propSatisfies$1 = exports('propSatisfies', propSatisfies);

      /**
       * Acts as multiple `prop`: array of keys in, array of values out. Preserves
       * order.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Object
       * @sig [k] -> {k: v} -> [v]
       * @param {Array} ps The property names to fetch
       * @param {Object} obj The object to query
       * @return {Array} The corresponding values or partially applied function.
       * @example
       *
       *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
       *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
       *
       *      const fullName = R.compose(R.join(' '), R.props(['first', 'last']));
       *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
       */

      var props =
      /*#__PURE__*/
      _curry2(function props(ps, obj) {
        return ps.map(function (p) {
          return path$1([p], obj);
        });
      });

      var props$1 = exports('props', props);

      /**
       * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig Number -> Number -> [Number]
       * @param {Number} from The first number in the list.
       * @param {Number} to One more than the last number in the list.
       * @return {Array} The list of numbers in the set `[a, b)`.
       * @example
       *
       *      R.range(1, 5);    //=> [1, 2, 3, 4]
       *      R.range(50, 53);  //=> [50, 51, 52]
       */

      var range =
      /*#__PURE__*/
      _curry2(function range(from, to) {
        if (!(_isNumber(from) && _isNumber(to))) {
          throw new TypeError('Both arguments to range must be numbers');
        }

        var result = [];
        var n = from;

        while (n < to) {
          result.push(n);
          n += 1;
        }

        return result;
      });

      var range$1 = exports('range', range);

      /**
       * Returns a single item by iterating through the list, successively calling
       * the iterator function and passing it an accumulator value and the current
       * value from the array, and then passing the result to the next call.
       *
       * Similar to [`reduce`](#reduce), except moves through the input list from the
       * right to the left.
       *
       * The iterator function receives two values: *(value, acc)*, while the arguments'
       * order of `reduce`'s iterator function is *(acc, value)*.
       *
       * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
       * arrays), unlike the native `Array.prototype.reduceRight` method. For more details
       * on this behavior, see:
       * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig ((a, b) -> b) -> b -> [a] -> b
       * @param {Function} fn The iterator function. Receives two values, the current element from the array
       *        and the accumulator.
       * @param {*} acc The accumulator value.
       * @param {Array} list The list to iterate over.
       * @return {*} The final, accumulated value.
       * @see R.reduce, R.addIndex
       * @example
       *
       *      R.reduceRight(R.subtract, 0, [1, 2, 3, 4]) // => (1 - (2 - (3 - (4 - 0)))) = -2
       *      //    -               -2
       *      //   / \              / \
       *      //  1   -            1   3
       *      //     / \              / \
       *      //    2   -     ==>    2  -1
       *      //       / \              / \
       *      //      3   -            3   4
       *      //         / \              / \
       *      //        4   0            4   0
       *
       * @symb R.reduceRight(f, a, [b, c, d]) = f(b, f(c, f(d, a)))
       */

      var reduceRight =
      /*#__PURE__*/
      _curry3(function reduceRight(fn, acc, list) {
        var idx = list.length - 1;

        while (idx >= 0) {
          acc = fn(list[idx], acc);
          idx -= 1;
        }

        return acc;
      });

      var reduceRight$1 = exports('reduceRight', reduceRight);

      /**
       * Like [`reduce`](#reduce), `reduceWhile` returns a single item by iterating
       * through the list, successively calling the iterator function. `reduceWhile`
       * also takes a predicate that is evaluated before each step. If the predicate
       * returns `false`, it "short-circuits" the iteration and returns the current
       * value of the accumulator.
       *
       * @func
       * @memberOf R
       * @since v0.22.0
       * @category List
       * @sig ((a, b) -> Boolean) -> ((a, b) -> a) -> a -> [b] -> a
       * @param {Function} pred The predicate. It is passed the accumulator and the
       *        current element.
       * @param {Function} fn The iterator function. Receives two values, the
       *        accumulator and the current element.
       * @param {*} a The accumulator value.
       * @param {Array} list The list to iterate over.
       * @return {*} The final, accumulated value.
       * @see R.reduce, R.reduced
       * @example
       *
       *      const isOdd = (acc, x) => x % 2 === 1;
       *      const xs = [1, 3, 5, 60, 777, 800];
       *      R.reduceWhile(isOdd, R.add, 0, xs); //=> 9
       *
       *      const ys = [2, 4, 6]
       *      R.reduceWhile(isOdd, R.add, 111, ys); //=> 111
       */

      var reduceWhile =
      /*#__PURE__*/
      _curryN(4, [], function _reduceWhile(pred, fn, a, list) {
        return _reduce(function (acc, x) {
          return pred(acc, x) ? fn(acc, x) : _reduced(acc);
        }, a, list);
      });

      var reduceWhile$1 = exports('reduceWhile', reduceWhile);

      /**
       * Returns a value wrapped to indicate that it is the final value of the reduce
       * and transduce functions. The returned value should be considered a black
       * box: the internal structure is not guaranteed to be stable.
       *
       * Note: this optimization is only available to the below functions:
       * - [`reduce`](#reduce)
       * - [`reduceWhile`](#reduceWhile)
       * - [`transduce`](#transduce)
       *
       * @func
       * @memberOf R
       * @since v0.15.0
       * @category List
       * @sig a -> *
       * @param {*} x The final value of the reduce.
       * @return {*} The wrapped value.
       * @see R.reduce, R.reduceWhile, R.transduce
       * @example
       *
       *     R.reduce(
       *       (acc, item) => item > 3 ? R.reduced(acc) : acc.concat(item),
       *       [],
       *       [1, 2, 3, 4, 5]) // [1, 2, 3]
       */

      var reduced =
      /*#__PURE__*/
      _curry1(_reduced);

      var reduced$1 = exports('reduced', reduced);

      /**
       * Calls an input function `n` times, returning an array containing the results
       * of those function calls.
       *
       * `fn` is passed one argument: The current value of `n`, which begins at `0`
       * and is gradually incremented to `n - 1`.
       *
       * @func
       * @memberOf R
       * @since v0.2.3
       * @category List
       * @sig (Number -> a) -> Number -> [a]
       * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
       * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
       * @return {Array} An array containing the return values of all calls to `fn`.
       * @see R.repeat
       * @example
       *
       *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
       * @symb R.times(f, 0) = []
       * @symb R.times(f, 1) = [f(0)]
       * @symb R.times(f, 2) = [f(0), f(1)]
       */

      var times =
      /*#__PURE__*/
      _curry2(function times(fn, n) {
        var len = Number(n);
        var idx = 0;
        var list;

        if (len < 0 || isNaN(len)) {
          throw new RangeError('n must be a non-negative number');
        }

        list = new Array(len);

        while (idx < len) {
          list[idx] = fn(idx);
          idx += 1;
        }

        return list;
      });

      var times$1 = exports('times', times);

      /**
       * Returns a fixed list of size `n` containing a specified identical value.
       *
       * @func
       * @memberOf R
       * @since v0.1.1
       * @category List
       * @sig a -> n -> [a]
       * @param {*} value The value to repeat.
       * @param {Number} n The desired size of the output list.
       * @return {Array} A new array containing `n` `value`s.
       * @see R.times
       * @example
       *
       *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
       *
       *      const obj = {};
       *      const repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
       *      repeatedObjs[0] === repeatedObjs[1]; //=> true
       * @symb R.repeat(a, 0) = []
       * @symb R.repeat(a, 1) = [a]
       * @symb R.repeat(a, 2) = [a, a]
       */

      var repeat =
      /*#__PURE__*/
      _curry2(function repeat(value, n) {
        return times$1(always$1(value), n);
      });

      var repeat$1 = exports('repeat', repeat);

      /**
       * Replace a substring or regex match in a string with a replacement.
       *
       * The first two parameters correspond to the parameters of the
       * `String.prototype.replace()` function, so the second parameter can also be a
       * function.
       *
       * @func
       * @memberOf R
       * @since v0.7.0
       * @category String
       * @sig RegExp|String -> String -> String -> String
       * @param {RegExp|String} pattern A regular expression or a substring to match.
       * @param {String} replacement The string to replace the matches with.
       * @param {String} str The String to do the search and replacement in.
       * @return {String} The result.
       * @example
       *
       *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
       *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
       *
       *      // Use the "g" (global) flag to replace all occurrences:
       *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
       */

      var replace =
      /*#__PURE__*/
      _curry3(function replace(regex, replacement, str) {
        return str.replace(regex, replacement);
      });

      var replace$1 = exports('replace', replace);

      /**
       * Scan is similar to [`reduce`](#reduce), but returns a list of successively
       * reduced values from the left
       *
       * @func
       * @memberOf R
       * @since v0.10.0
       * @category List
       * @sig ((a, b) -> a) -> a -> [b] -> [a]
       * @param {Function} fn The iterator function. Receives two values, the accumulator and the
       *        current element from the array
       * @param {*} acc The accumulator value.
       * @param {Array} list The list to iterate over.
       * @return {Array} A list of all intermediately reduced values.
       * @see R.reduce, R.mapAccum
       * @example
       *
       *      const numbers = [1, 2, 3, 4];
       *      const factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
       * @symb R.scan(f, a, [b, c]) = [a, f(a, b), f(f(a, b), c)]
       */

      var scan =
      /*#__PURE__*/
      _curry3(function scan(fn, acc, list) {
        var idx = 0;
        var len = list.length;
        var result = [acc];

        while (idx < len) {
          acc = fn(acc, list[idx]);
          result[idx + 1] = acc;
          idx += 1;
        }

        return result;
      });

      var scan$1 = exports('scan', scan);

      /**
       * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
       * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
       * Applicative of Traversable.
       *
       * Dispatches to the `sequence` method of the second argument, if present.
       *
       * @func
       * @memberOf R
       * @since v0.19.0
       * @category List
       * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
       * @param {Function} of
       * @param {*} traversable
       * @return {*}
       * @see R.traverse
       * @example
       *
       *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
       *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
       *
       *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
       *      R.sequence(R.of, Nothing());       //=> [Nothing()]
       */

      var sequence =
      /*#__PURE__*/
      _curry2(function sequence(of, traversable) {
        return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight$1(function (x, acc) {
          return ap$1(map$1(prepend$1, x), acc);
        }, of([]), traversable);
      });

      var sequence$1 = exports('sequence', sequence);

      /**
       * Returns the result of "setting" the portion of the given data structure
       * focused by the given lens to the given value.
       *
       * @func
       * @memberOf R
       * @since v0.16.0
       * @category Object
       * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
       * @sig Lens s a -> a -> s -> s
       * @param {Lens} lens
       * @param {*} v
       * @param {*} x
       * @return {*}
       * @see R.prop, R.lensIndex, R.lensProp
       * @example
       *
       *      const xLens = R.lensProp('x');
       *
       *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
       *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
       */

      var set =
      /*#__PURE__*/
      _curry3(function set(lens, v, x) {
        return over$1(lens, always$1(v), x);
      });

      var set$1 = exports('set', set);

      /**
       * Returns a copy of the list, sorted according to the comparator function,
       * which should accept two values at a time and return a negative number if the
       * first value is smaller, a positive number if it's larger, and zero if they
       * are equal. Please note that this is a **copy** of the list. It does not
       * modify the original.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig ((a, a) -> Number) -> [a] -> [a]
       * @param {Function} comparator A sorting function :: a -> b -> Int
       * @param {Array} list The list to sort
       * @return {Array} a new array with its elements sorted by the comparator function.
       * @example
       *
       *      const diff = function(a, b) { return a - b; };
       *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
       */

      var sort =
      /*#__PURE__*/
      _curry2(function sort(comparator, list) {
        return Array.prototype.slice.call(list, 0).sort(comparator);
      });

      var sort$1 = exports('sort', sort);

      /**
       * Sorts the list according to the supplied function.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Relation
       * @sig Ord b => (a -> b) -> [a] -> [a]
       * @param {Function} fn
       * @param {Array} list The list to sort.
       * @return {Array} A new list sorted by the keys generated by `fn`.
       * @example
       *
       *      const sortByFirstItem = R.sortBy(R.prop(0));
       *      const pairs = [[-1, 1], [-2, 2], [-3, 3]];
       *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
       *
       *      const sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
       *      const alice = {
       *        name: 'ALICE',
       *        age: 101
       *      };
       *      const bob = {
       *        name: 'Bob',
       *        age: -10
       *      };
       *      const clara = {
       *        name: 'clara',
       *        age: 314.159
       *      };
       *      const people = [clara, bob, alice];
       *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
       */

      var sortBy =
      /*#__PURE__*/
      _curry2(function sortBy(fn, list) {
        return Array.prototype.slice.call(list, 0).sort(function (a, b) {
          var aa = fn(a);
          var bb = fn(b);
          return aa < bb ? -1 : aa > bb ? 1 : 0;
        });
      });

      var sortBy$1 = exports('sortBy', sortBy);

      /**
       * Sorts a list according to a list of comparators.
       *
       * @func
       * @memberOf R
       * @since v0.23.0
       * @category Relation
       * @sig [(a, a) -> Number] -> [a] -> [a]
       * @param {Array} functions A list of comparator functions.
       * @param {Array} list The list to sort.
       * @return {Array} A new list sorted according to the comarator functions.
       * @example
       *
       *      const alice = {
       *        name: 'alice',
       *        age: 40
       *      };
       *      const bob = {
       *        name: 'bob',
       *        age: 30
       *      };
       *      const clara = {
       *        name: 'clara',
       *        age: 40
       *      };
       *      const people = [clara, bob, alice];
       *      const ageNameSort = R.sortWith([
       *        R.descend(R.prop('age')),
       *        R.ascend(R.prop('name'))
       *      ]);
       *      ageNameSort(people); //=> [alice, clara, bob]
       */

      var sortWith =
      /*#__PURE__*/
      _curry2(function sortWith(fns, list) {
        return Array.prototype.slice.call(list, 0).sort(function (a, b) {
          var result = 0;
          var i = 0;

          while (result === 0 && i < fns.length) {
            result = fns[i](a, b);
            i += 1;
          }

          return result;
        });
      });

      var sortWith$1 = exports('sortWith', sortWith);

      /**
       * Splits a string into an array of strings based on the given
       * separator.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category String
       * @sig (String | RegExp) -> String -> [String]
       * @param {String|RegExp} sep The pattern.
       * @param {String} str The string to separate into an array.
       * @return {Array} The array of strings from `str` separated by `sep`.
       * @see R.join
       * @example
       *
       *      const pathComponents = R.split('/');
       *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
       *
       *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
       */

      var split =
      /*#__PURE__*/
      invoker$1(1, 'split');
      var split$1 = exports('split', split);

      /**
       * Splits a given list or string at a given index.
       *
       * @func
       * @memberOf R
       * @since v0.19.0
       * @category List
       * @sig Number -> [a] -> [[a], [a]]
       * @sig Number -> String -> [String, String]
       * @param {Number} index The index where the array/string is split.
       * @param {Array|String} array The array/string to be split.
       * @return {Array}
       * @example
       *
       *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
       *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
       *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
       */

      var splitAt =
      /*#__PURE__*/
      _curry2(function splitAt(index, array) {
        return [slice$1(0, index, array), slice$1(index, length$1(array), array)];
      });

      var splitAt$1 = exports('splitAt', splitAt);

      /**
       * Splits a collection into slices of the specified length.
       *
       * @func
       * @memberOf R
       * @since v0.16.0
       * @category List
       * @sig Number -> [a] -> [[a]]
       * @sig Number -> String -> [String]
       * @param {Number} n
       * @param {Array} list
       * @return {Array}
       * @example
       *
       *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
       *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
       */

      var splitEvery =
      /*#__PURE__*/
      _curry2(function splitEvery(n, list) {
        if (n <= 0) {
          throw new Error('First argument to splitEvery must be a positive integer');
        }

        var result = [];
        var idx = 0;

        while (idx < list.length) {
          result.push(slice$1(idx, idx += n, list));
        }

        return result;
      });

      var splitEvery$1 = exports('splitEvery', splitEvery);

      /**
       * Takes a list and a predicate and returns a pair of lists with the following properties:
       *
       *  - the result of concatenating the two output lists is equivalent to the input list;
       *  - none of the elements of the first output list satisfies the predicate; and
       *  - if the second output list is non-empty, its first element satisfies the predicate.
       *
       * @func
       * @memberOf R
       * @since v0.19.0
       * @category List
       * @sig (a -> Boolean) -> [a] -> [[a], [a]]
       * @param {Function} pred The predicate that determines where the array is split.
       * @param {Array} list The array to be split.
       * @return {Array}
       * @example
       *
       *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
       */

      var splitWhen =
      /*#__PURE__*/
      _curry2(function splitWhen(pred, list) {
        var idx = 0;
        var len = list.length;
        var prefix = [];

        while (idx < len && !pred(list[idx])) {
          prefix.push(list[idx]);
          idx += 1;
        }

        return [prefix, Array.prototype.slice.call(list, idx)];
      });

      var splitWhen$1 = exports('splitWhen', splitWhen);

      /**
       * Checks if a list starts with the provided sublist.
       *
       * Similarly, checks if a string starts with the provided substring.
       *
       * @func
       * @memberOf R
       * @since v0.24.0
       * @category List
       * @sig [a] -> [a] -> Boolean
       * @sig String -> String -> Boolean
       * @param {*} prefix
       * @param {*} list
       * @return {Boolean}
       * @see R.endsWith
       * @example
       *
       *      R.startsWith('a', 'abc')                //=> true
       *      R.startsWith('b', 'abc')                //=> false
       *      R.startsWith(['a'], ['a', 'b', 'c'])    //=> true
       *      R.startsWith(['b'], ['a', 'b', 'c'])    //=> false
       */

      var startsWith =
      /*#__PURE__*/
      _curry2(function (prefix, list) {
        return equals$1(take$1(prefix.length, list), prefix);
      });

      var startsWith$1 = exports('startsWith', startsWith);

      /**
       * Subtracts its second argument from its first argument.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Math
       * @sig Number -> Number -> Number
       * @param {Number} a The first value.
       * @param {Number} b The second value.
       * @return {Number} The result of `a - b`.
       * @see R.add
       * @example
       *
       *      R.subtract(10, 8); //=> 2
       *
       *      const minus5 = R.subtract(R.__, 5);
       *      minus5(17); //=> 12
       *
       *      const complementaryAngle = R.subtract(90);
       *      complementaryAngle(30); //=> 60
       *      complementaryAngle(72); //=> 18
       */

      var subtract =
      /*#__PURE__*/
      _curry2(function subtract(a, b) {
        return Number(a) - Number(b);
      });

      var subtract$1 = exports('subtract', subtract);

      /**
       * Finds the set (i.e. no duplicates) of all elements contained in the first or
       * second list, but not both.
       *
       * @func
       * @memberOf R
       * @since v0.19.0
       * @category Relation
       * @sig [*] -> [*] -> [*]
       * @param {Array} list1 The first list.
       * @param {Array} list2 The second list.
       * @return {Array} The elements in `list1` or `list2`, but not both.
       * @see R.symmetricDifferenceWith, R.difference, R.differenceWith
       * @example
       *
       *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
       *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
       */

      var symmetricDifference =
      /*#__PURE__*/
      _curry2(function symmetricDifference(list1, list2) {
        return concat$1(difference$1(list1, list2), difference$1(list2, list1));
      });

      var symmetricDifference$1 = exports('symmetricDifference', symmetricDifference);

      /**
       * Finds the set (i.e. no duplicates) of all elements contained in the first or
       * second list, but not both. Duplication is determined according to the value
       * returned by applying the supplied predicate to two list elements.
       *
       * @func
       * @memberOf R
       * @since v0.19.0
       * @category Relation
       * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
       * @param {Function} pred A predicate used to test whether two items are equal.
       * @param {Array} list1 The first list.
       * @param {Array} list2 The second list.
       * @return {Array} The elements in `list1` or `list2`, but not both.
       * @see R.symmetricDifference, R.difference, R.differenceWith
       * @example
       *
       *      const eqA = R.eqBy(R.prop('a'));
       *      const l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
       *      const l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
       *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
       */

      var symmetricDifferenceWith =
      /*#__PURE__*/
      _curry3(function symmetricDifferenceWith(pred, list1, list2) {
        return concat$1(differenceWith$1(pred, list1, list2), differenceWith$1(pred, list2, list1));
      });

      var symmetricDifferenceWith$1 = exports('symmetricDifferenceWith', symmetricDifferenceWith);

      /**
       * Returns a new list containing the last `n` elements of a given list, passing
       * each value to the supplied predicate function, and terminating when the
       * predicate function returns `false`. Excludes the element that caused the
       * predicate function to fail. The predicate function is passed one argument:
       * *(value)*.
       *
       * @func
       * @memberOf R
       * @since v0.16.0
       * @category List
       * @sig (a -> Boolean) -> [a] -> [a]
       * @sig (a -> Boolean) -> String -> String
       * @param {Function} fn The function called per iteration.
       * @param {Array} xs The collection to iterate over.
       * @return {Array} A new array.
       * @see R.dropLastWhile, R.addIndex
       * @example
       *
       *      const isNotOne = x => x !== 1;
       *
       *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
       *
       *      R.takeLastWhile(x => x !== 'R' , 'Ramda'); //=> 'amda'
       */

      var takeLastWhile =
      /*#__PURE__*/
      _curry2(function takeLastWhile(fn, xs) {
        var idx = xs.length - 1;

        while (idx >= 0 && fn(xs[idx])) {
          idx -= 1;
        }

        return slice$1(idx + 1, Infinity, xs);
      });

      var takeLastWhile$1 = exports('takeLastWhile', takeLastWhile);

      var XTakeWhile =
      /*#__PURE__*/
      function () {
        function XTakeWhile(f, xf) {
          this.xf = xf;
          this.f = f;
        }

        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;

        XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
          return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
        };

        return XTakeWhile;
      }();

      var _xtakeWhile =
      /*#__PURE__*/
      _curry2(function _xtakeWhile(f, xf) {
        return new XTakeWhile(f, xf);
      });

      var _xtakeWhile$1 = _xtakeWhile;

      /**
       * Returns a new list containing the first `n` elements of a given list,
       * passing each value to the supplied predicate function, and terminating when
       * the predicate function returns `false`. Excludes the element that caused the
       * predicate function to fail. The predicate function is passed one argument:
       * *(value)*.
       *
       * Dispatches to the `takeWhile` method of the second argument, if present.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig (a -> Boolean) -> [a] -> [a]
       * @sig (a -> Boolean) -> String -> String
       * @param {Function} fn The function called per iteration.
       * @param {Array} xs The collection to iterate over.
       * @return {Array} A new array.
       * @see R.dropWhile, R.transduce, R.addIndex
       * @example
       *
       *      const isNotFour = x => x !== 4;
       *
       *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
       *
       *      R.takeWhile(x => x !== 'd' , 'Ramda'); //=> 'Ram'
       */

      var takeWhile =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _dispatchable(['takeWhile'], _xtakeWhile$1, function takeWhile(fn, xs) {
        var idx = 0;
        var len = xs.length;

        while (idx < len && fn(xs[idx])) {
          idx += 1;
        }

        return slice$1(0, idx, xs);
      }));

      var takeWhile$1 = exports('takeWhile', takeWhile);

      var XTap =
      /*#__PURE__*/
      function () {
        function XTap(f, xf) {
          this.xf = xf;
          this.f = f;
        }

        XTap.prototype['@@transducer/init'] = _xfBase.init;
        XTap.prototype['@@transducer/result'] = _xfBase.result;

        XTap.prototype['@@transducer/step'] = function (result, input) {
          this.f(input);
          return this.xf['@@transducer/step'](result, input);
        };

        return XTap;
      }();

      var _xtap =
      /*#__PURE__*/
      _curry2(function _xtap(f, xf) {
        return new XTap(f, xf);
      });

      var _xtap$1 = _xtap;

      /**
       * Runs the given function with the supplied object, then returns the object.
       *
       * Acts as a transducer if a transformer is given as second parameter.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Function
       * @sig (a -> *) -> a -> a
       * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
       * @param {*} x
       * @return {*} `x`.
       * @example
       *
       *      const sayX = x => console.log('x is ' + x);
       *      R.tap(sayX, 100); //=> 100
       *      // logs 'x is 100'
       * @symb R.tap(f, a) = a
       */

      var tap =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      _dispatchable([], _xtap$1, function tap(fn, x) {
        fn(x);
        return x;
      }));

      var tap$1 = exports('tap', tap);

      function _isRegExp(x) {
        return Object.prototype.toString.call(x) === '[object RegExp]';
      }

      /**
       * Determines whether a given string matches a given regular expression.
       *
       * @func
       * @memberOf R
       * @since v0.12.0
       * @category String
       * @sig RegExp -> String -> Boolean
       * @param {RegExp} pattern
       * @param {String} str
       * @return {Boolean}
       * @see R.match
       * @example
       *
       *      R.test(/^x/, 'xyz'); //=> true
       *      R.test(/^y/, 'xyz'); //=> false
       */

      var test =
      /*#__PURE__*/
      _curry2(function test(pattern, str) {
        if (!_isRegExp(pattern)) {
          throw new TypeError('‘test’ requires a value of type RegExp as its first argument; received ' + toString$1(pattern));
        }

        return _cloneRegExp(pattern).test(str);
      });

      var test$1 = exports('test', test);

      /**
       * Returns the result of applying the onSuccess function to the value inside
       * a successfully resolved promise. This is useful for working with promises
       * inside function compositions.
       *
       * @func
       * @memberOf R
       * @since v0.27.1
       * @category Function
       * @sig (a -> b) -> (Promise e a) -> (Promise e b)
       * @sig (a -> (Promise e b)) -> (Promise e a) -> (Promise e b)
       * @param {Function} onSuccess The function to apply. Can return a value or a promise of a value.
       * @param {Promise} p
       * @return {Promise} The result of calling `p.then(onSuccess)`
       * @see R.otherwise
       * @example
       *
       *      var makeQuery = (email) => ({ query: { email }});
       *
       *      //getMemberName :: String -> Promise ({firstName, lastName})
       *      var getMemberName = R.pipe(
       *        makeQuery,
       *        fetchMember,
       *        R.andThen(R.pick(['firstName', 'lastName']))
       *      );
       */

      var andThen =
      /*#__PURE__*/
      _curry2(function andThen(f, p) {
        _assertPromise('andThen', p);

        return p.then(f);
      });

      var andThen$1 = exports('andThen', andThen);

      /**
       * The lower case version of a string.
       *
       * @func
       * @memberOf R
       * @since v0.9.0
       * @category String
       * @sig String -> String
       * @param {String} str The string to lower case.
       * @return {String} The lower case version of `str`.
       * @see R.toUpper
       * @example
       *
       *      R.toLower('XYZ'); //=> 'xyz'
       */

      var toLower =
      /*#__PURE__*/
      invoker$1(0, 'toLowerCase');
      var toLower$1 = exports('toLower', toLower);

      /**
       * Converts an object into an array of key, value arrays. Only the object's
       * own properties are used.
       * Note that the order of the output array is not guaranteed to be consistent
       * across different JS platforms.
       *
       * @func
       * @memberOf R
       * @since v0.4.0
       * @category Object
       * @sig {String: *} -> [[String,*]]
       * @param {Object} obj The object to extract from
       * @return {Array} An array of key, value arrays from the object's own properties.
       * @see R.fromPairs
       * @example
       *
       *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
       */

      var toPairs =
      /*#__PURE__*/
      _curry1(function toPairs(obj) {
        var pairs = [];

        for (var prop in obj) {
          if (_has(prop, obj)) {
            pairs[pairs.length] = [prop, obj[prop]];
          }
        }

        return pairs;
      });

      var toPairs$1 = exports('toPairs', toPairs);

      /**
       * Converts an object into an array of key, value arrays. The object's own
       * properties and prototype properties are used. Note that the order of the
       * output array is not guaranteed to be consistent across different JS
       * platforms.
       *
       * @func
       * @memberOf R
       * @since v0.4.0
       * @category Object
       * @sig {String: *} -> [[String,*]]
       * @param {Object} obj The object to extract from
       * @return {Array} An array of key, value arrays from the object's own
       *         and prototype properties.
       * @example
       *
       *      const F = function() { this.x = 'X'; };
       *      F.prototype.y = 'Y';
       *      const f = new F();
       *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
       */

      var toPairsIn =
      /*#__PURE__*/
      _curry1(function toPairsIn(obj) {
        var pairs = [];

        for (var prop in obj) {
          pairs[pairs.length] = [prop, obj[prop]];
        }

        return pairs;
      });

      var toPairsIn$1 = exports('toPairsIn', toPairsIn);

      /**
       * The upper case version of a string.
       *
       * @func
       * @memberOf R
       * @since v0.9.0
       * @category String
       * @sig String -> String
       * @param {String} str The string to upper case.
       * @return {String} The upper case version of `str`.
       * @see R.toLower
       * @example
       *
       *      R.toUpper('abc'); //=> 'ABC'
       */

      var toUpper =
      /*#__PURE__*/
      invoker$1(0, 'toUpperCase');
      var toUpper$1 = exports('toUpper', toUpper);

      /**
       * Initializes a transducer using supplied iterator function. Returns a single
       * item by iterating through the list, successively calling the transformed
       * iterator function and passing it an accumulator value and the current value
       * from the array, and then passing the result to the next call.
       *
       * The iterator function receives two values: *(acc, value)*. It will be
       * wrapped as a transformer to initialize the transducer. A transformer can be
       * passed directly in place of an iterator function. In both cases, iteration
       * may be stopped early with the [`R.reduced`](#reduced) function.
       *
       * A transducer is a function that accepts a transformer and returns a
       * transformer and can be composed directly.
       *
       * A transformer is an an object that provides a 2-arity reducing iterator
       * function, step, 0-arity initial value function, init, and 1-arity result
       * extraction function, result. The step function is used as the iterator
       * function in reduce. The result function is used to convert the final
       * accumulator into the return type and in most cases is
       * [`R.identity`](#identity). The init function can be used to provide an
       * initial accumulator, but is ignored by transduce.
       *
       * The iteration is performed with [`R.reduce`](#reduce) after initializing the transducer.
       *
       * @func
       * @memberOf R
       * @since v0.12.0
       * @category List
       * @sig (c -> c) -> ((a, b) -> a) -> a -> [b] -> a
       * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
       * @param {Function} fn The iterator function. Receives two values, the accumulator and the
       *        current element from the array. Wrapped as transformer, if necessary, and used to
       *        initialize the transducer
       * @param {*} acc The initial accumulator value.
       * @param {Array} list The list to iterate over.
       * @return {*} The final, accumulated value.
       * @see R.reduce, R.reduced, R.into
       * @example
       *
       *      const numbers = [1, 2, 3, 4];
       *      const transducer = R.compose(R.map(R.add(1)), R.take(2));
       *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
       *
       *      const isOdd = (x) => x % 2 === 1;
       *      const firstOddTransducer = R.compose(R.filter(isOdd), R.take(1));
       *      R.transduce(firstOddTransducer, R.flip(R.append), [], R.range(0, 100)); //=> [1]
       */

      var transduce =
      /*#__PURE__*/
      curryN$1(4, function transduce(xf, fn, acc, list) {
        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
      });
      var transduce$1 = exports('transduce', transduce);

      /**
       * Transposes the rows and columns of a 2D list.
       * When passed a list of `n` lists of length `x`,
       * returns a list of `x` lists of length `n`.
       *
       *
       * @func
       * @memberOf R
       * @since v0.19.0
       * @category List
       * @sig [[a]] -> [[a]]
       * @param {Array} list A 2D list
       * @return {Array} A 2D list
       * @example
       *
       *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
       *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
       *
       *      // If some of the rows are shorter than the following rows, their elements are skipped:
       *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
       * @symb R.transpose([[a], [b], [c]]) = [a, b, c]
       * @symb R.transpose([[a, b], [c, d]]) = [[a, c], [b, d]]
       * @symb R.transpose([[a, b], [c]]) = [[a, c], [b]]
       */

      var transpose =
      /*#__PURE__*/
      _curry1(function transpose(outerlist) {
        var i = 0;
        var result = [];

        while (i < outerlist.length) {
          var innerlist = outerlist[i];
          var j = 0;

          while (j < innerlist.length) {
            if (typeof result[j] === 'undefined') {
              result[j] = [];
            }

            result[j].push(innerlist[j]);
            j += 1;
          }

          i += 1;
        }

        return result;
      });

      var transpose$1 = exports('transpose', transpose);

      /**
       * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
       * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
       * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
       * into an Applicative of Traversable.
       *
       * Dispatches to the `traverse` method of the third argument, if present.
       *
       * @func
       * @memberOf R
       * @since v0.19.0
       * @category List
       * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
       * @param {Function} of
       * @param {Function} f
       * @param {*} traversable
       * @return {*}
       * @see R.sequence
       * @example
       *
       *      // Returns `Maybe.Nothing` if the given divisor is `0`
       *      const safeDiv = n => d => d === 0 ? Maybe.Nothing() : Maybe.Just(n / d)
       *
       *      R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=> Maybe.Just([5, 2.5, 2])
       *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Maybe.Nothing
       */

      var traverse =
      /*#__PURE__*/
      _curry3(function traverse(of, f, traversable) {
        return typeof traversable['fantasy-land/traverse'] === 'function' ? traversable['fantasy-land/traverse'](f, of) : sequence$1(of, map$1(f, traversable));
      });

      var traverse$1 = exports('traverse', traverse);

      var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
      var zeroWidth = '\u200b';
      var hasProtoTrim = typeof String.prototype.trim === 'function';
      /**
       * Removes (strips) whitespace from both ends of the string.
       *
       * @func
       * @memberOf R
       * @since v0.6.0
       * @category String
       * @sig String -> String
       * @param {String} str The string to trim.
       * @return {String} Trimmed version of `str`.
       * @example
       *
       *      R.trim('   xyz  '); //=> 'xyz'
       *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
       */

      var trim = !hasProtoTrim ||
      /*#__PURE__*/
      ws.trim() || !
      /*#__PURE__*/
      zeroWidth.trim() ?
      /*#__PURE__*/
      _curry1(function trim(str) {
        var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
        var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
        return str.replace(beginRx, '').replace(endRx, '');
      }) :
      /*#__PURE__*/
      _curry1(function trim(str) {
        return str.trim();
      });
      var trim$1 = exports('trim', trim);

      /**
       * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned
       * function evaluates the `tryer`; if it does not throw, it simply returns the
       * result. If the `tryer` *does* throw, the returned function evaluates the
       * `catcher` function and returns its result. Note that for effective
       * composition with this function, both the `tryer` and `catcher` functions
       * must return the same type of results.
       *
       * @func
       * @memberOf R
       * @since v0.20.0
       * @category Function
       * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
       * @param {Function} tryer The function that may throw.
       * @param {Function} catcher The function that will be evaluated if `tryer` throws.
       * @return {Function} A new function that will catch exceptions and send then to the catcher.
       * @example
       *
       *      R.tryCatch(R.prop('x'), R.F)({x: true}); //=> true
       *      R.tryCatch(() => { throw 'foo'}, R.always('catched'))('bar') // => 'catched'
       *      R.tryCatch(R.times(R.identity), R.always([]))('s') // => []
       *      R.tryCatch(() => { throw 'this is not a valid value'}, (err, value)=>({error : err,  value }))('bar') // => {'error': 'this is not a valid value', 'value': 'bar'}
       */

      var tryCatch =
      /*#__PURE__*/
      _curry2(function _tryCatch(tryer, catcher) {
        return _arity(tryer.length, function () {
          try {
            return tryer.apply(this, arguments);
          } catch (e) {
            return catcher.apply(this, _concat([e], arguments));
          }
        });
      });

      var tryCatch$1 = exports('tryCatch', tryCatch);

      /**
       * Takes a function `fn`, which takes a single array argument, and returns a
       * function which:
       *
       *   - takes any number of positional arguments;
       *   - passes these arguments to `fn` as an array; and
       *   - returns the result.
       *
       * In other words, `R.unapply` derives a variadic function from a function which
       * takes an array. `R.unapply` is the inverse of [`R.apply`](#apply).
       *
       * @func
       * @memberOf R
       * @since v0.8.0
       * @category Function
       * @sig ([*...] -> a) -> (*... -> a)
       * @param {Function} fn
       * @return {Function}
       * @see R.apply
       * @example
       *
       *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
       * @symb R.unapply(f)(a, b) = f([a, b])
       */

      var unapply =
      /*#__PURE__*/
      _curry1(function unapply(fn) {
        return function () {
          return fn(Array.prototype.slice.call(arguments, 0));
        };
      });

      var unapply$1 = exports('unapply', unapply);

      /**
       * Wraps a function of any arity (including nullary) in a function that accepts
       * exactly 1 parameter. Any extraneous parameters will not be passed to the
       * supplied function.
       *
       * @func
       * @memberOf R
       * @since v0.2.0
       * @category Function
       * @sig (* -> b) -> (a -> b)
       * @param {Function} fn The function to wrap.
       * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
       *         arity 1.
       * @see R.binary, R.nAry
       * @example
       *
       *      const takesTwoArgs = function(a, b) {
       *        return [a, b];
       *      };
       *      takesTwoArgs.length; //=> 2
       *      takesTwoArgs(1, 2); //=> [1, 2]
       *
       *      const takesOneArg = R.unary(takesTwoArgs);
       *      takesOneArg.length; //=> 1
       *      // Only 1 argument is passed to the wrapped function
       *      takesOneArg(1, 2); //=> [1, undefined]
       * @symb R.unary(f)(a, b, c) = f(a)
       */

      var unary =
      /*#__PURE__*/
      _curry1(function unary(fn) {
        return nAry$1(1, fn);
      });

      var unary$1 = exports('unary', unary);

      /**
       * Returns a function of arity `n` from a (manually) curried function.
       *
       * @func
       * @memberOf R
       * @since v0.14.0
       * @category Function
       * @sig Number -> (a -> b) -> (a -> c)
       * @param {Number} length The arity for the returned function.
       * @param {Function} fn The function to uncurry.
       * @return {Function} A new function.
       * @see R.curry
       * @example
       *
       *      const addFour = a => b => c => d => a + b + c + d;
       *
       *      const uncurriedAddFour = R.uncurryN(4, addFour);
       *      uncurriedAddFour(1, 2, 3, 4); //=> 10
       */

      var uncurryN =
      /*#__PURE__*/
      _curry2(function uncurryN(depth, fn) {
        return curryN$1(depth, function () {
          var currentDepth = 1;
          var value = fn;
          var idx = 0;
          var endIdx;

          while (currentDepth <= depth && typeof value === 'function') {
            endIdx = currentDepth === depth ? arguments.length : idx + value.length;
            value = value.apply(this, Array.prototype.slice.call(arguments, idx, endIdx));
            currentDepth += 1;
            idx = endIdx;
          }

          return value;
        });
      });

      var uncurryN$1 = exports('uncurryN', uncurryN);

      /**
       * Builds a list from a seed value. Accepts an iterator function, which returns
       * either false to stop iteration or an array of length 2 containing the value
       * to add to the resulting list and the seed to be used in the next call to the
       * iterator function.
       *
       * The iterator function receives one argument: *(seed)*.
       *
       * @func
       * @memberOf R
       * @since v0.10.0
       * @category List
       * @sig (a -> [b]) -> * -> [b]
       * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
       *        either false to quit iteration or an array of length two to proceed. The element
       *        at index 0 of this array will be added to the resulting array, and the element
       *        at index 1 will be passed to the next call to `fn`.
       * @param {*} seed The seed value.
       * @return {Array} The final list.
       * @example
       *
       *      const f = n => n > 50 ? false : [-n, n + 10];
       *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
       * @symb R.unfold(f, x) = [f(x)[0], f(f(x)[1])[0], f(f(f(x)[1])[1])[0], ...]
       */

      var unfold =
      /*#__PURE__*/
      _curry2(function unfold(fn, seed) {
        var pair = fn(seed);
        var result = [];

        while (pair && pair.length) {
          result[result.length] = pair[0];
          pair = fn(pair[1]);
        }

        return result;
      });

      var unfold$1 = exports('unfold', unfold);

      /**
       * Combines two lists into a set (i.e. no duplicates) composed of the elements
       * of each list.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Relation
       * @sig [*] -> [*] -> [*]
       * @param {Array} as The first list.
       * @param {Array} bs The second list.
       * @return {Array} The first and second lists concatenated, with
       *         duplicates removed.
       * @example
       *
       *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
       */

      var union =
      /*#__PURE__*/
      _curry2(
      /*#__PURE__*/
      compose(uniq$1, _concat));

      var union$1 = exports('union', union);

      /**
       * Returns a new list containing only one copy of each element in the original
       * list, based upon the value returned by applying the supplied predicate to
       * two list elements. Prefers the first item if two items compare equal based
       * on the predicate.
       *
       * @func
       * @memberOf R
       * @since v0.2.0
       * @category List
       * @sig ((a, a) -> Boolean) -> [a] -> [a]
       * @param {Function} pred A predicate used to test whether two items are equal.
       * @param {Array} list The array to consider.
       * @return {Array} The list of unique items.
       * @example
       *
       *      const strEq = R.eqBy(String);
       *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
       *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
       *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
       *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
       */

      var uniqWith =
      /*#__PURE__*/
      _curry2(function uniqWith(pred, list) {
        var idx = 0;
        var len = list.length;
        var result = [];
        var item;

        while (idx < len) {
          item = list[idx];

          if (!_includesWith(pred, item, result)) {
            result[result.length] = item;
          }

          idx += 1;
        }

        return result;
      });

      var uniqWith$1 = exports('uniqWith', uniqWith);

      /**
       * Combines two lists into a set (i.e. no duplicates) composed of the elements
       * of each list. Duplication is determined according to the value returned by
       * applying the supplied predicate to two list elements.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category Relation
       * @sig ((a, a) -> Boolean) -> [*] -> [*] -> [*]
       * @param {Function} pred A predicate used to test whether two items are equal.
       * @param {Array} list1 The first list.
       * @param {Array} list2 The second list.
       * @return {Array} The first and second lists concatenated, with
       *         duplicates removed.
       * @see R.union
       * @example
       *
       *      const l1 = [{a: 1}, {a: 2}];
       *      const l2 = [{a: 1}, {a: 4}];
       *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
       */

      var unionWith =
      /*#__PURE__*/
      _curry3(function unionWith(pred, list1, list2) {
        return uniqWith$1(pred, _concat(list1, list2));
      });

      var unionWith$1 = exports('unionWith', unionWith);

      /**
       * Tests the final argument by passing it to the given predicate function. If
       * the predicate is not satisfied, the function will return the result of
       * calling the `whenFalseFn` function with the same argument. If the predicate
       * is satisfied, the argument is returned as is.
       *
       * @func
       * @memberOf R
       * @since v0.18.0
       * @category Logic
       * @sig (a -> Boolean) -> (a -> a) -> a -> a
       * @param {Function} pred        A predicate function
       * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
       *                               to a falsy value.
       * @param {*}        x           An object to test with the `pred` function and
       *                               pass to `whenFalseFn` if necessary.
       * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
       * @see R.ifElse, R.when, R.cond
       * @example
       *
       *      let safeInc = R.unless(R.isNil, R.inc);
       *      safeInc(null); //=> null
       *      safeInc(1); //=> 2
       */

      var unless =
      /*#__PURE__*/
      _curry3(function unless(pred, whenFalseFn, x) {
        return pred(x) ? x : whenFalseFn(x);
      });

      var unless$1 = exports('unless', unless);

      /**
       * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
       * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
       *
       * @func
       * @memberOf R
       * @since v0.3.0
       * @category List
       * @sig Chain c => c (c a) -> c a
       * @param {*} list
       * @return {*}
       * @see R.flatten, R.chain
       * @example
       *
       *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
       *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
       */

      var unnest =
      /*#__PURE__*/
      chain$1(_identity);
      var unnest$1 = exports('unnest', unnest);

      /**
       * Takes a predicate, a transformation function, and an initial value,
       * and returns a value of the same type as the initial value.
       * It does so by applying the transformation until the predicate is satisfied,
       * at which point it returns the satisfactory value.
       *
       * @func
       * @memberOf R
       * @since v0.20.0
       * @category Logic
       * @sig (a -> Boolean) -> (a -> a) -> a -> a
       * @param {Function} pred A predicate function
       * @param {Function} fn The iterator function
       * @param {*} init Initial value
       * @return {*} Final value that satisfies predicate
       * @example
       *
       *      R.until(R.gt(R.__, 100), R.multiply(2))(1) // => 128
       */

      var until =
      /*#__PURE__*/
      _curry3(function until(pred, fn, init) {
        var val = init;

        while (!pred(val)) {
          val = fn(val);
        }

        return val;
      });

      var until$1 = exports('until', until);

      /**
       * Returns a list of all the properties, including prototype properties, of the
       * supplied object.
       * Note that the order of the output array is not guaranteed to be consistent
       * across different JS platforms.
       *
       * @func
       * @memberOf R
       * @since v0.2.0
       * @category Object
       * @sig {k: v} -> [v]
       * @param {Object} obj The object to extract values from
       * @return {Array} An array of the values of the object's own and prototype properties.
       * @see R.values, R.keysIn
       * @example
       *
       *      const F = function() { this.x = 'X'; };
       *      F.prototype.y = 'Y';
       *      const f = new F();
       *      R.valuesIn(f); //=> ['X', 'Y']
       */

      var valuesIn =
      /*#__PURE__*/
      _curry1(function valuesIn(obj) {
        var prop;
        var vs = [];

        for (prop in obj) {
          vs[vs.length] = obj[prop];
        }

        return vs;
      });

      var valuesIn$1 = exports('valuesIn', valuesIn);

      var Const = function (x) {
        return {
          value: x,
          'fantasy-land/map': function () {
            return this;
          }
        };
      };
      /**
       * Returns a "view" of the given data structure, determined by the given lens.
       * The lens's focus determines which portion of the data structure is visible.
       *
       * @func
       * @memberOf R
       * @since v0.16.0
       * @category Object
       * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
       * @sig Lens s a -> s -> a
       * @param {Lens} lens
       * @param {*} x
       * @return {*}
       * @see R.prop, R.lensIndex, R.lensProp
       * @example
       *
       *      const xLens = R.lensProp('x');
       *
       *      R.view(xLens, {x: 1, y: 2});  //=> 1
       *      R.view(xLens, {x: 4, y: 2});  //=> 4
       */


      var view =
      /*#__PURE__*/
      _curry2(function view(lens, x) {
        // Using `Const` effectively ignores the setter function of the `lens`,
        // leaving the value returned by the getter function unmodified.
        return lens(Const)(x).value;
      });

      var view$1 = exports('view', view);

      /**
       * Tests the final argument by passing it to the given predicate function. If
       * the predicate is satisfied, the function will return the result of calling
       * the `whenTrueFn` function with the same argument. If the predicate is not
       * satisfied, the argument is returned as is.
       *
       * @func
       * @memberOf R
       * @since v0.18.0
       * @category Logic
       * @sig (a -> Boolean) -> (a -> a) -> a -> a
       * @param {Function} pred       A predicate function
       * @param {Function} whenTrueFn A function to invoke when the `condition`
       *                              evaluates to a truthy value.
       * @param {*}        x          An object to test with the `pred` function and
       *                              pass to `whenTrueFn` if necessary.
       * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
       * @see R.ifElse, R.unless, R.cond
       * @example
       *
       *      // truncate :: String -> String
       *      const truncate = R.when(
       *        R.propSatisfies(R.gt(R.__, 10), 'length'),
       *        R.pipe(R.take(10), R.append('…'), R.join(''))
       *      );
       *      truncate('12345');         //=> '12345'
       *      truncate('0123456789ABC'); //=> '0123456789…'
       */

      var when =
      /*#__PURE__*/
      _curry3(function when(pred, whenTrueFn, x) {
        return pred(x) ? whenTrueFn(x) : x;
      });

      var when$1 = exports('when', when);

      /**
       * Takes a spec object and a test object; returns true if the test satisfies
       * the spec. Each of the spec's own properties must be a predicate function.
       * Each predicate is applied to the value of the corresponding property of the
       * test object. `where` returns true if all the predicates return true, false
       * otherwise.
       *
       * `where` is well suited to declaratively expressing constraints for other
       * functions such as [`filter`](#filter) and [`find`](#find).
       *
       * @func
       * @memberOf R
       * @since v0.1.1
       * @category Object
       * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
       * @param {Object} spec
       * @param {Object} testObj
       * @return {Boolean}
       * @see R.propSatisfies, R.whereEq
       * @example
       *
       *      // pred :: Object -> Boolean
       *      const pred = R.where({
       *        a: R.equals('foo'),
       *        b: R.complement(R.equals('bar')),
       *        x: R.gt(R.__, 10),
       *        y: R.lt(R.__, 20)
       *      });
       *
       *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
       *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
       *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
       *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
       *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
       */

      var where =
      /*#__PURE__*/
      _curry2(function where(spec, testObj) {
        for (var prop in spec) {
          if (_has(prop, spec) && !spec[prop](testObj[prop])) {
            return false;
          }
        }

        return true;
      });

      var where$1 = exports('where', where);

      /**
       * Takes a spec object and a test object; returns true if the test satisfies
       * the spec, false otherwise. An object satisfies the spec if, for each of the
       * spec's own properties, accessing that property of the object gives the same
       * value (in [`R.equals`](#equals) terms) as accessing that property of the
       * spec.
       *
       * `whereEq` is a specialization of [`where`](#where).
       *
       * @func
       * @memberOf R
       * @since v0.14.0
       * @category Object
       * @sig {String: *} -> {String: *} -> Boolean
       * @param {Object} spec
       * @param {Object} testObj
       * @return {Boolean}
       * @see R.propEq, R.where
       * @example
       *
       *      // pred :: Object -> Boolean
       *      const pred = R.whereEq({a: 1, b: 2});
       *
       *      pred({a: 1});              //=> false
       *      pred({a: 1, b: 2});        //=> true
       *      pred({a: 1, b: 2, c: 3});  //=> true
       *      pred({a: 1, b: 1});        //=> false
       */

      var whereEq =
      /*#__PURE__*/
      _curry2(function whereEq(spec, testObj) {
        return where$1(map$1(equals$1, spec), testObj);
      });

      var whereEq$1 = exports('whereEq', whereEq);

      /**
       * Returns a new list without values in the first argument.
       * [`R.equals`](#equals) is used to determine equality.
       *
       * Acts as a transducer if a transformer is given in list position.
       *
       * @func
       * @memberOf R
       * @since v0.19.0
       * @category List
       * @sig [a] -> [a] -> [a]
       * @param {Array} list1 The values to be removed from `list2`.
       * @param {Array} list2 The array to remove values from.
       * @return {Array} The new array without values in `list1`.
       * @see R.transduce, R.difference, R.remove
       * @example
       *
       *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
       */

      var without =
      /*#__PURE__*/
      _curry2(function (xs, list) {
        return reject$1(flip$1(_includes)(xs), list);
      });

      var without$1 = exports('without', without);

      /**
       * Exclusive disjunction logical operation.
       * Returns `true` if one of the arguments is truthy and the other is falsy.
       * Otherwise, it returns `false`.
       *
       * @func
       * @memberOf R
       * @since v0.27.1
       * @category Logic
       * @sig a -> b -> Boolean
       * @param {Any} a
       * @param {Any} b
       * @return {Boolean} true if one of the arguments is truthy and the other is falsy
       * @see R.or, R.and
       * @example
       *
       *      R.xor(true, true); //=> false
       *      R.xor(true, false); //=> true
       *      R.xor(false, true); //=> true
       *      R.xor(false, false); //=> false
       */

      var xor =
      /*#__PURE__*/
      _curry2(function xor(a, b) {
        return Boolean(!a ^ !b);
      });

      var xor$1 = exports('xor', xor);

      /**
       * Creates a new list out of the two supplied by creating each possible pair
       * from the lists.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig [a] -> [b] -> [[a,b]]
       * @param {Array} as The first list.
       * @param {Array} bs The second list.
       * @return {Array} The list made by combining each possible pair from
       *         `as` and `bs` into pairs (`[a, b]`).
       * @example
       *
       *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
       * @symb R.xprod([a, b], [c, d]) = [[a, c], [a, d], [b, c], [b, d]]
       */

      var xprod =
      /*#__PURE__*/
      _curry2(function xprod(a, b) {
        // = xprodWith(prepend); (takes about 3 times as long...)
        var idx = 0;
        var ilen = a.length;
        var j;
        var jlen = b.length;
        var result = [];

        while (idx < ilen) {
          j = 0;

          while (j < jlen) {
            result[result.length] = [a[idx], b[j]];
            j += 1;
          }

          idx += 1;
        }

        return result;
      });

      var xprod$1 = exports('xprod', xprod);

      /**
       * Creates a new list out of the two supplied by pairing up equally-positioned
       * items from both lists. The returned list is truncated to the length of the
       * shorter of the two input lists.
       * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
       *
       * @func
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig [a] -> [b] -> [[a,b]]
       * @param {Array} list1 The first array to consider.
       * @param {Array} list2 The second array to consider.
       * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
       * @example
       *
       *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
       * @symb R.zip([a, b, c], [d, e, f]) = [[a, d], [b, e], [c, f]]
       */

      var zip =
      /*#__PURE__*/
      _curry2(function zip(a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);

        while (idx < len) {
          rv[idx] = [a[idx], b[idx]];
          idx += 1;
        }

        return rv;
      });

      var zip$1 = exports('zip', zip);

      /**
       * Creates a new object out of a list of keys and a list of values.
       * Key/value pairing is truncated to the length of the shorter of the two lists.
       * Note: `zipObj` is equivalent to `pipe(zip, fromPairs)`.
       *
       * @func
       * @memberOf R
       * @since v0.3.0
       * @category List
       * @sig [String] -> [*] -> {String: *}
       * @param {Array} keys The array that will be properties on the output object.
       * @param {Array} values The list of values on the output object.
       * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
       * @example
       *
       *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
       */

      var zipObj =
      /*#__PURE__*/
      _curry2(function zipObj(keys, values) {
        var idx = 0;
        var len = Math.min(keys.length, values.length);
        var out = {};

        while (idx < len) {
          out[keys[idx]] = values[idx];
          idx += 1;
        }

        return out;
      });

      var zipObj$1 = exports('zipObj', zipObj);

      /**
       * Creates a new list out of the two supplied by applying the function to each
       * equally-positioned pair in the lists. The returned list is truncated to the
       * length of the shorter of the two input lists.
       *
       * @function
       * @memberOf R
       * @since v0.1.0
       * @category List
       * @sig ((a, b) -> c) -> [a] -> [b] -> [c]
       * @param {Function} fn The function used to combine the two elements into one value.
       * @param {Array} list1 The first array to consider.
       * @param {Array} list2 The second array to consider.
       * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
       *         using `fn`.
       * @example
       *
       *      const f = (x, y) => {
       *        // ...
       *      };
       *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
       *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
       * @symb R.zipWith(fn, [a, b, c], [d, e, f]) = [fn(a, d), fn(b, e), fn(c, f)]
       */

      var zipWith =
      /*#__PURE__*/
      _curry3(function zipWith(fn, a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);

        while (idx < len) {
          rv[idx] = fn(a[idx], b[idx]);
          idx += 1;
        }

        return rv;
      });

      var zipWith$1 = exports('zipWith', zipWith);

      /**
       * Creates a thunk out of a function. A thunk delays a calculation until
       * its result is needed, providing lazy evaluation of arguments.
       *
       * @func
       * @memberOf R
       * @since v0.26.0
       * @category Function
       * @sig ((a, b, ..., j) -> k) -> (a, b, ..., j) -> (() -> k)
       * @param {Function} fn A function to wrap in a thunk
       * @return {Function} Expects arguments for `fn` and returns a new function
       *  that, when called, applies those arguments to `fn`.
       * @see R.partial, R.partialRight
       * @example
       *
       *      R.thunkify(R.identity)(42)(); //=> 42
       *      R.thunkify((a, b) => a + b)(25, 17)(); //=> 42
       */

      var thunkify =
      /*#__PURE__*/
      _curry1(function thunkify(fn) {
        return curryN$1(fn.length, function createThunk() {
          var fnArgs = arguments;
          return function invokeThunk() {
            return fn.apply(this, fnArgs);
          };
        });
      });

      var thunkify$1 = exports('thunkify', thunkify);

    })
  };
}));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9GLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL1QuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvX18uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2lzUGxhY2Vob2xkZXIuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2N1cnJ5MS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fY3VycnkyLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2FkZC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fY29uY2F0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19hcml0eS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fY3VycnlOLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2N1cnJ5Ti5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hZGRJbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fY3VycnkzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2FkanVzdC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNBcnJheS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNUcmFuc2Zvcm1lci5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19yZWR1Y2VkLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194ZkJhc2UuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hhbGwuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvYWxsLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21heC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fbWFwLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pc1N0cmluZy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNBcnJheUxpa2UuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3h3cmFwLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2JpbmQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3JlZHVjZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feG1hcC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faGFzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pc0FyZ3VtZW50cy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9rZXlzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21hcC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNJbnRlZ2VyLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL250aC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wYXRocy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wYXRoLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3Byb3AuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGx1Y2suanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcmVkdWNlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2FsbFBhc3MuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvYWx3YXlzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2FuZC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feGFueS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hbnkuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvYW55UGFzcy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hcC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fYXBlcnR1cmUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hhcGVydHVyZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hcGVydHVyZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hcHBlbmQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvYXBwbHkuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdmFsdWVzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2FwcGx5U3BlYy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hcHBseVRvLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2FzY2VuZC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hc3NvYy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pc05pbC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9hc3NvY1BhdGguanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbkFyeS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9iaW5hcnkuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2lzRnVuY3Rpb24uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbGlmdE4uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbGlmdC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9ib3RoLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2N1cnJ5LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2NhbGwuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX21ha2VGbGF0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19mb3JjZVJlZHVjZWQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2ZsYXRDYXQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hjaGFpbi5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9jaGFpbi5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9jbGFtcC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fY2xvbmVSZWdFeHAuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdHlwZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fY2xvbmUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY2xvbmUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY29tcGFyYXRvci5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9ub3QuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY29tcGxlbWVudC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fcGlwZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fY2hlY2tGb3JNZXRob2QuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvc2xpY2UuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdGFpbC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9waXBlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3JldmVyc2UuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY29tcG9zZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9jb21wb3NlSy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fcGlwZVAuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGlwZVAuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY29tcG9zZVAuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaGVhZC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faWRlbnRpdHkuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaWRlbnRpdHkuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGlwZVdpdGguanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY29tcG9zZVdpdGguanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2FycmF5RnJvbUl0ZXJhdG9yLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pbmNsdWRlc1dpdGguanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2Z1bmN0aW9uTmFtZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fb2JqZWN0SXMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2VxdWFscy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9lcXVhbHMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2luZGV4T2YuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2luY2x1ZGVzLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19xdW90ZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fdG9JU09TdHJpbmcuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2NvbXBsZW1lbnQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2ZpbHRlci5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9faXNPYmplY3QuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hmaWx0ZXIuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZmlsdGVyLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3JlamVjdC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fdG9TdHJpbmcuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdG9TdHJpbmcuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY29uY2F0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2NvbmQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY29uc3RydWN0Ti5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9jb25zdHJ1Y3QuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY29udGFpbnMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvY29udmVyZ2UuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hyZWR1Y2VCeS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9yZWR1Y2VCeS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9jb3VudEJ5LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2RlYy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9kZWZhdWx0VG8uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZGVzY2VuZC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fU2V0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2RpZmZlcmVuY2UuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZGlmZmVyZW5jZVdpdGguanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZGlzc29jLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3JlbW92ZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy91cGRhdGUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZGlzc29jUGF0aC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9kaXZpZGUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hkcm9wLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2Ryb3AuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3h0YWtlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3Rha2UuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2Ryb3BMYXN0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194ZHJvcExhc3QuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZHJvcExhc3QuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2Ryb3BMYXN0V2hpbGUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hkcm9wTGFzdFdoaWxlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2Ryb3BMYXN0V2hpbGUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hkcm9wUmVwZWF0c1dpdGguanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbGFzdC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9kcm9wUmVwZWF0c1dpdGguanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZHJvcFJlcGVhdHMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3hkcm9wV2hpbGUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZHJvcFdoaWxlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL29yLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2VpdGhlci5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9lbXB0eS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90YWtlTGFzdC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9lbmRzV2l0aC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9lcUJ5LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2VxUHJvcHMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZXZvbHZlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194ZmluZC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9maW5kLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194ZmluZEluZGV4LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ZpbmRJbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feGZpbmRMYXN0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ZpbmRMYXN0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194ZmluZExhc3RJbmRleC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9maW5kTGFzdEluZGV4LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ZsYXR0ZW4uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvZmxpcC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9mb3JFYWNoLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ZvckVhY2hPYmpJbmRleGVkLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2Zyb21QYWlycy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9ncm91cEJ5LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2dyb3VwV2l0aC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9ndC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9ndGUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaGFzUGF0aC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9oYXMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaGFzSW4uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaWRlbnRpY2FsLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2lmRWxzZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbmMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW5jbHVkZXMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW5kZXhCeS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbmRleE9mLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2luaXQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW5uZXJKb2luLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2luc2VydC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnNlcnRBbGwuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdW5pcUJ5LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3VuaXEuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJzZWN0aW9uLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVyc3BlcnNlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19vYmplY3RBc3NpZ24uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvb2JqT2YuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX3N0ZXBDYXQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50by5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnZlcnQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW52ZXJ0T2JqLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludm9rZXIuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaXMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaXNFbXB0eS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9qb2luLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2p1eHQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMva2V5c0luLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2xhc3RJbmRleE9mLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19pc051bWJlci5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9sZW5ndGguanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbGVucy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9sZW5zSW5kZXguanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbGVuc1BhdGguanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbGVuc1Byb3AuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbHQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbHRlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21hcEFjY3VtLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21hcEFjY3VtUmlnaHQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbWFwT2JqSW5kZXhlZC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tYXRjaC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tYXRoTW9kLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21heEJ5LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3N1bS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tZWFuLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21lZGlhbi5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tZW1vaXplV2l0aC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tZXJnZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tZXJnZUFsbC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tZXJnZVdpdGhLZXkuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbWVyZ2VEZWVwV2l0aEtleS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tZXJnZURlZXBMZWZ0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21lcmdlRGVlcFJpZ2h0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21lcmdlRGVlcFdpdGguanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbWVyZ2VMZWZ0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21lcmdlUmlnaHQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbWVyZ2VXaXRoLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL21pbi5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9taW5CeS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tb2R1bG8uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbW92ZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9tdWx0aXBseS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9uZWdhdGUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvbm9uZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9udGhBcmcuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvby5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9fb2YuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvb2YuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvb21pdC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9vbmNlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL19hc3NlcnRQcm9taXNlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL290aGVyd2lzZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9vdmVyLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3BhaXIuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3BhcnRpYWwuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGFydGlhbFJpZ2h0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3BhcnRpdGlvbi5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wYXRoRXEuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGF0aE9yLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3BhdGhTYXRpc2ZpZXMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcGljay5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9waWNrQWxsLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3BpY2tCeS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9waXBlSy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wcmVwZW5kLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3Byb2R1Y3QuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdXNlV2l0aC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wcm9qZWN0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3Byb3BFcS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9wcm9wSXMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcHJvcE9yLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3Byb3BTYXRpc2ZpZXMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcHJvcHMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcmFuZ2UuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcmVkdWNlUmlnaHQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcmVkdWNlV2hpbGUuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcmVkdWNlZC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90aW1lcy5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9yZXBlYXQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvcmVwbGFjZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9zY2FuLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3NlcXVlbmNlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3NldC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9zb3J0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3NvcnRCeS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9zb3J0V2l0aC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9zcGxpdC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9zcGxpdEF0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3NwbGl0RXZlcnkuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvc3BsaXRXaGVuLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3N0YXJ0c1dpdGguanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvc3VidHJhY3QuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvc3ltbWV0cmljRGlmZmVyZW5jZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9zeW1tZXRyaWNEaWZmZXJlbmNlV2l0aC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90YWtlTGFzdFdoaWxlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL2ludGVybmFsL194dGFrZVdoaWxlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3Rha2VXaGlsZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy9pbnRlcm5hbC9feHRhcC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90YXAuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvaW50ZXJuYWwvX2lzUmVnRXhwLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3Rlc3QuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvYW5kVGhlbi5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90b0xvd2VyLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3RvUGFpcnMuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdG9QYWlyc0luLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3RvVXBwZXIuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdHJhbnNkdWNlLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3RyYW5zcG9zZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90cmF2ZXJzZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90cmltLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3RyeUNhdGNoLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3VuYXBwbHkuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdW5hcnkuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdW5jdXJyeU4uanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdW5mb2xkLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3VuaW9uLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3VuaXFXaXRoLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3VuaW9uV2l0aC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy91bmxlc3MuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvdW5uZXN0LmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3VudGlsLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3ZhbHVlc0luLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3ZpZXcuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvd2hlbi5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy93aGVyZS5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy93aGVyZUVxLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3dpdGhvdXQuanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMveG9yLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3hwcm9kLmpzIiwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3JhbWRhL2VzL3ppcC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy96aXBPYmouanMiLCIuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcmFtZGEvZXMvemlwV2l0aC5qcyIsIi4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9yYW1kYS9lcy90aHVua2lmeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyBgZmFsc2VgLiBBbnkgcGFzc2VkIGluIHBhcmFtZXRlcnMgYXJlIGlnbm9yZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKiAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLlRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLkYoKTsgLy89PiBmYWxzZVxuICovXG52YXIgRiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRjsiLCIvKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyBgdHJ1ZWAuIEFueSBwYXNzZWQgaW4gcGFyYW1ldGVycyBhcmUgaWdub3JlZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAqIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIuRlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuVCgpOyAvLz0+IHRydWVcbiAqL1xudmFyIFQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVDsiLCIvKipcbiAqIEEgc3BlY2lhbCBwbGFjZWhvbGRlciB2YWx1ZSB1c2VkIHRvIHNwZWNpZnkgXCJnYXBzXCIgd2l0aGluIGN1cnJpZWQgZnVuY3Rpb25zLFxuICogYWxsb3dpbmcgcGFydGlhbCBhcHBsaWNhdGlvbiBvZiBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzLCByZWdhcmRsZXNzIG9mXG4gKiB0aGVpciBwb3NpdGlvbnMuXG4gKlxuICogSWYgYGdgIGlzIGEgY3VycmllZCB0ZXJuYXJ5IGZ1bmN0aW9uIGFuZCBgX2AgaXMgYFIuX19gLCB0aGUgZm9sbG93aW5nIGFyZVxuICogZXF1aXZhbGVudDpcbiAqXG4gKiAgIC0gYGcoMSwgMiwgMylgXG4gKiAgIC0gYGcoXywgMiwgMykoMSlgXG4gKiAgIC0gYGcoXywgXywgMykoMSkoMilgXG4gKiAgIC0gYGcoXywgXywgMykoMSwgMilgXG4gKiAgIC0gYGcoXywgMiwgXykoMSwgMylgXG4gKiAgIC0gYGcoXywgMikoMSkoMylgXG4gKiAgIC0gYGcoXywgMikoMSwgMylgXG4gKiAgIC0gYGcoXywgMikoXywgMykoMSlgXG4gKlxuICogQG5hbWUgX19cbiAqIEBjb25zdGFudFxuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC42LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGdyZWV0ID0gUi5yZXBsYWNlKCd7bmFtZX0nLCBSLl9fLCAnSGVsbG8sIHtuYW1lfSEnKTtcbiAqICAgICAgZ3JlZXQoJ0FsaWNlJyk7IC8vPT4gJ0hlbGxvLCBBbGljZSEnXG4gKi9cbmV4cG9ydCBkZWZhdWx0IHtcbiAgJ0BAZnVuY3Rpb25hbC9wbGFjZWhvbGRlcic6IHRydWVcbn07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2lzUGxhY2Vob2xkZXIoYSkge1xuICByZXR1cm4gYSAhPSBudWxsICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhWydAQGZ1bmN0aW9uYWwvcGxhY2Vob2xkZXInXSA9PT0gdHJ1ZTtcbn0iLCJpbXBvcnQgX2lzUGxhY2Vob2xkZXIgZnJvbSBcIi4vX2lzUGxhY2Vob2xkZXIuanNcIjtcbi8qKlxuICogT3B0aW1pemVkIGludGVybmFsIG9uZS1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2N1cnJ5MShmbikge1xuICByZXR1cm4gZnVuY3Rpb24gZjEoYSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwIHx8IF9pc1BsYWNlaG9sZGVyKGEpKSB7XG4gICAgICByZXR1cm4gZjE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcbn0iLCJpbXBvcnQgX2N1cnJ5MSBmcm9tIFwiLi9fY3VycnkxLmpzXCI7XG5pbXBvcnQgX2lzUGxhY2Vob2xkZXIgZnJvbSBcIi4vX2lzUGxhY2Vob2xkZXIuanNcIjtcbi8qKlxuICogT3B0aW1pemVkIGludGVybmFsIHR3by1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2N1cnJ5Mihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gZjIoYSwgYikge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gZjI7XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpID8gZjIgOiBfY3VycnkxKGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgIHJldHVybiBmbihhLCBfYik7XG4gICAgICAgIH0pO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gX2lzUGxhY2Vob2xkZXIoYSkgJiYgX2lzUGxhY2Vob2xkZXIoYikgPyBmMiA6IF9pc1BsYWNlaG9sZGVyKGEpID8gX2N1cnJ5MShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICByZXR1cm4gZm4oX2EsIGIpO1xuICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGIpID8gX2N1cnJ5MShmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICByZXR1cm4gZm4oYSwgX2IpO1xuICAgICAgICB9KSA6IGZuKGEsIGIpO1xuICAgIH1cbiAgfTtcbn0iLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG4vKipcbiAqIEFkZHMgdHdvIHZhbHVlcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gTnVtYmVyXG4gKiBAcGFyYW0ge051bWJlcn0gYVxuICogQHBhcmFtIHtOdW1iZXJ9IGJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBzZWUgUi5zdWJ0cmFjdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuYWRkKDIsIDMpOyAgICAgICAvLz0+ICA1XG4gKiAgICAgIFIuYWRkKDcpKDEwKTsgICAgICAvLz0+IDE3XG4gKi9cblxudmFyIGFkZCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIGFkZChhLCBiKSB7XG4gIHJldHVybiBOdW1iZXIoYSkgKyBOdW1iZXIoYik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYWRkOyIsIi8qKlxuICogUHJpdmF0ZSBgY29uY2F0YCBmdW5jdGlvbiB0byBtZXJnZSB0d28gYXJyYXktbGlrZSBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fEFyZ3VtZW50c30gW3NldDE9W11dIEFuIGFycmF5LWxpa2Ugb2JqZWN0LlxuICogQHBhcmFtIHtBcnJheXxBcmd1bWVudHN9IFtzZXQyPVtdXSBBbiBhcnJheS1saWtlIG9iamVjdC5cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldywgbWVyZ2VkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIF9jb25jYXQoWzQsIDUsIDZdLCBbMSwgMiwgM10pOyAvLz0+IFs0LCA1LCA2LCAxLCAyLCAzXVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY29uY2F0KHNldDEsIHNldDIpIHtcbiAgc2V0MSA9IHNldDEgfHwgW107XG4gIHNldDIgPSBzZXQyIHx8IFtdO1xuICB2YXIgaWR4O1xuICB2YXIgbGVuMSA9IHNldDEubGVuZ3RoO1xuICB2YXIgbGVuMiA9IHNldDIubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlkeCA9IDA7XG5cbiAgd2hpbGUgKGlkeCA8IGxlbjEpIHtcbiAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBzZXQxW2lkeF07XG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICBpZHggPSAwO1xuXG4gIHdoaWxlIChpZHggPCBsZW4yKSB7XG4gICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gc2V0MltpZHhdO1xuICAgIGlkeCArPSAxO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJpdHkobiwgZm4pIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbiAgc3dpdGNoIChuKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMykge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCkge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgY2FzZSA3OlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNikge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNykge1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDk6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgY2FzZSAxMDpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gX2FyaXR5IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciBubyBncmVhdGVyIHRoYW4gdGVuJyk7XG4gIH1cbn0iLCJpbXBvcnQgX2FyaXR5IGZyb20gXCIuL19hcml0eS5qc1wiO1xuaW1wb3J0IF9pc1BsYWNlaG9sZGVyIGZyb20gXCIuL19pc1BsYWNlaG9sZGVyLmpzXCI7XG4vKipcbiAqIEludGVybmFsIGN1cnJ5TiBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBhcml0eSBvZiB0aGUgY3VycmllZCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IHJlY2VpdmVkIEFuIGFycmF5IG9mIGFyZ3VtZW50cyByZWNlaXZlZCB0aHVzIGZhci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY3VycmllZCBmdW5jdGlvbi5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY3VycnlOKGxlbmd0aCwgcmVjZWl2ZWQsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNvbWJpbmVkID0gW107XG4gICAgdmFyIGFyZ3NJZHggPSAwO1xuICAgIHZhciBsZWZ0ID0gbGVuZ3RoO1xuICAgIHZhciBjb21iaW5lZElkeCA9IDA7XG5cbiAgICB3aGlsZSAoY29tYmluZWRJZHggPCByZWNlaXZlZC5sZW5ndGggfHwgYXJnc0lkeCA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGlmIChjb21iaW5lZElkeCA8IHJlY2VpdmVkLmxlbmd0aCAmJiAoIV9pc1BsYWNlaG9sZGVyKHJlY2VpdmVkW2NvbWJpbmVkSWR4XSkgfHwgYXJnc0lkeCA+PSBhcmd1bWVudHMubGVuZ3RoKSkge1xuICAgICAgICByZXN1bHQgPSByZWNlaXZlZFtjb21iaW5lZElkeF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBhcmd1bWVudHNbYXJnc0lkeF07XG4gICAgICAgIGFyZ3NJZHggKz0gMTtcbiAgICAgIH1cblxuICAgICAgY29tYmluZWRbY29tYmluZWRJZHhdID0gcmVzdWx0O1xuXG4gICAgICBpZiAoIV9pc1BsYWNlaG9sZGVyKHJlc3VsdCkpIHtcbiAgICAgICAgbGVmdCAtPSAxO1xuICAgICAgfVxuXG4gICAgICBjb21iaW5lZElkeCArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBsZWZ0IDw9IDAgPyBmbi5hcHBseSh0aGlzLCBjb21iaW5lZCkgOiBfYXJpdHkobGVmdCwgX2N1cnJ5TihsZW5ndGgsIGNvbWJpbmVkLCBmbikpO1xuICB9O1xufSIsImltcG9ydCBfYXJpdHkgZnJvbSBcIi4vaW50ZXJuYWwvX2FyaXR5LmpzXCI7XG5pbXBvcnQgX2N1cnJ5MSBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkxLmpzXCI7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgX2N1cnJ5TiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnlOLmpzXCI7XG4vKipcbiAqIFJldHVybnMgYSBjdXJyaWVkIGVxdWl2YWxlbnQgb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLCB3aXRoIHRoZSBzcGVjaWZpZWRcbiAqIGFyaXR5LiBUaGUgY3VycmllZCBmdW5jdGlvbiBoYXMgdHdvIHVudXN1YWwgY2FwYWJpbGl0aWVzLiBGaXJzdCwgaXRzXG4gKiBhcmd1bWVudHMgbmVlZG4ndCBiZSBwcm92aWRlZCBvbmUgYXQgYSB0aW1lLiBJZiBgZ2AgaXMgYFIuY3VycnlOKDMsIGYpYCwgdGhlXG4gKiBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAtIGBnKDEpKDIpKDMpYFxuICogICAtIGBnKDEpKDIsIDMpYFxuICogICAtIGBnKDEsIDIpKDMpYFxuICogICAtIGBnKDEsIDIsIDMpYFxuICpcbiAqIFNlY29uZGx5LCB0aGUgc3BlY2lhbCBwbGFjZWhvbGRlciB2YWx1ZSBbYFIuX19gXSgjX18pIG1heSBiZSB1c2VkIHRvIHNwZWNpZnlcbiAqIFwiZ2Fwc1wiLCBhbGxvd2luZyBwYXJ0aWFsIGFwcGxpY2F0aW9uIG9mIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMsXG4gKiByZWdhcmRsZXNzIG9mIHRoZWlyIHBvc2l0aW9ucy4gSWYgYGdgIGlzIGFzIGFib3ZlIGFuZCBgX2AgaXMgW2BSLl9fYF0oI19fKSxcbiAqIHRoZSBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAtIGBnKDEsIDIsIDMpYFxuICogICAtIGBnKF8sIDIsIDMpKDEpYFxuICogICAtIGBnKF8sIF8sIDMpKDEpKDIpYFxuICogICAtIGBnKF8sIF8sIDMpKDEsIDIpYFxuICogICAtIGBnKF8sIDIpKDEpKDMpYFxuICogICAtIGBnKF8sIDIpKDEsIDMpYFxuICogICAtIGBnKF8sIDIpKF8sIDMpKDEpYFxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjUuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIE51bWJlciAtPiAoKiAtPiBhKSAtPiAoKiAtPiBhKVxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgYXJpdHkgZm9yIHRoZSByZXR1cm5lZCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjdXJyeS5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldywgY3VycmllZCBmdW5jdGlvbi5cbiAqIEBzZWUgUi5jdXJyeVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IHN1bUFyZ3MgPSAoLi4uYXJncykgPT4gUi5zdW0oYXJncyk7XG4gKlxuICogICAgICBjb25zdCBjdXJyaWVkQWRkRm91ck51bWJlcnMgPSBSLmN1cnJ5Tig0LCBzdW1BcmdzKTtcbiAqICAgICAgY29uc3QgZiA9IGN1cnJpZWRBZGRGb3VyTnVtYmVycygxLCAyKTtcbiAqICAgICAgY29uc3QgZyA9IGYoMyk7XG4gKiAgICAgIGcoNCk7IC8vPT4gMTBcbiAqL1xuXG52YXIgY3VycnlOID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gY3VycnlOKGxlbmd0aCwgZm4pIHtcbiAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBfY3VycnkxKGZuKTtcbiAgfVxuXG4gIHJldHVybiBfYXJpdHkobGVuZ3RoLCBfY3VycnlOKGxlbmd0aCwgW10sIGZuKSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY3VycnlOOyIsImltcG9ydCBfY29uY2F0IGZyb20gXCIuL2ludGVybmFsL19jb25jYXQuanNcIjtcbmltcG9ydCBfY3VycnkxIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTEuanNcIjtcbmltcG9ydCBjdXJyeU4gZnJvbSBcIi4vY3VycnlOLmpzXCI7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbGlzdCBpdGVyYXRpb24gZnVuY3Rpb24gZnJvbSBhbiBleGlzdGluZyBvbmUgYnkgYWRkaW5nIHR3byBuZXdcbiAqIHBhcmFtZXRlcnMgdG8gaXRzIGNhbGxiYWNrIGZ1bmN0aW9uOiB0aGUgY3VycmVudCBpbmRleCwgYW5kIHRoZSBlbnRpcmUgbGlzdC5cbiAqXG4gKiBUaGlzIHdvdWxkIHR1cm4sIGZvciBpbnN0YW5jZSwgW2BSLm1hcGBdKCNtYXApIGZ1bmN0aW9uIGludG8gb25lIHRoYXRcbiAqIG1vcmUgY2xvc2VseSByZXNlbWJsZXMgYEFycmF5LnByb3RvdHlwZS5tYXBgLiBOb3RlIHRoYXQgdGhpcyB3aWxsIG9ubHkgd29ya1xuICogZm9yIGZ1bmN0aW9ucyBpbiB3aGljaCB0aGUgaXRlcmF0aW9uIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIHRoZSBmaXJzdFxuICogcGFyYW1ldGVyLCBhbmQgd2hlcmUgdGhlIGxpc3QgaXMgdGhlIGxhc3QgcGFyYW1ldGVyLiAoVGhpcyBsYXR0ZXIgbWlnaHQgYmVcbiAqIHVuaW1wb3J0YW50IGlmIHRoZSBsaXN0IHBhcmFtZXRlciBpcyBub3QgdXNlZC4pXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTUuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoKGEgLi4uIC0+IGIpIC4uLiAtPiBbYV0gLT4gKikgLT4gKChhIC4uLiwgSW50LCBbYV0gLT4gYikgLi4uIC0+IFthXSAtPiAqKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQSBsaXN0IGl0ZXJhdGlvbiBmdW5jdGlvbiB0aGF0IGRvZXMgbm90IHBhc3MgaW5kZXggb3IgbGlzdCB0byBpdHMgY2FsbGJhY2tcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBbiBhbHRlcmVkIGxpc3QgaXRlcmF0aW9uIGZ1bmN0aW9uIHRoYXQgcGFzc2VzIChpdGVtLCBpbmRleCwgbGlzdCkgdG8gaXRzIGNhbGxiYWNrXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgbWFwSW5kZXhlZCA9IFIuYWRkSW5kZXgoUi5tYXApO1xuICogICAgICBtYXBJbmRleGVkKCh2YWwsIGlkeCkgPT4gaWR4ICsgJy0nICsgdmFsLCBbJ2YnLCAnbycsICdvJywgJ2InLCAnYScsICdyJ10pO1xuICogICAgICAvLz0+IFsnMC1mJywgJzEtbycsICcyLW8nLCAnMy1iJywgJzQtYScsICc1LXInXVxuICovXG5cbnZhciBhZGRJbmRleCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKGZ1bmN0aW9uIGFkZEluZGV4KGZuKSB7XG4gIHJldHVybiBjdXJyeU4oZm4ubGVuZ3RoLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIG9yaWdGbiA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbGlzdCA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgYXJnc1swXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciByZXN1bHQgPSBvcmlnRm4uYXBwbHkodGhpcywgX2NvbmNhdChhcmd1bWVudHMsIFtpZHgsIGxpc3RdKSk7XG4gICAgICBpZHggKz0gMTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYWRkSW5kZXg7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSBcIi4vX2N1cnJ5MS5qc1wiO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9pc1BsYWNlaG9sZGVyIGZyb20gXCIuL19pc1BsYWNlaG9sZGVyLmpzXCI7XG4vKipcbiAqIE9wdGltaXplZCBpbnRlcm5hbCB0aHJlZS1hcml0eSBjdXJyeSBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGN1cnJpZWQgZnVuY3Rpb24uXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2N1cnJ5Myhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gZjMoYSwgYiwgYykge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gZjM7XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpID8gZjMgOiBfY3VycnkyKGZ1bmN0aW9uIChfYiwgX2MpIHtcbiAgICAgICAgICByZXR1cm4gZm4oYSwgX2IsIF9jKTtcbiAgICAgICAgfSk7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGIpID8gZjMgOiBfaXNQbGFjZWhvbGRlcihhKSA/IF9jdXJyeTIoZnVuY3Rpb24gKF9hLCBfYykge1xuICAgICAgICAgIHJldHVybiBmbihfYSwgYiwgX2MpO1xuICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGIpID8gX2N1cnJ5MihmdW5jdGlvbiAoX2IsIF9jKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKGEsIF9iLCBfYyk7XG4gICAgICAgIH0pIDogX2N1cnJ5MShmdW5jdGlvbiAoX2MpIHtcbiAgICAgICAgICByZXR1cm4gZm4oYSwgYiwgX2MpO1xuICAgICAgICB9KTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGIpICYmIF9pc1BsYWNlaG9sZGVyKGMpID8gZjMgOiBfaXNQbGFjZWhvbGRlcihhKSAmJiBfaXNQbGFjZWhvbGRlcihiKSA/IF9jdXJyeTIoZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICAgIHJldHVybiBmbihfYSwgX2IsIGMpO1xuICAgICAgICB9KSA6IF9pc1BsYWNlaG9sZGVyKGEpICYmIF9pc1BsYWNlaG9sZGVyKGMpID8gX2N1cnJ5MihmdW5jdGlvbiAoX2EsIF9jKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKF9hLCBiLCBfYyk7XG4gICAgICAgIH0pIDogX2lzUGxhY2Vob2xkZXIoYikgJiYgX2lzUGxhY2Vob2xkZXIoYykgPyBfY3VycnkyKGZ1bmN0aW9uIChfYiwgX2MpIHtcbiAgICAgICAgICByZXR1cm4gZm4oYSwgX2IsIF9jKTtcbiAgICAgICAgfSkgOiBfaXNQbGFjZWhvbGRlcihhKSA/IF9jdXJyeTEoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKF9hLCBiLCBjKTtcbiAgICAgICAgfSkgOiBfaXNQbGFjZWhvbGRlcihiKSA/IF9jdXJyeTEoZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKGEsIF9iLCBjKTtcbiAgICAgICAgfSkgOiBfaXNQbGFjZWhvbGRlcihjKSA/IF9jdXJyeTEoZnVuY3Rpb24gKF9jKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKGEsIGIsIF9jKTtcbiAgICAgICAgfSkgOiBmbihhLCBiLCBjKTtcbiAgICB9XG4gIH07XG59IiwiaW1wb3J0IF9jb25jYXQgZnJvbSBcIi4vaW50ZXJuYWwvX2NvbmNhdC5qc1wiO1xuaW1wb3J0IF9jdXJyeTMgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5My5qc1wiO1xuLyoqXG4gKiBBcHBsaWVzIGEgZnVuY3Rpb24gdG8gdGhlIHZhbHVlIGF0IHRoZSBnaXZlbiBpbmRleCBvZiBhbiBhcnJheSwgcmV0dXJuaW5nIGFcbiAqIG5ldyBjb3B5IG9mIHRoZSBhcnJheSB3aXRoIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleCByZXBsYWNlZCB3aXRoIHRoZVxuICogcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBhcHBsaWNhdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNC4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gKGEgLT4gYSkgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtOdW1iZXJ9IGlkeCBUaGUgaW5kZXguXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYXBwbHkuXG4gKiBAcGFyYW0ge0FycmF5fEFyZ3VtZW50c30gbGlzdCBBbiBhcnJheS1saWtlIG9iamVjdCB3aG9zZSB2YWx1ZVxuICogICAgICAgIGF0IHRoZSBzdXBwbGllZCBpbmRleCB3aWxsIGJlIHJlcGxhY2VkLlxuICogQHJldHVybiB7QXJyYXl9IEEgY29weSBvZiB0aGUgc3VwcGxpZWQgYXJyYXktbGlrZSBvYmplY3Qgd2l0aFxuICogICAgICAgICB0aGUgZWxlbWVudCBhdCBpbmRleCBgaWR4YCByZXBsYWNlZCB3aXRoIHRoZSB2YWx1ZVxuICogICAgICAgICByZXR1cm5lZCBieSBhcHBseWluZyBgZm5gIHRvIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICogQHNlZSBSLnVwZGF0ZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuYWRqdXN0KDEsIFIudG9VcHBlciwgWydhJywgJ2InLCAnYycsICdkJ10pOyAgICAgIC8vPT4gWydhJywgJ0InLCAnYycsICdkJ11cbiAqICAgICAgUi5hZGp1c3QoLTEsIFIudG9VcHBlciwgWydhJywgJ2InLCAnYycsICdkJ10pOyAgICAgLy89PiBbJ2EnLCAnYicsICdjJywgJ0QnXVxuICogQHN5bWIgUi5hZGp1c3QoLTEsIGYsIFthLCBiXSkgPSBbYSwgZihiKV1cbiAqIEBzeW1iIFIuYWRqdXN0KDAsIGYsIFthLCBiXSkgPSBbZihhKSwgYl1cbiAqL1xuXG52YXIgYWRqdXN0ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTMoZnVuY3Rpb24gYWRqdXN0KGlkeCwgZm4sIGxpc3QpIHtcbiAgaWYgKGlkeCA+PSBsaXN0Lmxlbmd0aCB8fCBpZHggPCAtbGlzdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIHZhciBzdGFydCA9IGlkeCA8IDAgPyBsaXN0Lmxlbmd0aCA6IDA7XG5cbiAgdmFyIF9pZHggPSBzdGFydCArIGlkeDtcblxuICB2YXIgX2xpc3QgPSBfY29uY2F0KGxpc3QpO1xuXG4gIF9saXN0W19pZHhdID0gZm4obGlzdFtfaWR4XSk7XG4gIHJldHVybiBfbGlzdDtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBhZGp1c3Q7IiwiLyoqXG4gKiBUZXN0cyB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgaXMgYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSBvYmplY3QgdG8gdGVzdC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBgdmFsYCBpcyBhbiBhcnJheSwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgX2lzQXJyYXkoW10pOyAvLz0+IHRydWVcbiAqICAgICAgX2lzQXJyYXkobnVsbCk7IC8vPT4gZmFsc2VcbiAqICAgICAgX2lzQXJyYXkoe30pOyAvLz0+IGZhbHNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gX2lzQXJyYXkodmFsKSB7XG4gIHJldHVybiB2YWwgIT0gbnVsbCAmJiB2YWwubGVuZ3RoID49IDAgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pc1RyYW5zZm9ybWVyKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9ialsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9PT0gJ2Z1bmN0aW9uJztcbn0iLCJpbXBvcnQgX2lzQXJyYXkgZnJvbSBcIi4vX2lzQXJyYXkuanNcIjtcbmltcG9ydCBfaXNUcmFuc2Zvcm1lciBmcm9tIFwiLi9faXNUcmFuc2Zvcm1lci5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBkaXNwYXRjaGVzIHdpdGggZGlmZmVyZW50IHN0cmF0ZWdpZXMgYmFzZWQgb24gdGhlXG4gKiBvYmplY3QgaW4gbGlzdCBwb3NpdGlvbiAobGFzdCBhcmd1bWVudCkuIElmIGl0IGlzIGFuIGFycmF5LCBleGVjdXRlcyBbZm5dLlxuICogT3RoZXJ3aXNlLCBpZiBpdCBoYXMgYSBmdW5jdGlvbiB3aXRoIG9uZSBvZiB0aGUgZ2l2ZW4gbWV0aG9kIG5hbWVzLCBpdCB3aWxsXG4gKiBleGVjdXRlIHRoYXQgZnVuY3Rpb24gKGZ1bmN0b3IgY2FzZSkuIE90aGVyd2lzZSwgaWYgaXQgaXMgYSB0cmFuc2Zvcm1lcixcbiAqIHVzZXMgdHJhbnNkdWNlciBbeGZdIHRvIHJldHVybiBhIG5ldyB0cmFuc2Zvcm1lciAodHJhbnNkdWNlciBjYXNlKS5cbiAqIE90aGVyd2lzZSwgaXQgd2lsbCBkZWZhdWx0IHRvIGV4ZWN1dGluZyBbZm5dLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBtZXRob2ROYW1lcyBwcm9wZXJ0aWVzIHRvIGNoZWNrIGZvciBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0geGYgdHJhbnNkdWNlciB0byBpbml0aWFsaXplIGlmIG9iamVjdCBpcyB0cmFuc2Zvcm1lclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gZGVmYXVsdCByYW1kYSBpbXBsZW1lbnRhdGlvblxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCBkaXNwYXRjaGVzIG9uIG9iamVjdCBpbiBsaXN0IHBvc2l0aW9uXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2Rpc3BhdGNoYWJsZShtZXRob2ROYW1lcywgeGYsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH1cblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICB2YXIgb2JqID0gYXJncy5wb3AoKTtcblxuICAgIGlmICghX2lzQXJyYXkob2JqKSkge1xuICAgICAgdmFyIGlkeCA9IDA7XG5cbiAgICAgIHdoaWxlIChpZHggPCBtZXRob2ROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmpbbWV0aG9kTmFtZXNbaWR4XV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gb2JqW21ldGhvZE5hbWVzW2lkeF1dLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZHggKz0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9pc1RyYW5zZm9ybWVyKG9iaikpIHtcbiAgICAgICAgdmFyIHRyYW5zZHVjZXIgPSB4Zi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zZHVjZXIob2JqKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfcmVkdWNlZCh4KSB7XG4gIHJldHVybiB4ICYmIHhbJ0BAdHJhbnNkdWNlci9yZWR1Y2VkJ10gPyB4IDoge1xuICAgICdAQHRyYW5zZHVjZXIvdmFsdWUnOiB4LFxuICAgICdAQHRyYW5zZHVjZXIvcmVkdWNlZCc6IHRydWVcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCB7XG4gIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL2luaXQnXSgpO1xuICB9LFxuICByZXN1bHQ6IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gIH1cbn07IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9yZWR1Y2VkIGZyb20gXCIuL19yZWR1Y2VkLmpzXCI7XG5pbXBvcnQgX3hmQmFzZSBmcm9tIFwiLi9feGZCYXNlLmpzXCI7XG5cbnZhciBYQWxsID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWEFsbChmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHRoaXMuYWxsID0gdHJ1ZTtcbiAgfVxuXG4gIFhBbGwucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuXG4gIFhBbGwucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgaWYgKHRoaXMuYWxsKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9O1xuXG4gIFhBbGwucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICBpZiAoIXRoaXMuZihpbnB1dCkpIHtcbiAgICAgIHRoaXMuYWxsID0gZmFsc2U7XG4gICAgICByZXN1bHQgPSBfcmVkdWNlZCh0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgZmFsc2UpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBYQWxsO1xufSgpO1xuXG52YXIgX3hhbGwgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBfeGFsbChmLCB4Zikge1xuICByZXR1cm4gbmV3IFhBbGwoZiwgeGYpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IF94YWxsOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gXCIuL2ludGVybmFsL19kaXNwYXRjaGFibGUuanNcIjtcbmltcG9ydCBfeGFsbCBmcm9tIFwiLi9pbnRlcm5hbC9feGFsbC5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgb2YgdGhlIGxpc3QgbWF0Y2ggdGhlIHByZWRpY2F0ZSwgYGZhbHNlYCBpZlxuICogdGhlcmUgYXJlIGFueSB0aGF0IGRvbid0LlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBhbGxgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByZWRpY2F0ZSBpcyBzYXRpc2ZpZWQgYnkgZXZlcnkgZWxlbWVudCwgYGZhbHNlYFxuICogICAgICAgICBvdGhlcndpc2UuXG4gKiBAc2VlIFIuYW55LCBSLm5vbmUsIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgZXF1YWxzMyA9IFIuZXF1YWxzKDMpO1xuICogICAgICBSLmFsbChlcXVhbHMzKShbMywgMywgMywgM10pOyAvLz0+IHRydWVcbiAqICAgICAgUi5hbGwoZXF1YWxzMykoWzMsIDMsIDEsIDNdKTsgLy89PiBmYWxzZVxuICovXG5cbnZhciBhbGwgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5Mihcbi8qI19fUFVSRV9fKi9cbl9kaXNwYXRjaGFibGUoWydhbGwnXSwgX3hhbGwsIGZ1bmN0aW9uIGFsbChmbiwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcblxuICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICBpZiAoIWZuKGxpc3RbaWR4XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZHggKz0gMTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufSkpO1xuXG5leHBvcnQgZGVmYXVsdCBhbGw7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBsYXJnZXIgb2YgaXRzIHR3byBhcmd1bWVudHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IGFcbiAqIEBwYXJhbSB7Kn0gYVxuICogQHBhcmFtIHsqfSBiXG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLm1heEJ5LCBSLm1pblxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWF4KDc4OSwgMTIzKTsgLy89PiA3ODlcbiAqICAgICAgUi5tYXgoJ2EnLCAnYicpOyAvLz0+ICdiJ1xuICovXG5cbnZhciBtYXggPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBtYXgoYSwgYikge1xuICByZXR1cm4gYiA+IGEgPyBiIDogYTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtYXg7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX21hcChmbiwgZnVuY3Rvcikge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGZ1bmN0b3IubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuKTtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgcmVzdWx0W2lkeF0gPSBmbihmdW5jdG9yW2lkeF0pO1xuICAgIGlkeCArPSAxO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXNTdHJpbmcoeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBTdHJpbmddJztcbn0iLCJpbXBvcnQgX2N1cnJ5MSBmcm9tIFwiLi9fY3VycnkxLmpzXCI7XG5pbXBvcnQgX2lzQXJyYXkgZnJvbSBcIi4vX2lzQXJyYXkuanNcIjtcbmltcG9ydCBfaXNTdHJpbmcgZnJvbSBcIi4vX2lzU3RyaW5nLmpzXCI7XG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBpcyBzaW1pbGFyIHRvIGFuIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY2F0ZWdvcnkgVHlwZVxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKiAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IHggVGhlIG9iamVjdCB0byB0ZXN0LlxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB4YCBoYXMgYSBudW1lcmljIGxlbmd0aCBwcm9wZXJ0eSBhbmQgZXh0cmVtZSBpbmRpY2VzIGRlZmluZWQ7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIF9pc0FycmF5TGlrZShbXSk7IC8vPT4gdHJ1ZVxuICogICAgICBfaXNBcnJheUxpa2UodHJ1ZSk7IC8vPT4gZmFsc2VcbiAqICAgICAgX2lzQXJyYXlMaWtlKHt9KTsgLy89PiBmYWxzZVxuICogICAgICBfaXNBcnJheUxpa2Uoe2xlbmd0aDogMTB9KTsgLy89PiBmYWxzZVxuICogICAgICBfaXNBcnJheUxpa2UoezA6ICd6ZXJvJywgOTogJ25pbmUnLCBsZW5ndGg6IDEwfSk7IC8vPT4gdHJ1ZVxuICovXG5cbnZhciBfaXNBcnJheUxpa2UgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiBpc0FycmF5TGlrZSh4KSB7XG4gIGlmIChfaXNBcnJheSh4KSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKCF4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChfaXNTdHJpbmcoeCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoeC5ub2RlVHlwZSA9PT0gMSkge1xuICAgIHJldHVybiAhIXgubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoeC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHguaGFzT3duUHJvcGVydHkoMCkgJiYgeC5oYXNPd25Qcm9wZXJ0eSh4Lmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IF9pc0FycmF5TGlrZTsiLCJ2YXIgWFdyYXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYV3JhcChmbikge1xuICAgIHRoaXMuZiA9IGZuO1xuICB9XG5cbiAgWFdyYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaW5pdCBub3QgaW1wbGVtZW50ZWQgb24gWFdyYXAnKTtcbiAgfTtcblxuICBYV3JhcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChhY2MpIHtcbiAgICByZXR1cm4gYWNjO1xuICB9O1xuXG4gIFhXcmFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChhY2MsIHgpIHtcbiAgICByZXR1cm4gdGhpcy5mKGFjYywgeCk7XG4gIH07XG5cbiAgcmV0dXJuIFhXcmFwO1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfeHdyYXAoZm4pIHtcbiAgcmV0dXJuIG5ldyBYV3JhcChmbik7XG59IiwiaW1wb3J0IF9hcml0eSBmcm9tIFwiLi9pbnRlcm5hbC9fYXJpdHkuanNcIjtcbmltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgYm91bmQgdG8gYSBjb250ZXh0LlxuICogTm90ZTogYFIuYmluZGAgZG9lcyBub3QgcHJvdmlkZSB0aGUgYWRkaXRpb25hbCBhcmd1bWVudC1iaW5kaW5nIGNhcGFiaWxpdGllcyBvZlxuICogW0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9iaW5kKS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC42LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyAoKiAtPiAqKSAtPiB7Kn0gLT4gKCogLT4gKilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBiaW5kIHRvIGNvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzT2JqIFRoZSBjb250ZXh0IHRvIGJpbmQgYGZuYCB0b1xuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB3aWxsIGV4ZWN1dGUgaW4gdGhlIGNvbnRleHQgb2YgYHRoaXNPYmpgLlxuICogQHNlZSBSLnBhcnRpYWxcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBsb2cgPSBSLmJpbmQoY29uc29sZS5sb2csIGNvbnNvbGUpO1xuICogICAgICBSLnBpcGUoUi5hc3NvYygnYScsIDIpLCBSLnRhcChsb2cpLCBSLmFzc29jKCdhJywgMykpKHthOiAxfSk7IC8vPT4ge2E6IDN9XG4gKiAgICAgIC8vIGxvZ3Mge2E6IDJ9XG4gKiBAc3ltYiBSLmJpbmQoZiwgbykoYSwgYikgPSBmLmNhbGwobywgYSwgYilcbiAqL1xuXG52YXIgYmluZCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNPYmopIHtcbiAgcmV0dXJuIF9hcml0eShmbi5sZW5ndGgsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc09iaiwgYXJndW1lbnRzKTtcbiAgfSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYmluZDsiLCJpbXBvcnQgX2lzQXJyYXlMaWtlIGZyb20gXCIuL19pc0FycmF5TGlrZS5qc1wiO1xuaW1wb3J0IF94d3JhcCBmcm9tIFwiLi9feHdyYXAuanNcIjtcbmltcG9ydCBiaW5kIGZyb20gXCIuLi9iaW5kLmpzXCI7XG5cbmZ1bmN0aW9uIF9hcnJheVJlZHVjZSh4ZiwgYWNjLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGFjYyA9IHhmWydAQHRyYW5zZHVjZXIvc3RlcCddKGFjYywgbGlzdFtpZHhdKTtcblxuICAgIGlmIChhY2MgJiYgYWNjWydAQHRyYW5zZHVjZXIvcmVkdWNlZCddKSB7XG4gICAgICBhY2MgPSBhY2NbJ0BAdHJhbnNkdWNlci92YWx1ZSddO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4geGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShhY2MpO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVSZWR1Y2UoeGYsIGFjYywgaXRlcikge1xuICB2YXIgc3RlcCA9IGl0ZXIubmV4dCgpO1xuXG4gIHdoaWxlICghc3RlcC5kb25lKSB7XG4gICAgYWNjID0geGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10oYWNjLCBzdGVwLnZhbHVlKTtcblxuICAgIGlmIChhY2MgJiYgYWNjWydAQHRyYW5zZHVjZXIvcmVkdWNlZCddKSB7XG4gICAgICBhY2MgPSBhY2NbJ0BAdHJhbnNkdWNlci92YWx1ZSddO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgc3RlcCA9IGl0ZXIubmV4dCgpO1xuICB9XG5cbiAgcmV0dXJuIHhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10oYWNjKTtcbn1cblxuZnVuY3Rpb24gX21ldGhvZFJlZHVjZSh4ZiwgYWNjLCBvYmosIG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIHhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ob2JqW21ldGhvZE5hbWVdKGJpbmQoeGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10sIHhmKSwgYWNjKSk7XG59XG5cbnZhciBzeW1JdGVyYXRvciA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sLml0ZXJhdG9yIDogJ0BAaXRlcmF0b3InO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3JlZHVjZShmbiwgYWNjLCBsaXN0KSB7XG4gIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICBmbiA9IF94d3JhcChmbik7XG4gIH1cblxuICBpZiAoX2lzQXJyYXlMaWtlKGxpc3QpKSB7XG4gICAgcmV0dXJuIF9hcnJheVJlZHVjZShmbiwgYWNjLCBsaXN0KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbGlzdFsnZmFudGFzeS1sYW5kL3JlZHVjZSddID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIF9tZXRob2RSZWR1Y2UoZm4sIGFjYywgbGlzdCwgJ2ZhbnRhc3ktbGFuZC9yZWR1Y2UnKTtcbiAgfVxuXG4gIGlmIChsaXN0W3N5bUl0ZXJhdG9yXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIF9pdGVyYWJsZVJlZHVjZShmbiwgYWNjLCBsaXN0W3N5bUl0ZXJhdG9yXSgpKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbGlzdC5uZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIF9pdGVyYWJsZVJlZHVjZShmbiwgYWNjLCBsaXN0KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbGlzdC5yZWR1Y2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gX21ldGhvZFJlZHVjZShmbiwgYWNjLCBsaXN0LCAncmVkdWNlJyk7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWR1Y2U6IGxpc3QgbXVzdCBiZSBhcnJheSBvciBpdGVyYWJsZScpO1xufSIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL19jdXJyeTIuanNcIjtcbmltcG9ydCBfeGZCYXNlIGZyb20gXCIuL194ZkJhc2UuanNcIjtcblxudmFyIFhNYXAgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYTWFwKGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gIH1cblxuICBYTWFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWE1hcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuXG4gIFhNYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRoaXMuZihpbnB1dCkpO1xuICB9O1xuXG4gIHJldHVybiBYTWFwO1xufSgpO1xuXG52YXIgX3htYXAgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBfeG1hcChmLCB4Zikge1xuICByZXR1cm4gbmV3IFhNYXAoZiwgeGYpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IF94bWFwOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9oYXMocHJvcCwgb2JqKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn0iLCJpbXBvcnQgX2hhcyBmcm9tIFwiLi9faGFzLmpzXCI7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG52YXIgX2lzQXJndW1lbnRzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXScgPyBmdW5jdGlvbiBfaXNBcmd1bWVudHMoeCkge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbiAgfSA6IGZ1bmN0aW9uIF9pc0FyZ3VtZW50cyh4KSB7XG4gICAgcmV0dXJuIF9oYXMoJ2NhbGxlZScsIHgpO1xuICB9O1xufSgpO1xuXG5leHBvcnQgZGVmYXVsdCBfaXNBcmd1bWVudHM7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5MS5qc1wiO1xuaW1wb3J0IF9oYXMgZnJvbSBcIi4vaW50ZXJuYWwvX2hhcy5qc1wiO1xuaW1wb3J0IF9pc0FyZ3VtZW50cyBmcm9tIFwiLi9pbnRlcm5hbC9faXNBcmd1bWVudHMuanNcIjsgLy8gY292ZXIgSUUgPCA5IGtleXMgaXNzdWVzXG5cbnZhciBoYXNFbnVtQnVnID0gIVxuLyojX19QVVJFX18qL1xue1xuICB0b1N0cmluZzogbnVsbFxufS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgndG9TdHJpbmcnKTtcbnZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ2NvbnN0cnVjdG9yJywgJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddOyAvLyBTYWZhcmkgYnVnXG5cbnZhciBoYXNBcmdzRW51bUJ1ZyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICByZXR1cm4gYXJndW1lbnRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKCdsZW5ndGgnKTtcbn0oKTtcblxudmFyIGNvbnRhaW5zID0gZnVuY3Rpb24gY29udGFpbnMobGlzdCwgaXRlbSkge1xuICB2YXIgaWR4ID0gMDtcblxuICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICBpZiAobGlzdFtpZHhdID09PSBpdGVtKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZHggKz0gMTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIFJldHVybnMgYSBsaXN0IGNvbnRhaW5pbmcgdGhlIG5hbWVzIG9mIGFsbCB0aGUgZW51bWVyYWJsZSBvd24gcHJvcGVydGllcyBvZlxuICogdGhlIHN1cHBsaWVkIG9iamVjdC5cbiAqIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIG91dHB1dCBhcnJheSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBjb25zaXN0ZW50XG4gKiBhY3Jvc3MgZGlmZmVyZW50IEpTIHBsYXRmb3Jtcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcge2s6IHZ9IC0+IFtrXVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGV4dHJhY3QgcHJvcGVydGllcyBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdGhlIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICogQHNlZSBSLmtleXNJbiwgUi52YWx1ZXNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmtleXMoe2E6IDEsIGI6IDIsIGM6IDN9KTsgLy89PiBbJ2EnLCAnYicsICdjJ11cbiAqL1xuXG5cbnZhciBrZXlzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nICYmICFoYXNBcmdzRW51bUJ1ZyA/XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKGZ1bmN0aW9uIGtleXMob2JqKSB7XG4gIHJldHVybiBPYmplY3Qob2JqKSAhPT0gb2JqID8gW10gOiBPYmplY3Qua2V5cyhvYmopO1xufSkgOlxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiBrZXlzKG9iaikge1xuICBpZiAoT2JqZWN0KG9iaikgIT09IG9iaikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBwcm9wLCBuSWR4O1xuICB2YXIga3MgPSBbXTtcblxuICB2YXIgY2hlY2tBcmdzTGVuZ3RoID0gaGFzQXJnc0VudW1CdWcgJiYgX2lzQXJndW1lbnRzKG9iaik7XG5cbiAgZm9yIChwcm9wIGluIG9iaikge1xuICAgIGlmIChfaGFzKHByb3AsIG9iaikgJiYgKCFjaGVja0FyZ3NMZW5ndGggfHwgcHJvcCAhPT0gJ2xlbmd0aCcpKSB7XG4gICAgICBrc1trcy5sZW5ndGhdID0gcHJvcDtcbiAgICB9XG4gIH1cblxuICBpZiAoaGFzRW51bUJ1Zykge1xuICAgIG5JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoIC0gMTtcblxuICAgIHdoaWxlIChuSWR4ID49IDApIHtcbiAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbklkeF07XG5cbiAgICAgIGlmIChfaGFzKHByb3AsIG9iaikgJiYgIWNvbnRhaW5zKGtzLCBwcm9wKSkge1xuICAgICAgICBrc1trcy5sZW5ndGhdID0gcHJvcDtcbiAgICAgIH1cblxuICAgICAgbklkeCAtPSAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBrcztcbn0pO1xuZXhwb3J0IGRlZmF1bHQga2V5czsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgX2Rpc3BhdGNoYWJsZSBmcm9tIFwiLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlLmpzXCI7XG5pbXBvcnQgX21hcCBmcm9tIFwiLi9pbnRlcm5hbC9fbWFwLmpzXCI7XG5pbXBvcnQgX3JlZHVjZSBmcm9tIFwiLi9pbnRlcm5hbC9fcmVkdWNlLmpzXCI7XG5pbXBvcnQgX3htYXAgZnJvbSBcIi4vaW50ZXJuYWwvX3htYXAuanNcIjtcbmltcG9ydCBjdXJyeU4gZnJvbSBcIi4vY3VycnlOLmpzXCI7XG5pbXBvcnQga2V5cyBmcm9tIFwiLi9rZXlzLmpzXCI7XG4vKipcbiAqIFRha2VzIGEgZnVuY3Rpb24gYW5kXG4gKiBhIFtmdW5jdG9yXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2Z1bmN0b3IpLFxuICogYXBwbGllcyB0aGUgZnVuY3Rpb24gdG8gZWFjaCBvZiB0aGUgZnVuY3RvcidzIHZhbHVlcywgYW5kIHJldHVybnNcbiAqIGEgZnVuY3RvciBvZiB0aGUgc2FtZSBzaGFwZS5cbiAqXG4gKiBSYW1kYSBwcm92aWRlcyBzdWl0YWJsZSBgbWFwYCBpbXBsZW1lbnRhdGlvbnMgZm9yIGBBcnJheWAgYW5kIGBPYmplY3RgLFxuICogc28gdGhpcyBmdW5jdGlvbiBtYXkgYmUgYXBwbGllZCB0byBgWzEsIDIsIDNdYCBvciBge3g6IDEsIHk6IDIsIHo6IDN9YC5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgbWFwYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQWxzbyB0cmVhdHMgZnVuY3Rpb25zIGFzIGZ1bmN0b3JzIGFuZCB3aWxsIGNvbXBvc2UgdGhlbSB0b2dldGhlci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIEZ1bmN0b3IgZiA9PiAoYSAtPiBiKSAtPiBmIGEgLT4gZiBiXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhlIGlucHV0IGBsaXN0YC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gYmUgaXRlcmF0ZWQgb3Zlci5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbmV3IGxpc3QuXG4gKiBAc2VlIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgZG91YmxlID0geCA9PiB4ICogMjtcbiAqXG4gKiAgICAgIFIubWFwKGRvdWJsZSwgWzEsIDIsIDNdKTsgLy89PiBbMiwgNCwgNl1cbiAqXG4gKiAgICAgIFIubWFwKGRvdWJsZSwge3g6IDEsIHk6IDIsIHo6IDN9KTsgLy89PiB7eDogMiwgeTogNCwgejogNn1cbiAqIEBzeW1iIFIubWFwKGYsIFthLCBiXSkgPSBbZihhKSwgZihiKV1cbiAqIEBzeW1iIFIubWFwKGYsIHsgeDogYSwgeTogYiB9KSA9IHsgeDogZihhKSwgeTogZihiKSB9XG4gKiBAc3ltYiBSLm1hcChmLCBmdW5jdG9yX28pID0gZnVuY3Rvcl9vLm1hcChmKVxuICovXG5cbnZhciBtYXAgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5Mihcbi8qI19fUFVSRV9fKi9cbl9kaXNwYXRjaGFibGUoWydmYW50YXN5LWxhbmQvbWFwJywgJ21hcCddLCBfeG1hcCwgZnVuY3Rpb24gbWFwKGZuLCBmdW5jdG9yKSB7XG4gIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0b3IpKSB7XG4gICAgY2FzZSAnW29iamVjdCBGdW5jdGlvbl0nOlxuICAgICAgcmV0dXJuIGN1cnJ5TihmdW5jdG9yLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBmdW5jdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgICAgfSk7XG5cbiAgICBjYXNlICdbb2JqZWN0IE9iamVjdF0nOlxuICAgICAgcmV0dXJuIF9yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICAgIGFjY1trZXldID0gZm4oZnVuY3RvcltrZXldKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9LCBrZXlzKGZ1bmN0b3IpKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gX21hcChmbiwgZnVuY3Rvcik7XG4gIH1cbn0pKTtcblxuZXhwb3J0IGRlZmF1bHQgbWFwOyIsIi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBwYXNzZWQgYXJndW1lbnQgaXMgYW4gaW50ZWdlci5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBuXG4gKiBAY2F0ZWdvcnkgVHlwZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbiBfaXNJbnRlZ2VyKG4pIHtcbiAgcmV0dXJuIG4gPDwgMCA9PT0gbjtcbn07IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9pc1N0cmluZyBmcm9tIFwiLi9pbnRlcm5hbC9faXNTdHJpbmcuanNcIjtcbi8qKlxuICogUmV0dXJucyB0aGUgbnRoIGVsZW1lbnQgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nLiBJZiBuIGlzIG5lZ2F0aXZlIHRoZVxuICogZWxlbWVudCBhdCBpbmRleCBsZW5ndGggKyBuIGlzIHJldHVybmVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBhIHwgVW5kZWZpbmVkXG4gKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0geyp9IGxpc3RcbiAqIEByZXR1cm4geyp9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgbGlzdCA9IFsnZm9vJywgJ2JhcicsICdiYXonLCAncXV1eCddO1xuICogICAgICBSLm50aCgxLCBsaXN0KTsgLy89PiAnYmFyJ1xuICogICAgICBSLm50aCgtMSwgbGlzdCk7IC8vPT4gJ3F1dXgnXG4gKiAgICAgIFIubnRoKC05OSwgbGlzdCk7IC8vPT4gdW5kZWZpbmVkXG4gKlxuICogICAgICBSLm50aCgyLCAnYWJjJyk7IC8vPT4gJ2MnXG4gKiAgICAgIFIubnRoKDMsICdhYmMnKTsgLy89PiAnJ1xuICogQHN5bWIgUi5udGgoLTEsIFthLCBiLCBjXSkgPSBjXG4gKiBAc3ltYiBSLm50aCgwLCBbYSwgYiwgY10pID0gYVxuICogQHN5bWIgUi5udGgoMSwgW2EsIGIsIGNdKSA9IGJcbiAqL1xuXG52YXIgbnRoID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gbnRoKG9mZnNldCwgbGlzdCkge1xuICB2YXIgaWR4ID0gb2Zmc2V0IDwgMCA/IGxpc3QubGVuZ3RoICsgb2Zmc2V0IDogb2Zmc2V0O1xuICByZXR1cm4gX2lzU3RyaW5nKGxpc3QpID8gbGlzdC5jaGFyQXQoaWR4KSA6IGxpc3RbaWR4XTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBudGg7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9pc0ludGVnZXIgZnJvbSBcIi4vaW50ZXJuYWwvX2lzSW50ZWdlci5qc1wiO1xuaW1wb3J0IG50aCBmcm9tIFwiLi9udGguanNcIjtcbi8qKlxuICogUmV0cmlldmVzIHRoZSB2YWx1ZXMgYXQgZ2l2ZW4gcGF0aHMgb2YgYW4gb2JqZWN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjI3LjFcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEB0eXBlZGVmbiBJZHggPSBbU3RyaW5nIHwgSW50XVxuICogQHNpZyBbSWR4XSAtPiB7YX0gLT4gW2EgfCBVbmRlZmluZWRdXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoc0FycmF5IFRoZSBhcnJheSBvZiBwYXRocyB0byBiZSBmZXRjaGVkLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHJldHJpZXZlIHRoZSBuZXN0ZWQgcHJvcGVydGllcyBmcm9tLlxuICogQHJldHVybiB7QXJyYXl9IEEgbGlzdCBjb25zaXN0aW5nIG9mIHZhbHVlcyBhdCBwYXRocyBzcGVjaWZpZWQgYnkgXCJwYXRoc0FycmF5XCIuXG4gKiBAc2VlIFIucGF0aFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucGF0aHMoW1snYScsICdiJ10sIFsncCcsIDAsICdxJ11dLCB7YToge2I6IDJ9LCBwOiBbe3E6IDN9XX0pOyAvLz0+IFsyLCAzXVxuICogICAgICBSLnBhdGhzKFtbJ2EnLCAnYiddLCBbJ3AnLCAnciddXSwge2E6IHtiOiAyfSwgcDogW3txOiAzfV19KTsgLy89PiBbMiwgdW5kZWZpbmVkXVxuICovXG5cbnZhciBwYXRocyA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIHBhdGhzKHBhdGhzQXJyYXksIG9iaikge1xuICByZXR1cm4gcGF0aHNBcnJheS5tYXAoZnVuY3Rpb24gKHBhdGhzKSB7XG4gICAgdmFyIHZhbCA9IG9iajtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB2YXIgcDtcblxuICAgIHdoaWxlIChpZHggPCBwYXRocy5sZW5ndGgpIHtcbiAgICAgIGlmICh2YWwgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHAgPSBwYXRoc1tpZHhdO1xuICAgICAgdmFsID0gX2lzSW50ZWdlcihwKSA/IG50aChwLCB2YWwpIDogdmFsW3BdO1xuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcGF0aHM7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IHBhdGhzIGZyb20gXCIuL3BhdGhzLmpzXCI7XG4vKipcbiAqIFJldHJpZXZlIHRoZSB2YWx1ZSBhdCBhIGdpdmVuIHBhdGguXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMi4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gSWR4ID0gU3RyaW5nIHwgSW50XG4gKiBAc2lnIFtJZHhdIC0+IHthfSAtPiBhIHwgVW5kZWZpbmVkXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIHVzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byByZXRyaWV2ZSB0aGUgbmVzdGVkIHByb3BlcnR5IGZyb20uXG4gKiBAcmV0dXJuIHsqfSBUaGUgZGF0YSBhdCBgcGF0aGAuXG4gKiBAc2VlIFIucHJvcCwgUi5udGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnBhdGgoWydhJywgJ2InXSwge2E6IHtiOiAyfX0pOyAvLz0+IDJcbiAqICAgICAgUi5wYXRoKFsnYScsICdiJ10sIHtjOiB7YjogMn19KTsgLy89PiB1bmRlZmluZWRcbiAqICAgICAgUi5wYXRoKFsnYScsICdiJywgMF0sIHthOiB7YjogWzEsIDIsIDNdfX0pOyAvLz0+IDFcbiAqICAgICAgUi5wYXRoKFsnYScsICdiJywgLTJdLCB7YToge2I6IFsxLCAyLCAzXX19KTsgLy89PiAyXG4gKi9cblxudmFyIHBhdGggPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBwYXRoKHBhdGhBciwgb2JqKSB7XG4gIHJldHVybiBwYXRocyhbcGF0aEFyXSwgb2JqKVswXTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBwYXRoOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbmltcG9ydCBwYXRoIGZyb20gXCIuL3BhdGguanNcIjtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2hlbiBzdXBwbGllZCBhbiBvYmplY3QgcmV0dXJucyB0aGUgaW5kaWNhdGVkXG4gKiBwcm9wZXJ0eSBvZiB0aGF0IG9iamVjdCwgaWYgaXQgZXhpc3RzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHR5cGVkZWZuIElkeCA9IFN0cmluZyB8IEludFxuICogQHNpZyBJZHggLT4ge3M6IGF9IC0+IGEgfCBVbmRlZmluZWRcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gcCBUaGUgcHJvcGVydHkgbmFtZSBvciBhcnJheSBpbmRleFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHF1ZXJ5XG4gKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWUgYXQgYG9iai5wYC5cbiAqIEBzZWUgUi5wYXRoLCBSLm50aFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucHJvcCgneCcsIHt4OiAxMDB9KTsgLy89PiAxMDBcbiAqICAgICAgUi5wcm9wKCd4Jywge30pOyAvLz0+IHVuZGVmaW5lZFxuICogICAgICBSLnByb3AoMCwgWzEwMF0pOyAvLz0+IDEwMFxuICogICAgICBSLmNvbXBvc2UoUi5pbmMsIFIucHJvcCgneCcpKSh7IHg6IDMgfSkgLy89PiA0XG4gKi9cblxudmFyIHByb3AgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBwcm9wKHAsIG9iaikge1xuICByZXR1cm4gcGF0aChbcF0sIG9iaik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcHJvcDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgbWFwIGZyb20gXCIuL21hcC5qc1wiO1xuaW1wb3J0IHByb3AgZnJvbSBcIi4vcHJvcC5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3QgYnkgcGx1Y2tpbmcgdGhlIHNhbWUgbmFtZWQgcHJvcGVydHkgb2ZmIGFsbCBvYmplY3RzIGluXG4gKiB0aGUgbGlzdCBzdXBwbGllZC5cbiAqXG4gKiBgcGx1Y2tgIHdpbGwgd29yayBvblxuICogYW55IFtmdW5jdG9yXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2Z1bmN0b3IpIGluXG4gKiBhZGRpdGlvbiB0byBhcnJheXMsIGFzIGl0IGlzIGVxdWl2YWxlbnQgdG8gYFIubWFwKFIucHJvcChrKSwgZilgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgRnVuY3RvciBmID0+IGsgLT4gZiB7azogdn0gLT4gZiB2XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IGtleSBUaGUga2V5IG5hbWUgdG8gcGx1Y2sgb2ZmIG9mIGVhY2ggb2JqZWN0LlxuICogQHBhcmFtIHtBcnJheX0gZiBUaGUgYXJyYXkgb3IgZnVuY3RvciB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBrZXkuXG4gKiBAc2VlIFIucHJvcHNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICB2YXIgZ2V0QWdlcyA9IFIucGx1Y2soJ2FnZScpO1xuICogICAgICBnZXRBZ2VzKFt7bmFtZTogJ2ZyZWQnLCBhZ2U6IDI5fSwge25hbWU6ICd3aWxtYScsIGFnZTogMjd9XSk7IC8vPT4gWzI5LCAyN11cbiAqXG4gKiAgICAgIFIucGx1Y2soMCwgW1sxLCAyXSwgWzMsIDRdXSk7ICAgICAgICAgICAgICAgLy89PiBbMSwgM11cbiAqICAgICAgUi5wbHVjaygndmFsJywge2E6IHt2YWw6IDN9LCBiOiB7dmFsOiA1fX0pOyAvLz0+IHthOiAzLCBiOiA1fVxuICogQHN5bWIgUi5wbHVjaygneCcsIFt7eDogMSwgeTogMn0sIHt4OiAzLCB5OiA0fSwge3g6IDUsIHk6IDZ9XSkgPSBbMSwgMywgNV1cbiAqIEBzeW1iIFIucGx1Y2soMCwgW1sxLCAyXSwgWzMsIDRdLCBbNSwgNl1dKSA9IFsxLCAzLCA1XVxuICovXG5cbnZhciBwbHVjayA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIHBsdWNrKHAsIGxpc3QpIHtcbiAgcmV0dXJuIG1hcChwcm9wKHApLCBsaXN0KTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBwbHVjazsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkzLmpzXCI7XG5pbXBvcnQgX3JlZHVjZSBmcm9tIFwiLi9pbnRlcm5hbC9fcmVkdWNlLmpzXCI7XG4vKipcbiAqIFJldHVybnMgYSBzaW5nbGUgaXRlbSBieSBpdGVyYXRpbmcgdGhyb3VnaCB0aGUgbGlzdCwgc3VjY2Vzc2l2ZWx5IGNhbGxpbmdcbiAqIHRoZSBpdGVyYXRvciBmdW5jdGlvbiBhbmQgcGFzc2luZyBpdCBhbiBhY2N1bXVsYXRvciB2YWx1ZSBhbmQgdGhlIGN1cnJlbnRcbiAqIHZhbHVlIGZyb20gdGhlIGFycmF5LCBhbmQgdGhlbiBwYXNzaW5nIHRoZSByZXN1bHQgdG8gdGhlIG5leHQgY2FsbC5cbiAqXG4gKiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIHZhbHVlczogKihhY2MsIHZhbHVlKSouIEl0IG1heSB1c2VcbiAqIFtgUi5yZWR1Y2VkYF0oI3JlZHVjZWQpIHRvIHNob3J0Y3V0IHRoZSBpdGVyYXRpb24uXG4gKlxuICogVGhlIGFyZ3VtZW50cycgb3JkZXIgb2YgW2ByZWR1Y2VSaWdodGBdKCNyZWR1Y2VSaWdodCkncyBpdGVyYXRvciBmdW5jdGlvblxuICogaXMgKih2YWx1ZSwgYWNjKSouXG4gKlxuICogTm90ZTogYFIucmVkdWNlYCBkb2VzIG5vdCBza2lwIGRlbGV0ZWQgb3IgdW5hc3NpZ25lZCBpbmRpY2VzIChzcGFyc2VcbiAqIGFycmF5cyksIHVubGlrZSB0aGUgbmF0aXZlIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2QuIEZvciBtb3JlIGRldGFpbHNcbiAqIG9uIHRoaXMgYmVoYXZpb3IsIHNlZTpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3JlZHVjZSNEZXNjcmlwdGlvblxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGByZWR1Y2VgIG1ldGhvZCBvZiB0aGUgdGhpcmQgYXJndW1lbnQsIGlmIHByZXNlbnQuIFdoZW5cbiAqIGRvaW5nIHNvLCBpdCBpcyB1cCB0byB0aGUgdXNlciB0byBoYW5kbGUgdGhlIFtgUi5yZWR1Y2VkYF0oI3JlZHVjZWQpXG4gKiBzaG9ydGN1dGluZywgYXMgdGhpcyBpcyBub3QgaW1wbGVtZW50ZWQgYnkgYHJlZHVjZWAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoKGEsIGIpIC0+IGEpIC0+IGEgLT4gW2JdIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgdGhlIGFjY3VtdWxhdG9yIGFuZCB0aGVcbiAqICAgICAgICBjdXJyZW50IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXkuXG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIFIucmVkdWNlZCwgUi5hZGRJbmRleCwgUi5yZWR1Y2VSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucmVkdWNlKFIuc3VidHJhY3QsIDAsIFsxLCAyLCAzLCA0XSkgLy8gPT4gKCgoKDAgLSAxKSAtIDIpIC0gMykgLSA0KSA9IC0xMFxuICogICAgICAvLyAgICAgICAgICAtICAgICAgICAgICAgICAgLTEwXG4gKiAgICAgIC8vICAgICAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAvLyAgICAgICAgLSAgIDQgICAgICAgICAgIC02ICAgNFxuICogICAgICAvLyAgICAgICAvIFxcICAgICAgICAgICAgICAvIFxcXG4gKiAgICAgIC8vICAgICAgLSAgIDMgICA9PT4gICAgIC0zICAgM1xuICogICAgICAvLyAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAvLyAgICAtICAgMiAgICAgICAgICAgLTEgICAyXG4gKiAgICAgIC8vICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAvLyAgMCAgIDEgICAgICAgICAgICAwICAgMVxuICpcbiAqIEBzeW1iIFIucmVkdWNlKGYsIGEsIFtiLCBjLCBkXSkgPSBmKGYoZihhLCBiKSwgYyksIGQpXG4gKi9cblxudmFyIHJlZHVjZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKF9yZWR1Y2UpO1xuXG5leHBvcnQgZGVmYXVsdCByZWR1Y2U7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5MS5qc1wiO1xuaW1wb3J0IGN1cnJ5TiBmcm9tIFwiLi9jdXJyeU4uanNcIjtcbmltcG9ydCBtYXggZnJvbSBcIi4vbWF4LmpzXCI7XG5pbXBvcnQgcGx1Y2sgZnJvbSBcIi4vcGx1Y2suanNcIjtcbmltcG9ydCByZWR1Y2UgZnJvbSBcIi4vcmVkdWNlLmpzXCI7XG4vKipcbiAqIFRha2VzIGEgbGlzdCBvZiBwcmVkaWNhdGVzIGFuZCByZXR1cm5zIGEgcHJlZGljYXRlIHRoYXQgcmV0dXJucyB0cnVlIGZvciBhXG4gKiBnaXZlbiBsaXN0IG9mIGFyZ3VtZW50cyBpZiBldmVyeSBvbmUgb2YgdGhlIHByb3ZpZGVkIHByZWRpY2F0ZXMgaXMgc2F0aXNmaWVkXG4gKiBieSB0aG9zZSBhcmd1bWVudHMuXG4gKlxuICogVGhlIGZ1bmN0aW9uIHJldHVybmVkIGlzIGEgY3VycmllZCBmdW5jdGlvbiB3aG9zZSBhcml0eSBtYXRjaGVzIHRoYXQgb2YgdGhlXG4gKiBoaWdoZXN0LWFyaXR5IHByZWRpY2F0ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyBbKCouLi4gLT4gQm9vbGVhbildIC0+ICgqLi4uIC0+IEJvb2xlYW4pXG4gKiBAcGFyYW0ge0FycmF5fSBwcmVkaWNhdGVzIEFuIGFycmF5IG9mIHByZWRpY2F0ZXMgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgY29tYmluZWQgcHJlZGljYXRlXG4gKiBAc2VlIFIuYW55UGFzc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGlzUXVlZW4gPSBSLnByb3BFcSgncmFuaycsICdRJyk7XG4gKiAgICAgIGNvbnN0IGlzU3BhZGUgPSBSLnByb3BFcSgnc3VpdCcsICfimaDvuI4nKTtcbiAqICAgICAgY29uc3QgaXNRdWVlbk9mU3BhZGVzID0gUi5hbGxQYXNzKFtpc1F1ZWVuLCBpc1NwYWRlXSk7XG4gKlxuICogICAgICBpc1F1ZWVuT2ZTcGFkZXMoe3Jhbms6ICdRJywgc3VpdDogJ+KZo++4jid9KTsgLy89PiBmYWxzZVxuICogICAgICBpc1F1ZWVuT2ZTcGFkZXMoe3Jhbms6ICdRJywgc3VpdDogJ+KZoO+4jid9KTsgLy89PiB0cnVlXG4gKi9cblxudmFyIGFsbFBhc3MgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiBhbGxQYXNzKHByZWRzKSB7XG4gIHJldHVybiBjdXJyeU4ocmVkdWNlKG1heCwgMCwgcGx1Y2soJ2xlbmd0aCcsIHByZWRzKSksIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB2YXIgbGVuID0gcHJlZHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgaWYgKCFwcmVkc1tpZHhdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZHggKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYWxsUGFzczsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkxLmpzXCI7XG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFsd2F5cyByZXR1cm5zIHRoZSBnaXZlbiB2YWx1ZS4gTm90ZSB0aGF0IGZvclxuICogbm9uLXByaW1pdGl2ZXMgdGhlIHZhbHVlIHJldHVybmVkIGlzIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGtub3duIGFzIGBjb25zdGAsIGBjb25zdGFudGAsIG9yIGBLYCAoZm9yIEsgY29tYmluYXRvcikgaW5cbiAqIG90aGVyIGxhbmd1YWdlcyBhbmQgbGlicmFyaWVzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIGEgLT4gKCogLT4gYSlcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB3cmFwIGluIGEgZnVuY3Rpb25cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIEZ1bmN0aW9uIDo6ICogLT4gdmFsLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IHQgPSBSLmFsd2F5cygnVGVlJyk7XG4gKiAgICAgIHQoKTsgLy89PiAnVGVlJ1xuICovXG5cbnZhciBhbHdheXMgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiBhbHdheXModmFsKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBhbHdheXM7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGFyZ3VtZW50cyBhcmUgYHRydWVgOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyBhIC0+IGIgLT4gYSB8IGJcbiAqIEBwYXJhbSB7QW55fSBhXG4gKiBAcGFyYW0ge0FueX0gYlxuICogQHJldHVybiB7QW55fSB0aGUgZmlyc3QgYXJndW1lbnQgaWYgaXQgaXMgZmFsc3ksIG90aGVyd2lzZSB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICogQHNlZSBSLmJvdGgsIFIueG9yXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5hbmQodHJ1ZSwgdHJ1ZSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmFuZCh0cnVlLCBmYWxzZSk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5hbmQoZmFsc2UsIHRydWUpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuYW5kKGZhbHNlLCBmYWxzZSk7IC8vPT4gZmFsc2VcbiAqL1xuXG52YXIgYW5kID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gYW5kKGEsIGIpIHtcbiAgcmV0dXJuIGEgJiYgYjtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBhbmQ7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9yZWR1Y2VkIGZyb20gXCIuL19yZWR1Y2VkLmpzXCI7XG5pbXBvcnQgX3hmQmFzZSBmcm9tIFwiLi9feGZCYXNlLmpzXCI7XG5cbnZhciBYQW55ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWEFueShmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHRoaXMuYW55ID0gZmFsc2U7XG4gIH1cblxuICBYQW55LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcblxuICBYQW55LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGlmICghdGhpcy5hbnkpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9O1xuXG4gIFhBbnkucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICBpZiAodGhpcy5mKGlucHV0KSkge1xuICAgICAgdGhpcy5hbnkgPSB0cnVlO1xuICAgICAgcmVzdWx0ID0gX3JlZHVjZWQodGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRydWUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBYQW55O1xufSgpO1xuXG52YXIgX3hhbnkgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBfeGFueShmLCB4Zikge1xuICByZXR1cm4gbmV3IFhBbnkoZiwgeGYpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IF94YW55OyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gXCIuL2ludGVybmFsL19kaXNwYXRjaGFibGUuanNcIjtcbmltcG9ydCBfeGFueSBmcm9tIFwiLi9pbnRlcm5hbC9feGFueS5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlIGVsZW1lbnRzIG9mIHRoZSBsaXN0IG1hdGNoIHRoZSBwcmVkaWNhdGUsXG4gKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgYW55YCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gQm9vbGVhblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBwcmVkaWNhdGUgaXMgc2F0aXNmaWVkIGJ5IGF0IGxlYXN0IG9uZSBlbGVtZW50LCBgZmFsc2VgXG4gKiAgICAgICAgIG90aGVyd2lzZS5cbiAqIEBzZWUgUi5hbGwsIFIubm9uZSwgUi50cmFuc2R1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBsZXNzVGhhbjAgPSBSLmZsaXAoUi5sdCkoMCk7XG4gKiAgICAgIGNvbnN0IGxlc3NUaGFuMiA9IFIuZmxpcChSLmx0KSgyKTtcbiAqICAgICAgUi5hbnkobGVzc1RoYW4wKShbMSwgMl0pOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuYW55KGxlc3NUaGFuMikoWzEsIDJdKTsgLy89PiB0cnVlXG4gKi9cblxudmFyIGFueSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKFxuLyojX19QVVJFX18qL1xuX2Rpc3BhdGNoYWJsZShbJ2FueSddLCBfeGFueSwgZnVuY3Rpb24gYW55KGZuLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuXG4gIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgIGlmIChmbihsaXN0W2lkeF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZHggKz0gMTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn0pKTtcblxuZXhwb3J0IGRlZmF1bHQgYW55OyIsImltcG9ydCBfY3VycnkxIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTEuanNcIjtcbmltcG9ydCBjdXJyeU4gZnJvbSBcIi4vY3VycnlOLmpzXCI7XG5pbXBvcnQgbWF4IGZyb20gXCIuL21heC5qc1wiO1xuaW1wb3J0IHBsdWNrIGZyb20gXCIuL3BsdWNrLmpzXCI7XG5pbXBvcnQgcmVkdWNlIGZyb20gXCIuL3JlZHVjZS5qc1wiO1xuLyoqXG4gKiBUYWtlcyBhIGxpc3Qgb2YgcHJlZGljYXRlcyBhbmQgcmV0dXJucyBhIHByZWRpY2F0ZSB0aGF0IHJldHVybnMgdHJ1ZSBmb3IgYVxuICogZ2l2ZW4gbGlzdCBvZiBhcmd1bWVudHMgaWYgYXQgbGVhc3Qgb25lIG9mIHRoZSBwcm92aWRlZCBwcmVkaWNhdGVzIGlzXG4gKiBzYXRpc2ZpZWQgYnkgdGhvc2UgYXJndW1lbnRzLlxuICpcbiAqIFRoZSBmdW5jdGlvbiByZXR1cm5lZCBpcyBhIGN1cnJpZWQgZnVuY3Rpb24gd2hvc2UgYXJpdHkgbWF0Y2hlcyB0aGF0IG9mIHRoZVxuICogaGlnaGVzdC1hcml0eSBwcmVkaWNhdGUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgWygqLi4uIC0+IEJvb2xlYW4pXSAtPiAoKi4uLiAtPiBCb29sZWFuKVxuICogQHBhcmFtIHtBcnJheX0gcHJlZGljYXRlcyBBbiBhcnJheSBvZiBwcmVkaWNhdGVzIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGNvbWJpbmVkIHByZWRpY2F0ZVxuICogQHNlZSBSLmFsbFBhc3NcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBpc0NsdWIgPSBSLnByb3BFcSgnc3VpdCcsICfimaMnKTtcbiAqICAgICAgY29uc3QgaXNTcGFkZSA9IFIucHJvcEVxKCdzdWl0JywgJ+KZoCcpO1xuICogICAgICBjb25zdCBpc0JsYWNrQ2FyZCA9IFIuYW55UGFzcyhbaXNDbHViLCBpc1NwYWRlXSk7XG4gKlxuICogICAgICBpc0JsYWNrQ2FyZCh7cmFuazogJzEwJywgc3VpdDogJ+KZoyd9KTsgLy89PiB0cnVlXG4gKiAgICAgIGlzQmxhY2tDYXJkKHtyYW5rOiAnUScsIHN1aXQ6ICfimaAnfSk7IC8vPT4gdHJ1ZVxuICogICAgICBpc0JsYWNrQ2FyZCh7cmFuazogJ1EnLCBzdWl0OiAn4pmmJ30pOyAvLz0+IGZhbHNlXG4gKi9cblxudmFyIGFueVBhc3MgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiBhbnlQYXNzKHByZWRzKSB7XG4gIHJldHVybiBjdXJyeU4ocmVkdWNlKG1heCwgMCwgcGx1Y2soJ2xlbmd0aCcsIHByZWRzKSksIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaWR4ID0gMDtcbiAgICB2YXIgbGVuID0gcHJlZHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgaWYgKHByZWRzW2lkeF0uYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBhbnlQYXNzOyIsImltcG9ydCBfY29uY2F0IGZyb20gXCIuL2ludGVybmFsL19jb25jYXQuanNcIjtcbmltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbmltcG9ydCBfcmVkdWNlIGZyb20gXCIuL2ludGVybmFsL19yZWR1Y2UuanNcIjtcbmltcG9ydCBtYXAgZnJvbSBcIi4vbWFwLmpzXCI7XG4vKipcbiAqIGFwIGFwcGxpZXMgYSBsaXN0IG9mIGZ1bmN0aW9ucyB0byBhIGxpc3Qgb2YgdmFsdWVzLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBhcGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuIEFsc29cbiAqIHRyZWF0cyBjdXJyaWVkIGZ1bmN0aW9ucyBhcyBhcHBsaWNhdGl2ZXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMy4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgW2EgLT4gYl0gLT4gW2FdIC0+IFtiXVxuICogQHNpZyBBcHBseSBmID0+IGYgKGEgLT4gYikgLT4gZiBhIC0+IGYgYlxuICogQHNpZyAociAtPiBhIC0+IGIpIC0+IChyIC0+IGEpIC0+IChyIC0+IGIpXG4gKiBAcGFyYW0geyp9IGFwcGx5RlxuICogQHBhcmFtIHsqfSBhcHBseVhcbiAqIEByZXR1cm4geyp9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5hcChbUi5tdWx0aXBseSgyKSwgUi5hZGQoMyldLCBbMSwyLDNdKTsgLy89PiBbMiwgNCwgNiwgNCwgNSwgNl1cbiAqICAgICAgUi5hcChbUi5jb25jYXQoJ3Rhc3R5ICcpLCBSLnRvVXBwZXJdLCBbJ3BpenphJywgJ3NhbGFkJ10pOyAvLz0+IFtcInRhc3R5IHBpenphXCIsIFwidGFzdHkgc2FsYWRcIiwgXCJQSVpaQVwiLCBcIlNBTEFEXCJdXG4gKlxuICogICAgICAvLyBSLmFwIGNhbiBhbHNvIGJlIHVzZWQgYXMgUyBjb21iaW5hdG9yXG4gKiAgICAgIC8vIHdoZW4gb25seSB0d28gZnVuY3Rpb25zIGFyZSBwYXNzZWRcbiAqICAgICAgUi5hcChSLmNvbmNhdCwgUi50b1VwcGVyKSgnUmFtZGEnKSAvLz0+ICdSYW1kYVJBTURBJ1xuICogQHN5bWIgUi5hcChbZiwgZ10sIFthLCBiXSkgPSBbZihhKSwgZihiKSwgZyhhKSwgZyhiKV1cbiAqL1xuXG52YXIgYXAgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBhcChhcHBseUYsIGFwcGx5WCkge1xuICByZXR1cm4gdHlwZW9mIGFwcGx5WFsnZmFudGFzeS1sYW5kL2FwJ10gPT09ICdmdW5jdGlvbicgPyBhcHBseVhbJ2ZhbnRhc3ktbGFuZC9hcCddKGFwcGx5RikgOiB0eXBlb2YgYXBwbHlGLmFwID09PSAnZnVuY3Rpb24nID8gYXBwbHlGLmFwKGFwcGx5WCkgOiB0eXBlb2YgYXBwbHlGID09PSAnZnVuY3Rpb24nID8gZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4gYXBwbHlGKHgpKGFwcGx5WCh4KSk7XG4gIH0gOiBfcmVkdWNlKGZ1bmN0aW9uIChhY2MsIGYpIHtcbiAgICByZXR1cm4gX2NvbmNhdChhY2MsIG1hcChmLCBhcHBseVgpKTtcbiAgfSwgW10sIGFwcGx5Rik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXA7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FwZXJ0dXJlKG4sIGxpc3QpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsaW1pdCA9IGxpc3QubGVuZ3RoIC0gKG4gLSAxKTtcbiAgdmFyIGFjYyA9IG5ldyBBcnJheShsaW1pdCA+PSAwID8gbGltaXQgOiAwKTtcblxuICB3aGlsZSAoaWR4IDwgbGltaXQpIHtcbiAgICBhY2NbaWR4XSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIGlkeCwgaWR4ICsgbik7XG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gYWNjO1xufSIsImltcG9ydCBfY29uY2F0IGZyb20gXCIuL19jb25jYXQuanNcIjtcbmltcG9ydCBfY3VycnkyIGZyb20gXCIuL19jdXJyeTIuanNcIjtcbmltcG9ydCBfeGZCYXNlIGZyb20gXCIuL194ZkJhc2UuanNcIjtcblxudmFyIFhBcGVydHVyZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhBcGVydHVyZShuLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLnBvcyA9IDA7XG4gICAgdGhpcy5mdWxsID0gZmFsc2U7XG4gICAgdGhpcy5hY2MgPSBuZXcgQXJyYXkobik7XG4gIH1cblxuICBYQXBlcnR1cmUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuXG4gIFhBcGVydHVyZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICB0aGlzLmFjYyA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9O1xuXG4gIFhBcGVydHVyZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIHRoaXMuc3RvcmUoaW5wdXQpO1xuICAgIHJldHVybiB0aGlzLmZ1bGwgPyB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdGhpcy5nZXRDb3B5KCkpIDogcmVzdWx0O1xuICB9O1xuXG4gIFhBcGVydHVyZS5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB0aGlzLmFjY1t0aGlzLnBvc10gPSBpbnB1dDtcbiAgICB0aGlzLnBvcyArPSAxO1xuXG4gICAgaWYgKHRoaXMucG9zID09PSB0aGlzLmFjYy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgIHRoaXMuZnVsbCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIFhBcGVydHVyZS5wcm90b3R5cGUuZ2V0Q29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2NvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmFjYywgdGhpcy5wb3MpLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmFjYywgMCwgdGhpcy5wb3MpKTtcbiAgfTtcblxuICByZXR1cm4gWEFwZXJ0dXJlO1xufSgpO1xuXG52YXIgX3hhcGVydHVyZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIF94YXBlcnR1cmUobiwgeGYpIHtcbiAgcmV0dXJuIG5ldyBYQXBlcnR1cmUobiwgeGYpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IF94YXBlcnR1cmU7IiwiaW1wb3J0IF9hcGVydHVyZSBmcm9tIFwiLi9pbnRlcm5hbC9fYXBlcnR1cmUuanNcIjtcbmltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gXCIuL2ludGVybmFsL19kaXNwYXRjaGFibGUuanNcIjtcbmltcG9ydCBfeGFwZXJ0dXJlIGZyb20gXCIuL2ludGVybmFsL194YXBlcnR1cmUuanNcIjtcbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0LCBjb21wb3NlZCBvZiBuLXR1cGxlcyBvZiBjb25zZWN1dGl2ZSBlbGVtZW50cy4gSWYgYG5gIGlzXG4gKiBncmVhdGVyIHRoYW4gdGhlIGxlbmd0aCBvZiB0aGUgbGlzdCwgYW4gZW1wdHkgbGlzdCBpcyByZXR1cm5lZC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTIuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbW2FdXVxuICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIHNpemUgb2YgdGhlIHR1cGxlcyB0byBjcmVhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gc3BsaXQgaW50byBgbmAtbGVuZ3RoIHR1cGxlc1xuICogQHJldHVybiB7QXJyYXl9IFRoZSByZXN1bHRpbmcgbGlzdCBvZiBgbmAtbGVuZ3RoIHR1cGxlc1xuICogQHNlZSBSLnRyYW5zZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuYXBlcnR1cmUoMiwgWzEsIDIsIDMsIDQsIDVdKTsgLy89PiBbWzEsIDJdLCBbMiwgM10sIFszLCA0XSwgWzQsIDVdXVxuICogICAgICBSLmFwZXJ0dXJlKDMsIFsxLCAyLCAzLCA0LCA1XSk7IC8vPT4gW1sxLCAyLCAzXSwgWzIsIDMsIDRdLCBbMywgNCwgNV1dXG4gKiAgICAgIFIuYXBlcnR1cmUoNywgWzEsIDIsIDMsIDQsIDVdKTsgLy89PiBbXVxuICovXG5cbnZhciBhcGVydHVyZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKFxuLyojX19QVVJFX18qL1xuX2Rpc3BhdGNoYWJsZShbXSwgX3hhcGVydHVyZSwgX2FwZXJ0dXJlKSk7XG5cbmV4cG9ydCBkZWZhdWx0IGFwZXJ0dXJlOyIsImltcG9ydCBfY29uY2F0IGZyb20gXCIuL2ludGVybmFsL19jb25jYXQuanNcIjtcbmltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIGNvbnRlbnRzIG9mIHRoZSBnaXZlbiBsaXN0LCBmb2xsb3dlZCBieVxuICogdGhlIGdpdmVuIGVsZW1lbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBhIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7Kn0gZWwgVGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBlbmQgb2YgdGhlIG5ldyBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCBvZiBlbGVtZW50cyB0byBhZGQgYSBuZXcgaXRlbSB0by5cbiAqICAgICAgICBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgZWxlbWVudHMgb2YgdGhlIG9sZCBsaXN0IGZvbGxvd2VkIGJ5IGBlbGAuXG4gKiBAc2VlIFIucHJlcGVuZFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuYXBwZW5kKCd0ZXN0cycsIFsnd3JpdGUnLCAnbW9yZSddKTsgLy89PiBbJ3dyaXRlJywgJ21vcmUnLCAndGVzdHMnXVxuICogICAgICBSLmFwcGVuZCgndGVzdHMnLCBbXSk7IC8vPT4gWyd0ZXN0cyddXG4gKiAgICAgIFIuYXBwZW5kKFsndGVzdHMnXSwgWyd3cml0ZScsICdtb3JlJ10pOyAvLz0+IFsnd3JpdGUnLCAnbW9yZScsIFsndGVzdHMnXV1cbiAqL1xuXG52YXIgYXBwZW5kID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gYXBwZW5kKGVsLCBsaXN0KSB7XG4gIHJldHVybiBfY29uY2F0KGxpc3QsIFtlbF0pO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGFwcGVuZDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG4vKipcbiAqIEFwcGxpZXMgZnVuY3Rpb24gYGZuYCB0byB0aGUgYXJndW1lbnQgbGlzdCBgYXJnc2AuIFRoaXMgaXMgdXNlZnVsIGZvclxuICogY3JlYXRpbmcgYSBmaXhlZC1hcml0eSBmdW5jdGlvbiBmcm9tIGEgdmFyaWFkaWMgZnVuY3Rpb24uIGBmbmAgc2hvdWxkIGJlIGFcbiAqIGJvdW5kIGZ1bmN0aW9uIGlmIGNvbnRleHQgaXMgc2lnbmlmaWNhbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNy4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKCouLi4gLT4gYSkgLT4gWypdIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCB3aXRoIGBhcmdzYFxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGNhbGwgYGZuYCB3aXRoXG4gKiBAcmV0dXJuIHsqfSByZXN1bHQgVGhlIHJlc3VsdCwgZXF1aXZhbGVudCB0byBgZm4oLi4uYXJncylgXG4gKiBAc2VlIFIuY2FsbCwgUi51bmFwcGx5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgbnVtcyA9IFsxLCAyLCAzLCAtOTksIDQyLCA2LCA3XTtcbiAqICAgICAgUi5hcHBseShNYXRoLm1heCwgbnVtcyk7IC8vPT4gNDJcbiAqIEBzeW1iIFIuYXBwbHkoZiwgW2EsIGIsIGNdKSA9IGYoYSwgYiwgYylcbiAqL1xuXG52YXIgYXBwbHkgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBhcHBseShmbiwgYXJncykge1xuICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXBwbHk7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5MS5qc1wiO1xuaW1wb3J0IGtleXMgZnJvbSBcIi4va2V5cy5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgdGhlIGVudW1lcmFibGUgb3duIHByb3BlcnRpZXMgb2YgdGhlIHN1cHBsaWVkIG9iamVjdC5cbiAqIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIG91dHB1dCBhcnJheSBpcyBub3QgZ3VhcmFudGVlZCBhY3Jvc3MgZGlmZmVyZW50XG4gKiBKUyBwbGF0Zm9ybXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtrOiB2fSAtPiBbdl1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IHZhbHVlcyBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdGhlIHZhbHVlcyBvZiB0aGUgb2JqZWN0J3Mgb3duIHByb3BlcnRpZXMuXG4gKiBAc2VlIFIudmFsdWVzSW4sIFIua2V5c1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudmFsdWVzKHthOiAxLCBiOiAyLCBjOiAzfSk7IC8vPT4gWzEsIDIsIDNdXG4gKi9cblxudmFyIHZhbHVlcyA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKGZ1bmN0aW9uIHZhbHVlcyhvYmopIHtcbiAgdmFyIHByb3BzID0ga2V5cyhvYmopO1xuICB2YXIgbGVuID0gcHJvcHMubGVuZ3RoO1xuICB2YXIgdmFscyA9IFtdO1xuICB2YXIgaWR4ID0gMDtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgdmFsc1tpZHhdID0gb2JqW3Byb3BzW2lkeF1dO1xuICAgIGlkeCArPSAxO1xuICB9XG5cbiAgcmV0dXJuIHZhbHM7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdmFsdWVzOyIsImltcG9ydCBfY3VycnkxIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTEuanNcIjtcbmltcG9ydCBhcHBseSBmcm9tIFwiLi9hcHBseS5qc1wiO1xuaW1wb3J0IGN1cnJ5TiBmcm9tIFwiLi9jdXJyeU4uanNcIjtcbmltcG9ydCBtYXggZnJvbSBcIi4vbWF4LmpzXCI7XG5pbXBvcnQgcGx1Y2sgZnJvbSBcIi4vcGx1Y2suanNcIjtcbmltcG9ydCByZWR1Y2UgZnJvbSBcIi4vcmVkdWNlLmpzXCI7XG5pbXBvcnQga2V5cyBmcm9tIFwiLi9rZXlzLmpzXCI7XG5pbXBvcnQgdmFsdWVzIGZyb20gXCIuL3ZhbHVlcy5qc1wiOyAvLyBVc2UgY3VzdG9tIG1hcFZhbHVlcyBmdW5jdGlvbiB0byBhdm9pZCBpc3N1ZXMgd2l0aCBzcGVjcyB0aGF0IGluY2x1ZGUgYSBcIm1hcFwiIGtleSBhbmQgUi5tYXBcbi8vIGRlbGVnYXRpbmcgY2FsbHMgdG8gLm1hcFxuXG5mdW5jdGlvbiBtYXBWYWx1ZXMoZm4sIG9iaikge1xuICByZXR1cm4ga2V5cyhvYmopLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICBhY2Nba2V5XSA9IGZuKG9ialtrZXldKTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG59XG4vKipcbiAqIEdpdmVuIGEgc3BlYyBvYmplY3QgcmVjdXJzaXZlbHkgbWFwcGluZyBwcm9wZXJ0aWVzIHRvIGZ1bmN0aW9ucywgY3JlYXRlcyBhXG4gKiBmdW5jdGlvbiBwcm9kdWNpbmcgYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHN0cnVjdHVyZSwgYnkgbWFwcGluZyBlYWNoIHByb3BlcnR5XG4gKiB0byB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgaXRzIGFzc29jaWF0ZWQgZnVuY3Rpb24gd2l0aCB0aGUgc3VwcGxpZWQgYXJndW1lbnRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIwLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyB7azogKChhLCBiLCAuLi4sIG0pIC0+IHYpfSAtPiAoKGEsIGIsIC4uLiwgbSkgLT4ge2s6IHZ9KVxuICogQHBhcmFtIHtPYmplY3R9IHNwZWMgYW4gb2JqZWN0IHJlY3Vyc2l2ZWx5IG1hcHBpbmcgcHJvcGVydGllcyB0byBmdW5jdGlvbnMgZm9yXG4gKiAgICAgICAgcHJvZHVjaW5nIHRoZSB2YWx1ZXMgZm9yIHRoZXNlIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JqZWN0IG9mIHRoZSBzYW1lIHN0cnVjdHVyZVxuICogYXMgYHNwZWMnLCB3aXRoIGVhY2ggcHJvcGVydHkgc2V0IHRvIHRoZSB2YWx1ZSByZXR1cm5lZCBieSBjYWxsaW5nIGl0c1xuICogYXNzb2NpYXRlZCBmdW5jdGlvbiB3aXRoIHRoZSBzdXBwbGllZCBhcmd1bWVudHMuXG4gKiBAc2VlIFIuY29udmVyZ2UsIFIuanV4dFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGdldE1ldHJpY3MgPSBSLmFwcGx5U3BlYyh7XG4gKiAgICAgICAgc3VtOiBSLmFkZCxcbiAqICAgICAgICBuZXN0ZWQ6IHsgbXVsOiBSLm11bHRpcGx5IH1cbiAqICAgICAgfSk7XG4gKiAgICAgIGdldE1ldHJpY3MoMiwgNCk7IC8vID0+IHsgc3VtOiA2LCBuZXN0ZWQ6IHsgbXVsOiA4IH0gfVxuICogQHN5bWIgUi5hcHBseVNwZWMoeyB4OiBmLCB5OiB7IHo6IGcgfSB9KShhLCBiKSA9IHsgeDogZihhLCBiKSwgeTogeyB6OiBnKGEsIGIpIH0gfVxuICovXG5cblxudmFyIGFwcGx5U3BlYyA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKGZ1bmN0aW9uIGFwcGx5U3BlYyhzcGVjKSB7XG4gIHNwZWMgPSBtYXBWYWx1ZXMoZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT0gJ2Z1bmN0aW9uJyA/IHYgOiBhcHBseVNwZWModik7XG4gIH0sIHNwZWMpO1xuICByZXR1cm4gY3VycnlOKHJlZHVjZShtYXgsIDAsIHBsdWNrKCdsZW5ndGgnLCB2YWx1ZXMoc3BlYykpKSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBtYXBWYWx1ZXMoZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJldHVybiBhcHBseShmLCBhcmdzKTtcbiAgICB9LCBzcGVjKTtcbiAgfSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXBwbHlTcGVjOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogVGFrZXMgYSB2YWx1ZSBhbmQgYXBwbGllcyBhIGZ1bmN0aW9uIHRvIGl0LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYWxzbyBrbm93biBhcyB0aGUgYHRocnVzaGAgY29tYmluYXRvci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yNS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgYSAtPiAoYSAtPiBiKSAtPiBiXG4gKiBAcGFyYW0geyp9IHggVGhlIHZhbHVlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIFRoZSBmdW5jdGlvbiB0byBhcHBseVxuICogQHJldHVybiB7Kn0gVGhlIHJlc3VsdCBvZiBhcHBseWluZyBgZmAgdG8gYHhgXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgdDQyID0gUi5hcHBseVRvKDQyKTtcbiAqICAgICAgdDQyKFIuaWRlbnRpdHkpOyAvLz0+IDQyXG4gKiAgICAgIHQ0MihSLmFkZCgxKSk7IC8vPT4gNDNcbiAqL1xuXG52YXIgYXBwbHlUbyA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIGFwcGx5VG8oeCwgZikge1xuICByZXR1cm4gZih4KTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBhcHBseVRvOyIsImltcG9ydCBfY3VycnkzIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTMuanNcIjtcbi8qKlxuICogTWFrZXMgYW4gYXNjZW5kaW5nIGNvbXBhcmF0b3IgZnVuY3Rpb24gb3V0IG9mIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdmFsdWVcbiAqIHRoYXQgY2FuIGJlIGNvbXBhcmVkIHdpdGggYDxgIGFuZCBgPmAuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjMuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIE9yZCBiID0+IChhIC0+IGIpIC0+IGEgLT4gYSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEEgZnVuY3Rpb24gb2YgYXJpdHkgb25lIHRoYXQgcmV0dXJucyBhIHZhbHVlIHRoYXQgY2FuIGJlIGNvbXBhcmVkXG4gKiBAcGFyYW0geyp9IGEgVGhlIGZpcnN0IGl0ZW0gdG8gYmUgY29tcGFyZWQuXG4gKiBAcGFyYW0geyp9IGIgVGhlIHNlY29uZCBpdGVtIHRvIGJlIGNvbXBhcmVkLlxuICogQHJldHVybiB7TnVtYmVyfSBgLTFgIGlmIGZuKGEpIDwgZm4oYiksIGAxYCBpZiBmbihiKSA8IGZuKGEpLCBvdGhlcndpc2UgYDBgXG4gKiBAc2VlIFIuZGVzY2VuZFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGJ5QWdlID0gUi5hc2NlbmQoUi5wcm9wKCdhZ2UnKSk7XG4gKiAgICAgIGNvbnN0IHBlb3BsZSA9IFtcbiAqICAgICAgICB7IG5hbWU6ICdFbW1hJywgYWdlOiA3MCB9LFxuICogICAgICAgIHsgbmFtZTogJ1BldGVyJywgYWdlOiA3OCB9LFxuICogICAgICAgIHsgbmFtZTogJ01pa2hhaWwnLCBhZ2U6IDYyIH0sXG4gKiAgICAgIF07XG4gKiAgICAgIGNvbnN0IHBlb3BsZUJ5WW91bmdlc3RGaXJzdCA9IFIuc29ydChieUFnZSwgcGVvcGxlKTtcbiAqICAgICAgICAvLz0+IFt7IG5hbWU6ICdNaWtoYWlsJywgYWdlOiA2MiB9LHsgbmFtZTogJ0VtbWEnLCBhZ2U6IDcwIH0sIHsgbmFtZTogJ1BldGVyJywgYWdlOiA3OCB9XVxuICovXG5cbnZhciBhc2NlbmQgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MyhmdW5jdGlvbiBhc2NlbmQoZm4sIGEsIGIpIHtcbiAgdmFyIGFhID0gZm4oYSk7XG4gIHZhciBiYiA9IGZuKGIpO1xuICByZXR1cm4gYWEgPCBiYiA/IC0xIDogYWEgPiBiYiA/IDEgOiAwO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGFzY2VuZDsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkzLmpzXCI7XG4vKipcbiAqIE1ha2VzIGEgc2hhbGxvdyBjbG9uZSBvZiBhbiBvYmplY3QsIHNldHRpbmcgb3Igb3ZlcnJpZGluZyB0aGUgc3BlY2lmaWVkXG4gKiBwcm9wZXJ0eSB3aXRoIHRoZSBnaXZlbiB2YWx1ZS4gTm90ZSB0aGF0IHRoaXMgY29waWVzIGFuZCBmbGF0dGVucyBwcm90b3R5cGVcbiAqIHByb3BlcnRpZXMgb250byB0aGUgbmV3IG9iamVjdCBhcyB3ZWxsLiBBbGwgbm9uLXByaW1pdGl2ZSBwcm9wZXJ0aWVzIGFyZVxuICogY29waWVkIGJ5IHJlZmVyZW5jZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgU3RyaW5nIC0+IGEgLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICogQHBhcmFtIHtTdHJpbmd9IHByb3AgVGhlIHByb3BlcnR5IG5hbWUgdG8gc2V0XG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgbmV3IHZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2xvbmVcbiAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IGVxdWl2YWxlbnQgdG8gdGhlIG9yaWdpbmFsIGV4Y2VwdCBmb3IgdGhlIGNoYW5nZWQgcHJvcGVydHkuXG4gKiBAc2VlIFIuZGlzc29jLCBSLnBpY2tcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmFzc29jKCdjJywgMywge2E6IDEsIGI6IDJ9KTsgLy89PiB7YTogMSwgYjogMiwgYzogM31cbiAqL1xuXG52YXIgYXNzb2MgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MyhmdW5jdGlvbiBhc3NvYyhwcm9wLCB2YWwsIG9iaikge1xuICB2YXIgcmVzdWx0ID0ge307XG5cbiAgZm9yICh2YXIgcCBpbiBvYmopIHtcbiAgICByZXN1bHRbcF0gPSBvYmpbcF07XG4gIH1cblxuICByZXN1bHRbcHJvcF0gPSB2YWw7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXNzb2M7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5MS5qc1wiO1xuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGlucHV0IHZhbHVlIGlzIGBudWxsYCBvciBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBUeXBlXG4gKiBAc2lnICogLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfSB4IFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB4YCBpcyBgdW5kZWZpbmVkYCBvciBgbnVsbGAsIG90aGVyd2lzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaXNOaWwobnVsbCk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzTmlsKHVuZGVmaW5lZCk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzTmlsKDApOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaXNOaWwoW10pOyAvLz0+IGZhbHNlXG4gKi9cblxudmFyIGlzTmlsID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoZnVuY3Rpb24gaXNOaWwoeCkge1xuICByZXR1cm4geCA9PSBudWxsO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzTmlsOyIsImltcG9ydCBfY3VycnkzIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTMuanNcIjtcbmltcG9ydCBfaGFzIGZyb20gXCIuL2ludGVybmFsL19oYXMuanNcIjtcbmltcG9ydCBfaXNBcnJheSBmcm9tIFwiLi9pbnRlcm5hbC9faXNBcnJheS5qc1wiO1xuaW1wb3J0IF9pc0ludGVnZXIgZnJvbSBcIi4vaW50ZXJuYWwvX2lzSW50ZWdlci5qc1wiO1xuaW1wb3J0IGFzc29jIGZyb20gXCIuL2Fzc29jLmpzXCI7XG5pbXBvcnQgaXNOaWwgZnJvbSBcIi4vaXNOaWwuanNcIjtcbi8qKlxuICogTWFrZXMgYSBzaGFsbG93IGNsb25lIG9mIGFuIG9iamVjdCwgc2V0dGluZyBvciBvdmVycmlkaW5nIHRoZSBub2RlcyByZXF1aXJlZFxuICogdG8gY3JlYXRlIHRoZSBnaXZlbiBwYXRoLCBhbmQgcGxhY2luZyB0aGUgc3BlY2lmaWMgdmFsdWUgYXQgdGhlIHRhaWwgZW5kIG9mXG4gKiB0aGF0IHBhdGguIE5vdGUgdGhhdCB0aGlzIGNvcGllcyBhbmQgZmxhdHRlbnMgcHJvdG90eXBlIHByb3BlcnRpZXMgb250byB0aGVcbiAqIG5ldyBvYmplY3QgYXMgd2VsbC4gQWxsIG5vbi1wcmltaXRpdmUgcHJvcGVydGllcyBhcmUgY29waWVkIGJ5IHJlZmVyZW5jZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEB0eXBlZGVmbiBJZHggPSBTdHJpbmcgfCBJbnRcbiAqIEBzaWcgW0lkeF0gLT4gYSAtPiB7YX0gLT4ge2F9XG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoIHRoZSBwYXRoIHRvIHNldFxuICogQHBhcmFtIHsqfSB2YWwgVGhlIG5ldyB2YWx1ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNsb25lXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCBlcXVpdmFsZW50IHRvIHRoZSBvcmlnaW5hbCBleGNlcHQgYWxvbmcgdGhlIHNwZWNpZmllZCBwYXRoLlxuICogQHNlZSBSLmRpc3NvY1BhdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmFzc29jUGF0aChbJ2EnLCAnYicsICdjJ10sIDQyLCB7YToge2I6IHtjOiAwfX19KTsgLy89PiB7YToge2I6IHtjOiA0Mn19fVxuICpcbiAqICAgICAgLy8gQW55IG1pc3Npbmcgb3Igbm9uLW9iamVjdCBrZXlzIGluIHBhdGggd2lsbCBiZSBvdmVycmlkZGVuXG4gKiAgICAgIFIuYXNzb2NQYXRoKFsnYScsICdiJywgJ2MnXSwgNDIsIHthOiA1fSk7IC8vPT4ge2E6IHtiOiB7YzogNDJ9fX1cbiAqL1xuXG52YXIgYXNzb2NQYXRoID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTMoZnVuY3Rpb24gYXNzb2NQYXRoKHBhdGgsIHZhbCwgb2JqKSB7XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICB2YXIgaWR4ID0gcGF0aFswXTtcblxuICBpZiAocGF0aC5sZW5ndGggPiAxKSB7XG4gICAgdmFyIG5leHRPYmogPSAhaXNOaWwob2JqKSAmJiBfaGFzKGlkeCwgb2JqKSA/IG9ialtpZHhdIDogX2lzSW50ZWdlcihwYXRoWzFdKSA/IFtdIDoge307XG4gICAgdmFsID0gYXNzb2NQYXRoKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHBhdGgsIDEpLCB2YWwsIG5leHRPYmopO1xuICB9XG5cbiAgaWYgKF9pc0ludGVnZXIoaWR4KSAmJiBfaXNBcnJheShvYmopKSB7XG4gICAgdmFyIGFyciA9IFtdLmNvbmNhdChvYmopO1xuICAgIGFycltpZHhdID0gdmFsO1xuICAgIHJldHVybiBhcnI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGFzc29jKGlkeCwgdmFsLCBvYmopO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYXNzb2NQYXRoOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogV3JhcHMgYSBmdW5jdGlvbiBvZiBhbnkgYXJpdHkgKGluY2x1ZGluZyBudWxsYXJ5KSBpbiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0c1xuICogZXhhY3RseSBgbmAgcGFyYW1ldGVycy4gQW55IGV4dHJhbmVvdXMgcGFyYW1ldGVycyB3aWxsIG5vdCBiZSBwYXNzZWQgdG8gdGhlXG4gKiBzdXBwbGllZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBOdW1iZXIgLT4gKCogLT4gYSkgLT4gKCogLT4gYSlcbiAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBkZXNpcmVkIGFyaXR5IG9mIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyBgZm5gLiBUaGUgbmV3IGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gYmUgb2ZcbiAqICAgICAgICAgYXJpdHkgYG5gLlxuICogQHNlZSBSLmJpbmFyeSwgUi51bmFyeVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IHRha2VzVHdvQXJncyA9IChhLCBiKSA9PiBbYSwgYl07XG4gKlxuICogICAgICB0YWtlc1R3b0FyZ3MubGVuZ3RoOyAvLz0+IDJcbiAqICAgICAgdGFrZXNUd29BcmdzKDEsIDIpOyAvLz0+IFsxLCAyXVxuICpcbiAqICAgICAgY29uc3QgdGFrZXNPbmVBcmcgPSBSLm5BcnkoMSwgdGFrZXNUd29BcmdzKTtcbiAqICAgICAgdGFrZXNPbmVBcmcubGVuZ3RoOyAvLz0+IDFcbiAqICAgICAgLy8gT25seSBgbmAgYXJndW1lbnRzIGFyZSBwYXNzZWQgdG8gdGhlIHdyYXBwZWQgZnVuY3Rpb25cbiAqICAgICAgdGFrZXNPbmVBcmcoMSwgMik7IC8vPT4gWzEsIHVuZGVmaW5lZF1cbiAqIEBzeW1iIFIubkFyeSgwLCBmKShhLCBiKSA9IGYoKVxuICogQHN5bWIgUi5uQXJ5KDEsIGYpKGEsIGIpID0gZihhKVxuICogQHN5bWIgUi5uQXJ5KDIsIGYpKGEsIGIpID0gZihhLCBiKVxuICovXG5cbnZhciBuQXJ5ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gbkFyeShuLCBmbikge1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwKSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGEwKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEpO1xuICAgICAgfTtcblxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMikge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzKSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSwgYTIsIGEzKTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDU6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQpO1xuICAgICAgfTtcblxuICAgIGNhc2UgNjpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQsIGE1KTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDc6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2KSB7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2KTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDg6XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNykge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpO1xuICAgICAgfTtcblxuICAgIGNhc2UgOTpcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4KTtcbiAgICAgIH07XG5cbiAgICBjYXNlIDEwOlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSkge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSk7XG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgdG8gbkFyeSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgbm8gZ3JlYXRlciB0aGFuIHRlbicpO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbkFyeTsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkxLmpzXCI7XG5pbXBvcnQgbkFyeSBmcm9tIFwiLi9uQXJ5LmpzXCI7XG4vKipcbiAqIFdyYXBzIGEgZnVuY3Rpb24gb2YgYW55IGFyaXR5IChpbmNsdWRpbmcgbnVsbGFyeSkgaW4gYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHNcbiAqIGV4YWN0bHkgMiBwYXJhbWV0ZXJzLiBBbnkgZXh0cmFuZW91cyBwYXJhbWV0ZXJzIHdpbGwgbm90IGJlIHBhc3NlZCB0byB0aGVcbiAqIHN1cHBsaWVkIGZ1bmN0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgqIC0+IGMpIC0+IChhLCBiIC0+IGMpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyBgZm5gLiBUaGUgbmV3IGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gYmUgb2ZcbiAqICAgICAgICAgYXJpdHkgMi5cbiAqIEBzZWUgUi5uQXJ5LCBSLnVuYXJ5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgdGFrZXNUaHJlZUFyZ3MgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gKiAgICAgICAgcmV0dXJuIFthLCBiLCBjXTtcbiAqICAgICAgfTtcbiAqICAgICAgdGFrZXNUaHJlZUFyZ3MubGVuZ3RoOyAvLz0+IDNcbiAqICAgICAgdGFrZXNUaHJlZUFyZ3MoMSwgMiwgMyk7IC8vPT4gWzEsIDIsIDNdXG4gKlxuICogICAgICBjb25zdCB0YWtlc1R3b0FyZ3MgPSBSLmJpbmFyeSh0YWtlc1RocmVlQXJncyk7XG4gKiAgICAgIHRha2VzVHdvQXJncy5sZW5ndGg7IC8vPT4gMlxuICogICAgICAvLyBPbmx5IDIgYXJndW1lbnRzIGFyZSBwYXNzZWQgdG8gdGhlIHdyYXBwZWQgZnVuY3Rpb25cbiAqICAgICAgdGFrZXNUd29BcmdzKDEsIDIsIDMpOyAvLz0+IFsxLCAyLCB1bmRlZmluZWRdXG4gKiBAc3ltYiBSLmJpbmFyeShmKShhLCBiLCBjKSA9IGYoYSwgYilcbiAqL1xuXG52YXIgYmluYXJ5ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoZnVuY3Rpb24gYmluYXJ5KGZuKSB7XG4gIHJldHVybiBuQXJ5KDIsIGZuKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBiaW5hcnk7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2lzRnVuY3Rpb24oeCkge1xuICB2YXIgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KTtcbiAgcmV0dXJuIHR5cGUgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgQXN5bmNHZW5lcmF0b3JGdW5jdGlvbl0nO1xufSIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbmltcG9ydCBfcmVkdWNlIGZyb20gXCIuL2ludGVybmFsL19yZWR1Y2UuanNcIjtcbmltcG9ydCBhcCBmcm9tIFwiLi9hcC5qc1wiO1xuaW1wb3J0IGN1cnJ5TiBmcm9tIFwiLi9jdXJyeU4uanNcIjtcbmltcG9ydCBtYXAgZnJvbSBcIi4vbWFwLmpzXCI7XG4vKipcbiAqIFwibGlmdHNcIiBhIGZ1bmN0aW9uIHRvIGJlIHRoZSBzcGVjaWZpZWQgYXJpdHksIHNvIHRoYXQgaXQgbWF5IFwibWFwIG92ZXJcIiB0aGF0XG4gKiBtYW55IGxpc3RzLCBGdW5jdGlvbnMgb3Igb3RoZXIgb2JqZWN0cyB0aGF0IHNhdGlzZnkgdGhlIFtGYW50YXN5TGFuZCBBcHBseSBzcGVjXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2FwcGx5KS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC43LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBOdW1iZXIgLT4gKCouLi4gLT4gKikgLT4gKFsqXS4uLiAtPiBbKl0pXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbGlmdCBpbnRvIGhpZ2hlciBjb250ZXh0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGxpZnRlZCBmdW5jdGlvbi5cbiAqIEBzZWUgUi5saWZ0LCBSLmFwXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgbWFkZDMgPSBSLmxpZnROKDMsICguLi5hcmdzKSA9PiBSLnN1bShhcmdzKSk7XG4gKiAgICAgIG1hZGQzKFsxLDIsM10sIFsxLDIsM10sIFsxXSk7IC8vPT4gWzMsIDQsIDUsIDQsIDUsIDYsIDUsIDYsIDddXG4gKi9cblxudmFyIGxpZnROID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gbGlmdE4oYXJpdHksIGZuKSB7XG4gIHZhciBsaWZ0ZWQgPSBjdXJyeU4oYXJpdHksIGZuKTtcbiAgcmV0dXJuIGN1cnJ5Tihhcml0eSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcmVkdWNlKGFwLCBtYXAobGlmdGVkLCBhcmd1bWVudHNbMF0pLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgfSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbGlmdE47IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5MS5qc1wiO1xuaW1wb3J0IGxpZnROIGZyb20gXCIuL2xpZnROLmpzXCI7XG4vKipcbiAqIFwibGlmdHNcIiBhIGZ1bmN0aW9uIG9mIGFyaXR5ID4gMSBzbyB0aGF0IGl0IG1heSBcIm1hcCBvdmVyXCIgYSBsaXN0LCBGdW5jdGlvbiBvciBvdGhlclxuICogb2JqZWN0IHRoYXQgc2F0aXNmaWVzIHRoZSBbRmFudGFzeUxhbmQgQXBwbHkgc3BlY10oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhcHBseSkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNy4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKCouLi4gLT4gKikgLT4gKFsqXS4uLiAtPiBbKl0pXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbGlmdCBpbnRvIGhpZ2hlciBjb250ZXh0XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIGxpZnRlZCBmdW5jdGlvbi5cbiAqIEBzZWUgUi5saWZ0TlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IG1hZGQzID0gUi5saWZ0KChhLCBiLCBjKSA9PiBhICsgYiArIGMpO1xuICpcbiAqICAgICAgbWFkZDMoWzEsMiwzXSwgWzEsMiwzXSwgWzFdKTsgLy89PiBbMywgNCwgNSwgNCwgNSwgNiwgNSwgNiwgN11cbiAqXG4gKiAgICAgIGNvbnN0IG1hZGQ1ID0gUi5saWZ0KChhLCBiLCBjLCBkLCBlKSA9PiBhICsgYiArIGMgKyBkICsgZSk7XG4gKlxuICogICAgICBtYWRkNShbMSwyXSwgWzNdLCBbNCwgNV0sIFs2XSwgWzcsIDhdKTsgLy89PiBbMjEsIDIyLCAyMiwgMjMsIDIyLCAyMywgMjMsIDI0XVxuICovXG5cbnZhciBsaWZ0ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoZnVuY3Rpb24gbGlmdChmbikge1xuICByZXR1cm4gbGlmdE4oZm4ubGVuZ3RoLCBmbik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbGlmdDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgX2lzRnVuY3Rpb24gZnJvbSBcIi4vaW50ZXJuYWwvX2lzRnVuY3Rpb24uanNcIjtcbmltcG9ydCBhbmQgZnJvbSBcIi4vYW5kLmpzXCI7XG5pbXBvcnQgbGlmdCBmcm9tIFwiLi9saWZ0LmpzXCI7XG4vKipcbiAqIEEgZnVuY3Rpb24gd2hpY2ggY2FsbHMgdGhlIHR3byBwcm92aWRlZCBmdW5jdGlvbnMgYW5kIHJldHVybnMgdGhlIGAmJmBcbiAqIG9mIHRoZSByZXN1bHRzLlxuICogSXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBmaXJzdCBmdW5jdGlvbiBpZiBpdCBpcyBmYWxzZS15IGFuZCB0aGUgcmVzdWx0XG4gKiBvZiB0aGUgc2Vjb25kIGZ1bmN0aW9uIG90aGVyd2lzZS4gTm90ZSB0aGF0IHRoaXMgaXMgc2hvcnQtY2lyY3VpdGVkLFxuICogbWVhbmluZyB0aGF0IHRoZSBzZWNvbmQgZnVuY3Rpb24gd2lsbCBub3QgYmUgaW52b2tlZCBpZiB0aGUgZmlyc3QgcmV0dXJucyBhXG4gKiBmYWxzZS15IHZhbHVlLlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIGZ1bmN0aW9ucywgYFIuYm90aGAgYWxzbyBhY2NlcHRzIGFueSBmYW50YXN5LWxhbmQgY29tcGF0aWJsZVxuICogYXBwbGljYXRpdmUgZnVuY3Rvci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMi4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgKCouLi4gLT4gQm9vbGVhbikgLT4gKCouLi4gLT4gQm9vbGVhbikgLT4gKCouLi4gLT4gQm9vbGVhbilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGYgQSBwcmVkaWNhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGcgQW5vdGhlciBwcmVkaWNhdGVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBhIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBpdHMgYXJndW1lbnRzIHRvIGBmYCBhbmQgYGdgIGFuZCBgJiZgcyB0aGVpciBvdXRwdXRzIHRvZ2V0aGVyLlxuICogQHNlZSBSLmFuZFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGd0MTAgPSBSLmd0KFIuX18sIDEwKVxuICogICAgICBjb25zdCBsdDIwID0gUi5sdChSLl9fLCAyMClcbiAqICAgICAgY29uc3QgZiA9IFIuYm90aChndDEwLCBsdDIwKTtcbiAqICAgICAgZigxNSk7IC8vPT4gdHJ1ZVxuICogICAgICBmKDMwKTsgLy89PiBmYWxzZVxuICpcbiAqICAgICAgUi5ib3RoKE1heWJlLkp1c3QoZmFsc2UpLCBNYXliZS5KdXN0KDU1KSk7IC8vID0+IE1heWJlLkp1c3QoZmFsc2UpXG4gKiAgICAgIFIuYm90aChbZmFsc2UsIGZhbHNlLCAnYSddLCBbMTFdKTsgLy89PiBbZmFsc2UsIGZhbHNlLCAxMV1cbiAqL1xuXG52YXIgYm90aCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIGJvdGgoZiwgZykge1xuICByZXR1cm4gX2lzRnVuY3Rpb24oZikgPyBmdW5jdGlvbiBfYm90aCgpIHtcbiAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpICYmIGcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSA6IGxpZnQoYW5kKShmLCBnKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBib3RoOyIsImltcG9ydCBfY3VycnkxIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTEuanNcIjtcbmltcG9ydCBjdXJyeU4gZnJvbSBcIi4vY3VycnlOLmpzXCI7XG4vKipcbiAqIFJldHVybnMgYSBjdXJyaWVkIGVxdWl2YWxlbnQgb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLiBUaGUgY3VycmllZCBmdW5jdGlvblxuICogaGFzIHR3byB1bnVzdWFsIGNhcGFiaWxpdGllcy4gRmlyc3QsIGl0cyBhcmd1bWVudHMgbmVlZG4ndCBiZSBwcm92aWRlZCBvbmVcbiAqIGF0IGEgdGltZS4gSWYgYGZgIGlzIGEgdGVybmFyeSBmdW5jdGlvbiBhbmQgYGdgIGlzIGBSLmN1cnJ5KGYpYCwgdGhlXG4gKiBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAtIGBnKDEpKDIpKDMpYFxuICogICAtIGBnKDEpKDIsIDMpYFxuICogICAtIGBnKDEsIDIpKDMpYFxuICogICAtIGBnKDEsIDIsIDMpYFxuICpcbiAqIFNlY29uZGx5LCB0aGUgc3BlY2lhbCBwbGFjZWhvbGRlciB2YWx1ZSBbYFIuX19gXSgjX18pIG1heSBiZSB1c2VkIHRvIHNwZWNpZnlcbiAqIFwiZ2Fwc1wiLCBhbGxvd2luZyBwYXJ0aWFsIGFwcGxpY2F0aW9uIG9mIGFueSBjb21iaW5hdGlvbiBvZiBhcmd1bWVudHMsXG4gKiByZWdhcmRsZXNzIG9mIHRoZWlyIHBvc2l0aW9ucy4gSWYgYGdgIGlzIGFzIGFib3ZlIGFuZCBgX2AgaXMgW2BSLl9fYF0oI19fKSxcbiAqIHRoZSBmb2xsb3dpbmcgYXJlIGVxdWl2YWxlbnQ6XG4gKlxuICogICAtIGBnKDEsIDIsIDMpYFxuICogICAtIGBnKF8sIDIsIDMpKDEpYFxuICogICAtIGBnKF8sIF8sIDMpKDEpKDIpYFxuICogICAtIGBnKF8sIF8sIDMpKDEsIDIpYFxuICogICAtIGBnKF8sIDIpKDEpKDMpYFxuICogICAtIGBnKF8sIDIpKDEsIDMpYFxuICogICAtIGBnKF8sIDIpKF8sIDMpKDEpYFxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgqIC0+IGEpIC0+ICgqIC0+IGEpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcsIGN1cnJpZWQgZnVuY3Rpb24uXG4gKiBAc2VlIFIuY3VycnlOLCBSLnBhcnRpYWxcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBhZGRGb3VyTnVtYmVycyA9IChhLCBiLCBjLCBkKSA9PiBhICsgYiArIGMgKyBkO1xuICpcbiAqICAgICAgY29uc3QgY3VycmllZEFkZEZvdXJOdW1iZXJzID0gUi5jdXJyeShhZGRGb3VyTnVtYmVycyk7XG4gKiAgICAgIGNvbnN0IGYgPSBjdXJyaWVkQWRkRm91ck51bWJlcnMoMSwgMik7XG4gKiAgICAgIGNvbnN0IGcgPSBmKDMpO1xuICogICAgICBnKDQpOyAvLz0+IDEwXG4gKi9cblxudmFyIGN1cnJ5ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoZnVuY3Rpb24gY3VycnkoZm4pIHtcbiAgcmV0dXJuIGN1cnJ5Tihmbi5sZW5ndGgsIGZuKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBjdXJyeTsiLCJpbXBvcnQgY3VycnkgZnJvbSBcIi4vY3VycnkuanNcIjtcbi8qKlxuICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgaXRzIGZpcnN0IGFyZ3VtZW50IHdpdGggdGhlIHJlbWFpbmluZ1xuICogYXJndW1lbnRzLiBUaGlzIGlzIG9jY2FzaW9uYWxseSB1c2VmdWwgYXMgYSBjb252ZXJnaW5nIGZ1bmN0aW9uIGZvclxuICogW2BSLmNvbnZlcmdlYF0oI2NvbnZlcmdlKTogdGhlIGZpcnN0IGJyYW5jaCBjYW4gcHJvZHVjZSBhIGZ1bmN0aW9uIHdoaWxlIHRoZVxuICogcmVtYWluaW5nIGJyYW5jaGVzIHByb2R1Y2UgdmFsdWVzIHRvIGJlIHBhc3NlZCB0byB0aGF0IGZ1bmN0aW9uIGFzIGl0c1xuICogYXJndW1lbnRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgqLi4uIC0+IGEpLCouLi4gLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIHRoZSByZW1haW5pbmcgYXJndW1lbnRzLlxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFueSBudW1iZXIgb2YgcG9zaXRpb25hbCBhcmd1bWVudHMuXG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLmFwcGx5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5jYWxsKFIuYWRkLCAxLCAyKTsgLy89PiAzXG4gKlxuICogICAgICBjb25zdCBpbmRlbnROID0gUi5waXBlKFIucmVwZWF0KCcgJyksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFIuam9pbignJyksXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFIucmVwbGFjZSgvXig/ISQpL2dtKSk7XG4gKlxuICogICAgICBjb25zdCBmb3JtYXQgPSBSLmNvbnZlcmdlKFIuY2FsbCwgW1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUi5waXBlKFIucHJvcCgnaW5kZW50JyksIGluZGVudE4pLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUi5wcm9wKCd2YWx1ZScpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICpcbiAqICAgICAgZm9ybWF0KHtpbmRlbnQ6IDIsIHZhbHVlOiAnZm9vXFxuYmFyXFxuYmF6XFxuJ30pOyAvLz0+ICcgIGZvb1xcbiAgYmFyXFxuICBiYXpcXG4nXG4gKiBAc3ltYiBSLmNhbGwoZiwgYSwgYikgPSBmKGEsIGIpXG4gKi9cblxudmFyIGNhbGwgPVxuLyojX19QVVJFX18qL1xuY3VycnkoZnVuY3Rpb24gY2FsbChmbikge1xuICByZXR1cm4gZm4uYXBwbHkodGhpcywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG59KTtcbmV4cG9ydCBkZWZhdWx0IGNhbGw7IiwiaW1wb3J0IF9pc0FycmF5TGlrZSBmcm9tIFwiLi9faXNBcnJheUxpa2UuanNcIjtcbi8qKlxuICogYF9tYWtlRmxhdGAgaXMgYSBoZWxwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgb25lLWxldmVsIG9yIGZ1bGx5IHJlY3Vyc2l2ZVxuICogZnVuY3Rpb24gYmFzZWQgb24gdGhlIGZsYWcgcGFzc2VkIGluLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX21ha2VGbGF0KHJlY3Vyc2l2ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gZmxhdHQobGlzdCkge1xuICAgIHZhciB2YWx1ZSwgamxlbiwgajtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIGlsZW4gPSBsaXN0Lmxlbmd0aDtcblxuICAgIHdoaWxlIChpZHggPCBpbGVuKSB7XG4gICAgICBpZiAoX2lzQXJyYXlMaWtlKGxpc3RbaWR4XSkpIHtcbiAgICAgICAgdmFsdWUgPSByZWN1cnNpdmUgPyBmbGF0dChsaXN0W2lkeF0pIDogbGlzdFtpZHhdO1xuICAgICAgICBqID0gMDtcbiAgICAgICAgamxlbiA9IHZhbHVlLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaiA8IGpsZW4pIHtcbiAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZVtqXTtcbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IGxpc3RbaWR4XTtcbiAgICAgIH1cblxuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZm9yY2VSZWR1Y2VkKHgpIHtcbiAgcmV0dXJuIHtcbiAgICAnQEB0cmFuc2R1Y2VyL3ZhbHVlJzogeCxcbiAgICAnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnOiB0cnVlXG4gIH07XG59IiwiaW1wb3J0IF9mb3JjZVJlZHVjZWQgZnJvbSBcIi4vX2ZvcmNlUmVkdWNlZC5qc1wiO1xuaW1wb3J0IF9pc0FycmF5TGlrZSBmcm9tIFwiLi9faXNBcnJheUxpa2UuanNcIjtcbmltcG9ydCBfcmVkdWNlIGZyb20gXCIuL19yZWR1Y2UuanNcIjtcbmltcG9ydCBfeGZCYXNlIGZyb20gXCIuL194ZkJhc2UuanNcIjtcblxudmFyIHByZXNlcnZpbmdSZWR1Y2VkID0gZnVuY3Rpb24gKHhmKSB7XG4gIHJldHVybiB7XG4gICAgJ0BAdHJhbnNkdWNlci9pbml0JzogX3hmQmFzZS5pbml0LFxuICAgICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgICB9LFxuICAgICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgICB2YXIgcmV0ID0geGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCk7XG4gICAgICByZXR1cm4gcmV0WydAQHRyYW5zZHVjZXIvcmVkdWNlZCddID8gX2ZvcmNlUmVkdWNlZChyZXQpIDogcmV0O1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBfZmxhdENhdCA9IGZ1bmN0aW9uIF94Y2F0KHhmKSB7XG4gIHZhciByeGYgPSBwcmVzZXJ2aW5nUmVkdWNlZCh4Zik7XG4gIHJldHVybiB7XG4gICAgJ0BAdHJhbnNkdWNlci9pbml0JzogX3hmQmFzZS5pbml0LFxuICAgICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJ4ZlsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddKHJlc3VsdCk7XG4gICAgfSxcbiAgICAnQEB0cmFuc2R1Y2VyL3N0ZXAnOiBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgICAgcmV0dXJuICFfaXNBcnJheUxpa2UoaW5wdXQpID8gX3JlZHVjZShyeGYsIHJlc3VsdCwgW2lucHV0XSkgOiBfcmVkdWNlKHJ4ZiwgcmVzdWx0LCBpbnB1dCk7XG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgX2ZsYXRDYXQ7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9mbGF0Q2F0IGZyb20gXCIuL19mbGF0Q2F0LmpzXCI7XG5pbXBvcnQgbWFwIGZyb20gXCIuLi9tYXAuanNcIjtcblxudmFyIF94Y2hhaW4gPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBfeGNoYWluKGYsIHhmKSB7XG4gIHJldHVybiBtYXAoZiwgX2ZsYXRDYXQoeGYpKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBfeGNoYWluOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gXCIuL2ludGVybmFsL19kaXNwYXRjaGFibGUuanNcIjtcbmltcG9ydCBfbWFrZUZsYXQgZnJvbSBcIi4vaW50ZXJuYWwvX21ha2VGbGF0LmpzXCI7XG5pbXBvcnQgX3hjaGFpbiBmcm9tIFwiLi9pbnRlcm5hbC9feGNoYWluLmpzXCI7XG5pbXBvcnQgbWFwIGZyb20gXCIuL21hcC5qc1wiO1xuLyoqXG4gKiBgY2hhaW5gIG1hcHMgYSBmdW5jdGlvbiBvdmVyIGEgbGlzdCBhbmQgY29uY2F0ZW5hdGVzIHRoZSByZXN1bHRzLiBgY2hhaW5gXG4gKiBpcyBhbHNvIGtub3duIGFzIGBmbGF0TWFwYCBpbiBzb21lIGxpYnJhcmllcy5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgY2hhaW5gIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LFxuICogYWNjb3JkaW5nIHRvIHRoZSBbRmFudGFzeUxhbmQgQ2hhaW4gc3BlY10oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNjaGFpbikuXG4gKlxuICogSWYgc2Vjb25kIGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24sIGBjaGFpbihmLCBnKSh4KWAgaXMgZXF1aXZhbGVudCB0byBgZihnKHgpLCB4KWAuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjMuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgQ2hhaW4gbSA9PiAoYSAtPiBtIGIpIC0+IG0gYSAtPiBtIGJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXAgd2l0aFxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBtYXAgb3ZlclxuICogQHJldHVybiB7QXJyYXl9IFRoZSByZXN1bHQgb2YgZmxhdC1tYXBwaW5nIGBsaXN0YCB3aXRoIGBmbmBcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBkdXBsaWNhdGUgPSBuID0+IFtuLCBuXTtcbiAqICAgICAgUi5jaGFpbihkdXBsaWNhdGUsIFsxLCAyLCAzXSk7IC8vPT4gWzEsIDEsIDIsIDIsIDMsIDNdXG4gKlxuICogICAgICBSLmNoYWluKFIuYXBwZW5kLCBSLmhlYWQpKFsxLCAyLCAzXSk7IC8vPT4gWzEsIDIsIDMsIDFdXG4gKi9cblxudmFyIGNoYWluID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoXG4vKiNfX1BVUkVfXyovXG5fZGlzcGF0Y2hhYmxlKFsnZmFudGFzeS1sYW5kL2NoYWluJywgJ2NoYWluJ10sIF94Y2hhaW4sIGZ1bmN0aW9uIGNoYWluKGZuLCBtb25hZCkge1xuICBpZiAodHlwZW9mIG1vbmFkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4KSB7XG4gICAgICByZXR1cm4gZm4obW9uYWQoeCkpKHgpO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX21ha2VGbGF0KGZhbHNlKShtYXAoZm4sIG1vbmFkKSk7XG59KSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNoYWluOyIsImltcG9ydCBfY3VycnkzIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTMuanNcIjtcbi8qKlxuICogUmVzdHJpY3RzIGEgbnVtYmVyIHRvIGJlIHdpdGhpbiBhIHJhbmdlLlxuICpcbiAqIEFsc28gd29ya3MgZm9yIG90aGVyIG9yZGVyZWQgdHlwZXMgc3VjaCBhcyBTdHJpbmdzIGFuZCBEYXRlcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yMC4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IGEgLT4gYVxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbmltdW0gVGhlIGxvd2VyIGxpbWl0IG9mIHRoZSBjbGFtcCAoaW5jbHVzaXZlKVxuICogQHBhcmFtIHtOdW1iZXJ9IG1heGltdW0gVGhlIHVwcGVyIGxpbWl0IG9mIHRoZSBjbGFtcCAoaW5jbHVzaXZlKVxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFZhbHVlIHRvIGJlIGNsYW1wZWRcbiAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyBgbWluaW11bWAgd2hlbiBgdmFsIDwgbWluaW11bWAsIGBtYXhpbXVtYCB3aGVuIGB2YWwgPiBtYXhpbXVtYCwgcmV0dXJucyBgdmFsYCBvdGhlcndpc2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmNsYW1wKDEsIDEwLCAtNSkgLy8gPT4gMVxuICogICAgICBSLmNsYW1wKDEsIDEwLCAxNSkgLy8gPT4gMTBcbiAqICAgICAgUi5jbGFtcCgxLCAxMCwgNCkgIC8vID0+IDRcbiAqL1xuXG52YXIgY2xhbXAgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MyhmdW5jdGlvbiBjbGFtcChtaW4sIG1heCwgdmFsdWUpIHtcbiAgaWYgKG1pbiA+IG1heCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWluIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiBtYXggaW4gY2xhbXAobWluLCBtYXgsIHZhbHVlKScpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlIDwgbWluID8gbWluIDogdmFsdWUgPiBtYXggPyBtYXggOiB2YWx1ZTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFtcDsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY2xvbmVSZWdFeHAocGF0dGVybikge1xuICByZXR1cm4gbmV3IFJlZ0V4cChwYXR0ZXJuLnNvdXJjZSwgKHBhdHRlcm4uZ2xvYmFsID8gJ2cnIDogJycpICsgKHBhdHRlcm4uaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArIChwYXR0ZXJuLm11bHRpbGluZSA/ICdtJyA6ICcnKSArIChwYXR0ZXJuLnN0aWNreSA/ICd5JyA6ICcnKSArIChwYXR0ZXJuLnVuaWNvZGUgPyAndScgOiAnJykpO1xufSIsImltcG9ydCBfY3VycnkxIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTEuanNcIjtcbi8qKlxuICogR2l2ZXMgYSBzaW5nbGUtd29yZCBzdHJpbmcgZGVzY3JpcHRpb24gb2YgdGhlIChuYXRpdmUpIHR5cGUgb2YgYSB2YWx1ZSxcbiAqIHJldHVybmluZyBzdWNoIGFuc3dlcnMgYXMgJ09iamVjdCcsICdOdW1iZXInLCAnQXJyYXknLCBvciAnTnVsbCcuIERvZXMgbm90XG4gKiBhdHRlbXB0IHRvIGRpc3Rpbmd1aXNoIHVzZXIgT2JqZWN0IHR5cGVzIGFueSBmdXJ0aGVyLCByZXBvcnRpbmcgdGhlbSBhbGwgYXNcbiAqICdPYmplY3QnLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjguMFxuICogQGNhdGVnb3J5IFR5cGVcbiAqIEBzaWcgKCogLT4geyp9KSAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7Kn0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50eXBlKHt9KTsgLy89PiBcIk9iamVjdFwiXG4gKiAgICAgIFIudHlwZSgxKTsgLy89PiBcIk51bWJlclwiXG4gKiAgICAgIFIudHlwZShmYWxzZSk7IC8vPT4gXCJCb29sZWFuXCJcbiAqICAgICAgUi50eXBlKCdzJyk7IC8vPT4gXCJTdHJpbmdcIlxuICogICAgICBSLnR5cGUobnVsbCk7IC8vPT4gXCJOdWxsXCJcbiAqICAgICAgUi50eXBlKFtdKTsgLy89PiBcIkFycmF5XCJcbiAqICAgICAgUi50eXBlKC9bQS16XS8pOyAvLz0+IFwiUmVnRXhwXCJcbiAqICAgICAgUi50eXBlKCgpID0+IHt9KTsgLy89PiBcIkZ1bmN0aW9uXCJcbiAqICAgICAgUi50eXBlKHVuZGVmaW5lZCk7IC8vPT4gXCJVbmRlZmluZWRcIlxuICovXG5cbnZhciB0eXBlID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoZnVuY3Rpb24gdHlwZSh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PT0gbnVsbCA/ICdOdWxsJyA6IHZhbCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKS5zbGljZSg4LCAtMSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdHlwZTsiLCJpbXBvcnQgX2Nsb25lUmVnRXhwIGZyb20gXCIuL19jbG9uZVJlZ0V4cC5qc1wiO1xuaW1wb3J0IHR5cGUgZnJvbSBcIi4uL3R5cGUuanNcIjtcbi8qKlxuICogQ29waWVzIGFuIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgY29waWVkXG4gKiBAcGFyYW0ge0FycmF5fSByZWZGcm9tIEFycmF5IGNvbnRhaW5pbmcgdGhlIHNvdXJjZSByZWZlcmVuY2VzXG4gKiBAcGFyYW0ge0FycmF5fSByZWZUbyBBcnJheSBjb250YWluaW5nIHRoZSBjb3BpZWQgc291cmNlIHJlZmVyZW5jZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVlcCBXaGV0aGVyIG9yIG5vdCB0byBwZXJmb3JtIGRlZXAgY2xvbmluZy5cbiAqIEByZXR1cm4geyp9IFRoZSBjb3BpZWQgdmFsdWUuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2Nsb25lKHZhbHVlLCByZWZGcm9tLCByZWZUbywgZGVlcCkge1xuICB2YXIgY29weSA9IGZ1bmN0aW9uIGNvcHkoY29waWVkVmFsdWUpIHtcbiAgICB2YXIgbGVuID0gcmVmRnJvbS5sZW5ndGg7XG4gICAgdmFyIGlkeCA9IDA7XG5cbiAgICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgICBpZiAodmFsdWUgPT09IHJlZkZyb21baWR4XSkge1xuICAgICAgICByZXR1cm4gcmVmVG9baWR4XTtcbiAgICAgIH1cblxuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuXG4gICAgcmVmRnJvbVtpZHggKyAxXSA9IHZhbHVlO1xuICAgIHJlZlRvW2lkeCArIDFdID0gY29waWVkVmFsdWU7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgIGNvcGllZFZhbHVlW2tleV0gPSBkZWVwID8gX2Nsb25lKHZhbHVlW2tleV0sIHJlZkZyb20sIHJlZlRvLCB0cnVlKSA6IHZhbHVlW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvcGllZFZhbHVlO1xuICB9O1xuXG4gIHN3aXRjaCAodHlwZSh2YWx1ZSkpIHtcbiAgICBjYXNlICdPYmplY3QnOlxuICAgICAgcmV0dXJuIGNvcHkoe30pO1xuXG4gICAgY2FzZSAnQXJyYXknOlxuICAgICAgcmV0dXJuIGNvcHkoW10pO1xuXG4gICAgY2FzZSAnRGF0ZSc6XG4gICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUudmFsdWVPZigpKTtcblxuICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgICByZXR1cm4gX2Nsb25lUmVnRXhwKHZhbHVlKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn0iLCJpbXBvcnQgX2Nsb25lIGZyb20gXCIuL2ludGVybmFsL19jbG9uZS5qc1wiO1xuaW1wb3J0IF9jdXJyeTEgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5MS5qc1wiO1xuLyoqXG4gKiBDcmVhdGVzIGEgZGVlcCBjb3B5IG9mIHRoZSB2YWx1ZSB3aGljaCBtYXkgY29udGFpbiAobmVzdGVkKSBgQXJyYXlgcyBhbmRcbiAqIGBPYmplY3RgcywgYE51bWJlcmBzLCBgU3RyaW5nYHMsIGBCb29sZWFuYHMgYW5kIGBEYXRlYHMuIGBGdW5jdGlvbmBzIGFyZVxuICogYXNzaWduZWQgYnkgcmVmZXJlbmNlIHJhdGhlciB0aGFuIGNvcGllZFxuICpcbiAqIERpc3BhdGNoZXMgdG8gYSBgY2xvbmVgIG1ldGhvZCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7Kn0gLT4geyp9XG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gY2xvbmVcbiAqIEByZXR1cm4geyp9IEEgZGVlcGx5IGNsb25lZCBjb3B5IG9mIGB2YWxgXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3Qgb2JqZWN0cyA9IFt7fSwge30sIHt9XTtcbiAqICAgICAgY29uc3Qgb2JqZWN0c0Nsb25lID0gUi5jbG9uZShvYmplY3RzKTtcbiAqICAgICAgb2JqZWN0cyA9PT0gb2JqZWN0c0Nsb25lOyAvLz0+IGZhbHNlXG4gKiAgICAgIG9iamVjdHNbMF0gPT09IG9iamVjdHNDbG9uZVswXTsgLy89PiBmYWxzZVxuICovXG5cbnZhciBjbG9uZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKGZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS5jbG9uZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLmNsb25lKCkgOiBfY2xvbmUodmFsdWUsIFtdLCBbXSwgdHJ1ZSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY2xvbmU7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5MS5qc1wiO1xuLyoqXG4gKiBNYWtlcyBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gb3V0IG9mIGEgZnVuY3Rpb24gdGhhdCByZXBvcnRzIHdoZXRoZXIgdGhlIGZpcnN0XG4gKiBlbGVtZW50IGlzIGxlc3MgdGhhbiB0aGUgc2Vjb25kLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgoYSwgYikgLT4gQm9vbGVhbikgLT4gKChhLCBiKSAtPiBOdW1iZXIpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIGZ1bmN0aW9uIG9mIGFyaXR5IHR3byB3aGljaCB3aWxsIHJldHVybiBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBpcyBsZXNzIHRoYW4gdGhlIHNlY29uZCwgYGZhbHNlYCBvdGhlcndpc2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIEZ1bmN0aW9uIDo6IGEgLT4gYiAtPiBJbnQgdGhhdCByZXR1cm5zIGAtMWAgaWYgYSA8IGIsIGAxYCBpZiBiIDwgYSwgb3RoZXJ3aXNlIGAwYFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGJ5QWdlID0gUi5jb21wYXJhdG9yKChhLCBiKSA9PiBhLmFnZSA8IGIuYWdlKTtcbiAqICAgICAgY29uc3QgcGVvcGxlID0gW1xuICogICAgICAgIHsgbmFtZTogJ0VtbWEnLCBhZ2U6IDcwIH0sXG4gKiAgICAgICAgeyBuYW1lOiAnUGV0ZXInLCBhZ2U6IDc4IH0sXG4gKiAgICAgICAgeyBuYW1lOiAnTWlraGFpbCcsIGFnZTogNjIgfSxcbiAqICAgICAgXTtcbiAqICAgICAgY29uc3QgcGVvcGxlQnlJbmNyZWFzaW5nQWdlID0gUi5zb3J0KGJ5QWdlLCBwZW9wbGUpO1xuICogICAgICAgIC8vPT4gW3sgbmFtZTogJ01pa2hhaWwnLCBhZ2U6IDYyIH0seyBuYW1lOiAnRW1tYScsIGFnZTogNzAgfSwgeyBuYW1lOiAnUGV0ZXInLCBhZ2U6IDc4IH1dXG4gKi9cblxudmFyIGNvbXBhcmF0b3IgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiBjb21wYXJhdG9yKHByZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIHByZWQoYSwgYikgPyAtMSA6IHByZWQoYiwgYSkgPyAxIDogMDtcbiAgfTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBjb21wYXJhdG9yOyIsImltcG9ydCBfY3VycnkxIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTEuanNcIjtcbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGAhYCBvZiBpdHMgYXJndW1lbnQuIEl0IHdpbGwgcmV0dXJuIGB0cnVlYCB3aGVuXG4gKiBwYXNzZWQgZmFsc2UteSB2YWx1ZSwgYW5kIGBmYWxzZWAgd2hlbiBwYXNzZWQgYSB0cnV0aC15IG9uZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyAqIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0gYSBhbnkgdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRoZSBsb2dpY2FsIGludmVyc2Ugb2YgcGFzc2VkIGFyZ3VtZW50LlxuICogQHNlZSBSLmNvbXBsZW1lbnRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm5vdCh0cnVlKTsgLy89PiBmYWxzZVxuICogICAgICBSLm5vdChmYWxzZSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLm5vdCgwKTsgLy89PiB0cnVlXG4gKiAgICAgIFIubm90KDEpOyAvLz0+IGZhbHNlXG4gKi9cblxudmFyIG5vdCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKGZ1bmN0aW9uIG5vdChhKSB7XG4gIHJldHVybiAhYTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBub3Q7IiwiaW1wb3J0IGxpZnQgZnJvbSBcIi4vbGlmdC5qc1wiO1xuaW1wb3J0IG5vdCBmcm9tIFwiLi9ub3QuanNcIjtcbi8qKlxuICogVGFrZXMgYSBmdW5jdGlvbiBgZmAgYW5kIHJldHVybnMgYSBmdW5jdGlvbiBgZ2Agc3VjaCB0aGF0IGlmIGNhbGxlZCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50c1xuICogd2hlbiBgZmAgcmV0dXJucyBhIFwidHJ1dGh5XCIgdmFsdWUsIGBnYCByZXR1cm5zIGBmYWxzZWAgYW5kIHdoZW4gYGZgIHJldHVybnMgYSBcImZhbHN5XCIgdmFsdWUgYGdgIHJldHVybnMgYHRydWVgLlxuICpcbiAqIGBSLmNvbXBsZW1lbnRgIG1heSBiZSBhcHBsaWVkIHRvIGFueSBmdW5jdG9yXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTIuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnICgqLi4uIC0+ICopIC0+ICgqLi4uIC0+IEJvb2xlYW4pXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzZWUgUi5ub3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBpc05vdE5pbCA9IFIuY29tcGxlbWVudChSLmlzTmlsKTtcbiAqICAgICAgaXNOaWwobnVsbCk7IC8vPT4gdHJ1ZVxuICogICAgICBpc05vdE5pbChudWxsKTsgLy89PiBmYWxzZVxuICogICAgICBpc05pbCg3KTsgLy89PiBmYWxzZVxuICogICAgICBpc05vdE5pbCg3KTsgLy89PiB0cnVlXG4gKi9cblxudmFyIGNvbXBsZW1lbnQgPVxuLyojX19QVVJFX18qL1xubGlmdChub3QpO1xuZXhwb3J0IGRlZmF1bHQgY29tcGxlbWVudDsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfcGlwZShmLCBnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGcuY2FsbCh0aGlzLCBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9O1xufSIsImltcG9ydCBfaXNBcnJheSBmcm9tIFwiLi9faXNBcnJheS5qc1wiO1xuLyoqXG4gKiBUaGlzIGNoZWNrcyB3aGV0aGVyIGEgZnVuY3Rpb24gaGFzIGEgW21ldGhvZG5hbWVdIGZ1bmN0aW9uLiBJZiBpdCBpc24ndCBhblxuICogYXJyYXkgaXQgd2lsbCBleGVjdXRlIHRoYXQgZnVuY3Rpb24gb3RoZXJ3aXNlIGl0IHdpbGwgZGVmYXVsdCB0byB0aGUgcmFtZGFcbiAqIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiByYW1kYSBpbXBsZW10YXRpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RuYW1lIHByb3BlcnR5IHRvIGNoZWNrIGZvciBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICogQHJldHVybiB7T2JqZWN0fSBXaGF0ZXZlciB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBtZXRob2QgaXMuXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NoZWNrRm9yTWV0aG9kKG1ldGhvZG5hbWUsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9XG5cbiAgICB2YXIgb2JqID0gYXJndW1lbnRzW2xlbmd0aCAtIDFdO1xuICAgIHJldHVybiBfaXNBcnJheShvYmopIHx8IHR5cGVvZiBvYmpbbWV0aG9kbmFtZV0gIT09ICdmdW5jdGlvbicgPyBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogb2JqW21ldGhvZG5hbWVdLmFwcGx5KG9iaiwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCBsZW5ndGggLSAxKSk7XG4gIH07XG59IiwiaW1wb3J0IF9jaGVja0Zvck1ldGhvZCBmcm9tIFwiLi9pbnRlcm5hbC9fY2hlY2tGb3JNZXRob2QuanNcIjtcbmltcG9ydCBfY3VycnkzIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTMuanNcIjtcbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nIChvciBvYmplY3Qgd2l0aCBhIGBzbGljZWBcbiAqIG1ldGhvZCkgZnJvbSBgZnJvbUluZGV4YCAoaW5jbHVzaXZlKSB0byBgdG9JbmRleGAgKGV4Y2x1c2l2ZSkuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYHNsaWNlYCBtZXRob2Qgb2YgdGhlIHRoaXJkIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuNFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBbYV0gLT4gW2FdXG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IGZyb21JbmRleCBUaGUgc3RhcnQgaW5kZXggKGluY2x1c2l2ZSkuXG4gKiBAcGFyYW0ge051bWJlcn0gdG9JbmRleCBUaGUgZW5kIGluZGV4IChleGNsdXNpdmUpLlxuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuc2xpY2UoMSwgMywgWydhJywgJ2InLCAnYycsICdkJ10pOyAgICAgICAgLy89PiBbJ2InLCAnYyddXG4gKiAgICAgIFIuc2xpY2UoMSwgSW5maW5pdHksIFsnYScsICdiJywgJ2MnLCAnZCddKTsgLy89PiBbJ2InLCAnYycsICdkJ11cbiAqICAgICAgUi5zbGljZSgwLCAtMSwgWydhJywgJ2InLCAnYycsICdkJ10pOyAgICAgICAvLz0+IFsnYScsICdiJywgJ2MnXVxuICogICAgICBSLnNsaWNlKC0zLCAtMSwgWydhJywgJ2InLCAnYycsICdkJ10pOyAgICAgIC8vPT4gWydiJywgJ2MnXVxuICogICAgICBSLnNsaWNlKDAsIDMsICdyYW1kYScpOyAgICAgICAgICAgICAgICAgICAgIC8vPT4gJ3JhbSdcbiAqL1xuXG52YXIgc2xpY2UgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5Myhcbi8qI19fUFVSRV9fKi9cbl9jaGVja0Zvck1ldGhvZCgnc2xpY2UnLCBmdW5jdGlvbiBzbGljZShmcm9tSW5kZXgsIHRvSW5kZXgsIGxpc3QpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIGZyb21JbmRleCwgdG9JbmRleCk7XG59KSk7XG5cbmV4cG9ydCBkZWZhdWx0IHNsaWNlOyIsImltcG9ydCBfY2hlY2tGb3JNZXRob2QgZnJvbSBcIi4vaW50ZXJuYWwvX2NoZWNrRm9yTWV0aG9kLmpzXCI7XG5pbXBvcnQgX2N1cnJ5MSBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkxLmpzXCI7XG5pbXBvcnQgc2xpY2UgZnJvbSBcIi4vc2xpY2UuanNcIjtcbi8qKlxuICogUmV0dXJucyBhbGwgYnV0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBsaXN0IG9yIHN0cmluZyAob3Igb2JqZWN0XG4gKiB3aXRoIGEgYHRhaWxgIG1ldGhvZCkuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYHNsaWNlYCBtZXRob2Qgb2YgdGhlIGZpcnN0IGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IFthXVxuICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0geyp9IGxpc3RcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIuaGVhZCwgUi5pbml0LCBSLmxhc3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRhaWwoWzEsIDIsIDNdKTsgIC8vPT4gWzIsIDNdXG4gKiAgICAgIFIudGFpbChbMSwgMl0pOyAgICAgLy89PiBbMl1cbiAqICAgICAgUi50YWlsKFsxXSk7ICAgICAgICAvLz0+IFtdXG4gKiAgICAgIFIudGFpbChbXSk7ICAgICAgICAgLy89PiBbXVxuICpcbiAqICAgICAgUi50YWlsKCdhYmMnKTsgIC8vPT4gJ2JjJ1xuICogICAgICBSLnRhaWwoJ2FiJyk7ICAgLy89PiAnYidcbiAqICAgICAgUi50YWlsKCdhJyk7ICAgIC8vPT4gJydcbiAqICAgICAgUi50YWlsKCcnKTsgICAgIC8vPT4gJydcbiAqL1xuXG52YXIgdGFpbCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKFxuLyojX19QVVJFX18qL1xuX2NoZWNrRm9yTWV0aG9kKCd0YWlsJyxcbi8qI19fUFVSRV9fKi9cbnNsaWNlKDEsIEluZmluaXR5KSkpO1xuXG5leHBvcnQgZGVmYXVsdCB0YWlsOyIsImltcG9ydCBfYXJpdHkgZnJvbSBcIi4vaW50ZXJuYWwvX2FyaXR5LmpzXCI7XG5pbXBvcnQgX3BpcGUgZnJvbSBcIi4vaW50ZXJuYWwvX3BpcGUuanNcIjtcbmltcG9ydCByZWR1Y2UgZnJvbSBcIi4vcmVkdWNlLmpzXCI7XG5pbXBvcnQgdGFpbCBmcm9tIFwiLi90YWlsLmpzXCI7XG4vKipcbiAqIFBlcmZvcm1zIGxlZnQtdG8tcmlnaHQgZnVuY3Rpb24gY29tcG9zaXRpb24uIFRoZSBmaXJzdCBhcmd1bWVudCBtYXkgaGF2ZVxuICogYW55IGFyaXR5OyB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cyBtdXN0IGJlIHVuYXJ5LlxuICpcbiAqIEluIHNvbWUgbGlicmFyaWVzIHRoaXMgZnVuY3Rpb24gaXMgbmFtZWQgYHNlcXVlbmNlYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIHJlc3VsdCBvZiBwaXBlIGlzIG5vdCBhdXRvbWF0aWNhbGx5IGN1cnJpZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKCgoYSwgYiwgLi4uLCBuKSAtPiBvKSwgKG8gLT4gcCksIC4uLiwgKHggLT4geSksICh5IC0+IHopKSAtPiAoKGEsIGIsIC4uLiwgbikgLT4geilcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IGZ1bmN0aW9uc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIuY29tcG9zZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGYgPSBSLnBpcGUoTWF0aC5wb3csIFIubmVnYXRlLCBSLmluYyk7XG4gKlxuICogICAgICBmKDMsIDQpOyAvLyAtKDNeNCkgKyAxXG4gKiBAc3ltYiBSLnBpcGUoZiwgZywgaCkoYSwgYikgPSBoKGcoZihhLCBiKSkpXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGlwZSgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BpcGUgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50Jyk7XG4gIH1cblxuICByZXR1cm4gX2FyaXR5KGFyZ3VtZW50c1swXS5sZW5ndGgsIHJlZHVjZShfcGlwZSwgYXJndW1lbnRzWzBdLCB0YWlsKGFyZ3VtZW50cykpKTtcbn0iLCJpbXBvcnQgX2N1cnJ5MSBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkxLmpzXCI7XG5pbXBvcnQgX2lzU3RyaW5nIGZyb20gXCIuL2ludGVybmFsL19pc1N0cmluZy5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3Qgb3Igc3RyaW5nIHdpdGggdGhlIGVsZW1lbnRzIG9yIGNoYXJhY3RlcnMgaW4gcmV2ZXJzZVxuICogb3JkZXIuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2FdXG4gKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBsaXN0XG4gKiBAcmV0dXJuIHtBcnJheXxTdHJpbmd9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5yZXZlcnNlKFsxLCAyLCAzXSk7ICAvLz0+IFszLCAyLCAxXVxuICogICAgICBSLnJldmVyc2UoWzEsIDJdKTsgICAgIC8vPT4gWzIsIDFdXG4gKiAgICAgIFIucmV2ZXJzZShbMV0pOyAgICAgICAgLy89PiBbMV1cbiAqICAgICAgUi5yZXZlcnNlKFtdKTsgICAgICAgICAvLz0+IFtdXG4gKlxuICogICAgICBSLnJldmVyc2UoJ2FiYycpOyAgICAgIC8vPT4gJ2NiYSdcbiAqICAgICAgUi5yZXZlcnNlKCdhYicpOyAgICAgICAvLz0+ICdiYSdcbiAqICAgICAgUi5yZXZlcnNlKCdhJyk7ICAgICAgICAvLz0+ICdhJ1xuICogICAgICBSLnJldmVyc2UoJycpOyAgICAgICAgIC8vPT4gJydcbiAqL1xuXG52YXIgcmV2ZXJzZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKGZ1bmN0aW9uIHJldmVyc2UobGlzdCkge1xuICByZXR1cm4gX2lzU3RyaW5nKGxpc3QpID8gbGlzdC5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCkucmV2ZXJzZSgpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJldmVyc2U7IiwiaW1wb3J0IHBpcGUgZnJvbSBcIi4vcGlwZS5qc1wiO1xuaW1wb3J0IHJldmVyc2UgZnJvbSBcIi4vcmV2ZXJzZS5qc1wiO1xuLyoqXG4gKiBQZXJmb3JtcyByaWdodC10by1sZWZ0IGZ1bmN0aW9uIGNvbXBvc2l0aW9uLiBUaGUgbGFzdCBhcmd1bWVudCBtYXkgaGF2ZVxuICogYW55IGFyaXR5OyB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cyBtdXN0IGJlIHVuYXJ5LlxuICpcbiAqICoqTm90ZToqKiBUaGUgcmVzdWx0IG9mIGNvbXBvc2UgaXMgbm90IGF1dG9tYXRpY2FsbHkgY3VycmllZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKHkgLT4geiksICh4IC0+IHkpLCAuLi4sIChvIC0+IHApLCAoKGEsIGIsIC4uLiwgbikgLT4gbykpIC0+ICgoYSwgYiwgLi4uLCBuKSAtPiB6KVxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gLi4uZnVuY3Rpb25zIFRoZSBmdW5jdGlvbnMgdG8gY29tcG9zZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIucGlwZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGNsYXNzeUdyZWV0aW5nID0gKGZpcnN0TmFtZSwgbGFzdE5hbWUpID0+IFwiVGhlIG5hbWUncyBcIiArIGxhc3ROYW1lICsgXCIsIFwiICsgZmlyc3ROYW1lICsgXCIgXCIgKyBsYXN0TmFtZVxuICogICAgICBjb25zdCB5ZWxsR3JlZXRpbmcgPSBSLmNvbXBvc2UoUi50b1VwcGVyLCBjbGFzc3lHcmVldGluZyk7XG4gKiAgICAgIHllbGxHcmVldGluZygnSmFtZXMnLCAnQm9uZCcpOyAvLz0+IFwiVEhFIE5BTUUnUyBCT05ELCBKQU1FUyBCT05EXCJcbiAqXG4gKiAgICAgIFIuY29tcG9zZShNYXRoLmFicywgUi5hZGQoMSksIFIubXVsdGlwbHkoMikpKC00KSAvLz0+IDdcbiAqXG4gKiBAc3ltYiBSLmNvbXBvc2UoZiwgZywgaCkoYSwgYikgPSBmKGcoaChhLCBiKSkpXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcG9zZSgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXBvc2UgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50Jyk7XG4gIH1cblxuICByZXR1cm4gcGlwZS5hcHBseSh0aGlzLCByZXZlcnNlKGFyZ3VtZW50cykpO1xufSIsImltcG9ydCBjaGFpbiBmcm9tIFwiLi9jaGFpbi5qc1wiO1xuaW1wb3J0IGNvbXBvc2UgZnJvbSBcIi4vY29tcG9zZS5qc1wiO1xuaW1wb3J0IG1hcCBmcm9tIFwiLi9tYXAuanNcIjtcbi8qKlxuICogUmV0dXJucyB0aGUgcmlnaHQtdG8tbGVmdCBLbGVpc2xpIGNvbXBvc2l0aW9uIG9mIHRoZSBwcm92aWRlZCBmdW5jdGlvbnMsXG4gKiBlYWNoIG9mIHdoaWNoIG11c3QgcmV0dXJuIGEgdmFsdWUgb2YgYSB0eXBlIHN1cHBvcnRlZCBieSBbYGNoYWluYF0oI2NoYWluKS5cbiAqXG4gKiBgUi5jb21wb3NlSyhoLCBnLCBmKWAgaXMgZXF1aXZhbGVudCB0byBgUi5jb21wb3NlKFIuY2hhaW4oaCksIFIuY2hhaW4oZyksIGYpYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgQ2hhaW4gbSA9PiAoKHkgLT4gbSB6KSwgKHggLT4gbSB5KSwgLi4uLCAoYSAtPiBtIGIpKSAtPiAoYSAtPiBtIHopXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSAuLi5mdW5jdGlvbnMgVGhlIGZ1bmN0aW9ucyB0byBjb21wb3NlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzZWUgUi5waXBlS1xuICogQGRlcHJlY2F0ZWQgc2luY2UgdjAuMjYuMFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgICAvLyAgZ2V0IDo6IFN0cmluZyAtPiBPYmplY3QgLT4gTWF5YmUgKlxuICogICAgICAgY29uc3QgZ2V0ID0gUi5jdXJyeSgocHJvcE5hbWUsIG9iaikgPT4gTWF5YmUob2JqW3Byb3BOYW1lXSkpXG4gKlxuICogICAgICAgLy8gIGdldFN0YXRlQ29kZSA6OiBNYXliZSBTdHJpbmcgLT4gTWF5YmUgU3RyaW5nXG4gKiAgICAgICBjb25zdCBnZXRTdGF0ZUNvZGUgPSBSLmNvbXBvc2VLKFxuICogICAgICAgICBSLmNvbXBvc2UoTWF5YmUub2YsIFIudG9VcHBlciksXG4gKiAgICAgICAgIGdldCgnc3RhdGUnKSxcbiAqICAgICAgICAgZ2V0KCdhZGRyZXNzJyksXG4gKiAgICAgICAgIGdldCgndXNlcicpLFxuICogICAgICAgKTtcbiAqICAgICAgIGdldFN0YXRlQ29kZSh7XCJ1c2VyXCI6e1wiYWRkcmVzc1wiOntcInN0YXRlXCI6XCJueVwifX19KTsgLy89PiBNYXliZS5KdXN0KFwiTllcIilcbiAqICAgICAgIGdldFN0YXRlQ29kZSh7fSk7IC8vPT4gTWF5YmUuTm90aGluZygpXG4gKiBAc3ltYiBSLmNvbXBvc2VLKGYsIGcsIGgpKGEpID0gUi5jaGFpbihmLCBSLmNoYWluKGcsIGgoYSkpKVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBvc2VLKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY29tcG9zZUsgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50Jyk7XG4gIH1cblxuICB2YXIgaW5pdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gIHZhciBsYXN0ID0gaW5pdC5wb3AoKTtcbiAgcmV0dXJuIGNvbXBvc2UoY29tcG9zZS5hcHBseSh0aGlzLCBtYXAoY2hhaW4sIGluaXQpKSwgbGFzdCk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3BpcGVQKGYsIGcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3R4ID0gdGhpcztcbiAgICByZXR1cm4gZi5hcHBseShjdHgsIGFyZ3VtZW50cykudGhlbihmdW5jdGlvbiAoeCkge1xuICAgICAgcmV0dXJuIGcuY2FsbChjdHgsIHgpO1xuICAgIH0pO1xuICB9O1xufSIsImltcG9ydCBfYXJpdHkgZnJvbSBcIi4vaW50ZXJuYWwvX2FyaXR5LmpzXCI7XG5pbXBvcnQgX3BpcGVQIGZyb20gXCIuL2ludGVybmFsL19waXBlUC5qc1wiO1xuaW1wb3J0IHJlZHVjZSBmcm9tIFwiLi9yZWR1Y2UuanNcIjtcbmltcG9ydCB0YWlsIGZyb20gXCIuL3RhaWwuanNcIjtcbi8qKlxuICogUGVyZm9ybXMgbGVmdC10by1yaWdodCBjb21wb3NpdGlvbiBvZiBvbmUgb3IgbW9yZSBQcm9taXNlLXJldHVybmluZ1xuICogZnVuY3Rpb25zLiBUaGUgZmlyc3QgYXJndW1lbnQgbWF5IGhhdmUgYW55IGFyaXR5OyB0aGUgcmVtYWluaW5nIGFyZ3VtZW50c1xuICogbXVzdCBiZSB1bmFyeS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKChhIC0+IFByb21pc2UgYiksIChiIC0+IFByb21pc2UgYyksIC4uLiwgKHkgLT4gUHJvbWlzZSB6KSkgLT4gKGEgLT4gUHJvbWlzZSB6KVxuICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gZnVuY3Rpb25zXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzZWUgUi5jb21wb3NlUFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdjAuMjYuMFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIC8vICBmb2xsb3dlcnNGb3JVc2VyIDo6IFN0cmluZyAtPiBQcm9taXNlIFtVc2VyXVxuICogICAgICBjb25zdCBmb2xsb3dlcnNGb3JVc2VyID0gUi5waXBlUChkYi5nZXRVc2VyQnlJZCwgZGIuZ2V0Rm9sbG93ZXJzKTtcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwaXBlUCgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3BpcGVQIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhcmd1bWVudCcpO1xuICB9XG5cbiAgcmV0dXJuIF9hcml0eShhcmd1bWVudHNbMF0ubGVuZ3RoLCByZWR1Y2UoX3BpcGVQLCBhcmd1bWVudHNbMF0sIHRhaWwoYXJndW1lbnRzKSkpO1xufSIsImltcG9ydCBwaXBlUCBmcm9tIFwiLi9waXBlUC5qc1wiO1xuaW1wb3J0IHJldmVyc2UgZnJvbSBcIi4vcmV2ZXJzZS5qc1wiO1xuLyoqXG4gKiBQZXJmb3JtcyByaWdodC10by1sZWZ0IGNvbXBvc2l0aW9uIG9mIG9uZSBvciBtb3JlIFByb21pc2UtcmV0dXJuaW5nXG4gKiBmdW5jdGlvbnMuIFRoZSBsYXN0IGFyZ3VtZW50cyBtYXkgaGF2ZSBhbnkgYXJpdHk7IHRoZSByZW1haW5pbmdcbiAqIGFyZ3VtZW50cyBtdXN0IGJlIHVuYXJ5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKHkgLT4gUHJvbWlzZSB6KSwgKHggLT4gUHJvbWlzZSB5KSwgLi4uLCAoYSAtPiBQcm9taXNlIGIpKSAtPiAoYSAtPiBQcm9taXNlIHopXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jdGlvbnMgVGhlIGZ1bmN0aW9ucyB0byBjb21wb3NlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzZWUgUi5waXBlUFxuICogQGRlcHJlY2F0ZWQgc2luY2UgdjAuMjYuMFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGRiID0ge1xuICogICAgICAgIHVzZXJzOiB7XG4gKiAgICAgICAgICBKT0U6IHtcbiAqICAgICAgICAgICAgbmFtZTogJ0pvZScsXG4gKiAgICAgICAgICAgIGZvbGxvd2VyczogWydTVEVWRScsICdTVVpZJ11cbiAqICAgICAgICAgIH1cbiAqICAgICAgICB9XG4gKiAgICAgIH1cbiAqXG4gKiAgICAgIC8vIFdlJ2xsIHByZXRlbmQgdG8gZG8gYSBkYiBsb29rdXAgd2hpY2ggcmV0dXJucyBhIHByb21pc2VcbiAqICAgICAgY29uc3QgbG9va3VwVXNlciA9ICh1c2VySWQpID0+IFByb21pc2UucmVzb2x2ZShkYi51c2Vyc1t1c2VySWRdKVxuICogICAgICBjb25zdCBsb29rdXBGb2xsb3dlcnMgPSAodXNlcikgPT4gUHJvbWlzZS5yZXNvbHZlKHVzZXIuZm9sbG93ZXJzKVxuICogICAgICBsb29rdXBVc2VyKCdKT0UnKS50aGVuKGxvb2t1cEZvbGxvd2VycylcbiAqXG4gKiAgICAgIC8vICBmb2xsb3dlcnNGb3JVc2VyIDo6IFN0cmluZyAtPiBQcm9taXNlIFtVc2VySWRdXG4gKiAgICAgIGNvbnN0IGZvbGxvd2Vyc0ZvclVzZXIgPSBSLmNvbXBvc2VQKGxvb2t1cEZvbGxvd2VycywgbG9va3VwVXNlcik7XG4gKiAgICAgIGZvbGxvd2Vyc0ZvclVzZXIoJ0pPRScpLnRoZW4oZm9sbG93ZXJzID0+IGNvbnNvbGUubG9nKCdGb2xsb3dlcnM6JywgZm9sbG93ZXJzKSlcbiAqICAgICAgLy8gRm9sbG93ZXJzOiBbXCJTVEVWRVwiLFwiU1VaWVwiXVxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXBvc2VQKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY29tcG9zZVAgcmVxdWlyZXMgYXQgbGVhc3Qgb25lIGFyZ3VtZW50Jyk7XG4gIH1cblxuICByZXR1cm4gcGlwZVAuYXBwbHkodGhpcywgcmV2ZXJzZShhcmd1bWVudHMpKTtcbn0iLCJpbXBvcnQgbnRoIGZyb20gXCIuL250aC5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBnaXZlbiBsaXN0IG9yIHN0cmluZy4gSW4gc29tZSBsaWJyYXJpZXNcbiAqIHRoaXMgZnVuY3Rpb24gaXMgbmFtZWQgYGZpcnN0YC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBhIHwgVW5kZWZpbmVkXG4gKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLnRhaWwsIFIuaW5pdCwgUi5sYXN0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5oZWFkKFsnZmknLCAnZm8nLCAnZnVtJ10pOyAvLz0+ICdmaSdcbiAqICAgICAgUi5oZWFkKFtdKTsgLy89PiB1bmRlZmluZWRcbiAqXG4gKiAgICAgIFIuaGVhZCgnYWJjJyk7IC8vPT4gJ2EnXG4gKiAgICAgIFIuaGVhZCgnJyk7IC8vPT4gJydcbiAqL1xuXG52YXIgaGVhZCA9XG4vKiNfX1BVUkVfXyovXG5udGgoMCk7XG5leHBvcnQgZGVmYXVsdCBoZWFkOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufSIsImltcG9ydCBfY3VycnkxIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTEuanNcIjtcbmltcG9ydCBfaWRlbnRpdHkgZnJvbSBcIi4vaW50ZXJuYWwvX2lkZW50aXR5LmpzXCI7XG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCBkb2VzIG5vdGhpbmcgYnV0IHJldHVybiB0aGUgcGFyYW1ldGVyIHN1cHBsaWVkIHRvIGl0LiBHb29kXG4gKiBhcyBhIGRlZmF1bHQgb3IgcGxhY2Vob2xkZXIgZnVuY3Rpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgYSAtPiBhXG4gKiBAcGFyYW0geyp9IHggVGhlIHZhbHVlIHRvIHJldHVybi5cbiAqIEByZXR1cm4geyp9IFRoZSBpbnB1dCB2YWx1ZSwgYHhgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaWRlbnRpdHkoMSk7IC8vPT4gMVxuICpcbiAqICAgICAgY29uc3Qgb2JqID0ge307XG4gKiAgICAgIFIuaWRlbnRpdHkob2JqKSA9PT0gb2JqOyAvLz0+IHRydWVcbiAqIEBzeW1iIFIuaWRlbnRpdHkoYSkgPSBhXG4gKi9cblxudmFyIGlkZW50aXR5ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoX2lkZW50aXR5KTtcblxuZXhwb3J0IGRlZmF1bHQgaWRlbnRpdHk7IiwiaW1wb3J0IF9hcml0eSBmcm9tIFwiLi9pbnRlcm5hbC9fYXJpdHkuanNcIjtcbmltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbmltcG9ydCBoZWFkIGZyb20gXCIuL2hlYWQuanNcIjtcbmltcG9ydCBfcmVkdWNlIGZyb20gXCIuL2ludGVybmFsL19yZWR1Y2UuanNcIjtcbmltcG9ydCB0YWlsIGZyb20gXCIuL3RhaWwuanNcIjtcbmltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eS5qc1wiO1xuLyoqXG4gKiBQZXJmb3JtcyBsZWZ0LXRvLXJpZ2h0IGZ1bmN0aW9uIGNvbXBvc2l0aW9uIHVzaW5nIHRyYW5zZm9ybWluZyBmdW5jdGlvbi4gVGhlIGZpcnN0IGFyZ3VtZW50IG1heSBoYXZlXG4gKiBhbnkgYXJpdHk7IHRoZSByZW1haW5pbmcgYXJndW1lbnRzIG11c3QgYmUgdW5hcnkuXG4gKlxuICogKipOb3RlOioqIFRoZSByZXN1bHQgb2YgcGlwZVdpdGggaXMgbm90IGF1dG9tYXRpY2FsbHkgY3VycmllZC4gVHJhbnNmb3JtaW5nIGZ1bmN0aW9uIGlzIG5vdCB1c2VkIG9uIHRoZVxuICogZmlyc3QgYXJndW1lbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjYuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgoKiAtPiAqKSwgWygoYSwgYiwgLi4uLCBuKSAtPiBvKSwgKG8gLT4gcCksIC4uLiwgKHggLT4geSksICh5IC0+IHopXSkgLT4gKChhLCBiLCAuLi4sIG4pIC0+IHopXG4gKiBAcGFyYW0gey4uLkZ1bmN0aW9ufSBmdW5jdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHNlZSBSLmNvbXBvc2VXaXRoLCBSLnBpcGVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBwaXBlV2hpbGVOb3ROaWwgPSBSLnBpcGVXaXRoKChmLCByZXMpID0+IFIuaXNOaWwocmVzKSA/IHJlcyA6IGYocmVzKSk7XG4gKiAgICAgIGNvbnN0IGYgPSBwaXBlV2hpbGVOb3ROaWwoW01hdGgucG93LCBSLm5lZ2F0ZSwgUi5pbmNdKVxuICpcbiAqICAgICAgZigzLCA0KTsgLy8gLSgzXjQpICsgMVxuICogQHN5bWIgUi5waXBlV2l0aChmKShbZywgaCwgaV0pKC4uLmFyZ3MpID0gZihpLCBmKGgsIGcoLi4uYXJncykpKVxuICovXG5cbnZhciBwaXBlV2l0aCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIHBpcGVXaXRoKHhmLCBsaXN0KSB7XG4gIGlmIChsaXN0Lmxlbmd0aCA8PSAwKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG5cbiAgdmFyIGhlYWRMaXN0ID0gaGVhZChsaXN0KTtcbiAgdmFyIHRhaWxMaXN0ID0gdGFpbChsaXN0KTtcbiAgcmV0dXJuIF9hcml0eShoZWFkTGlzdC5sZW5ndGgsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3JlZHVjZShmdW5jdGlvbiAocmVzdWx0LCBmKSB7XG4gICAgICByZXR1cm4geGYuY2FsbCh0aGlzLCBmLCByZXN1bHQpO1xuICAgIH0sIGhlYWRMaXN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHRhaWxMaXN0KTtcbiAgfSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcGlwZVdpdGg7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IHBpcGVXaXRoIGZyb20gXCIuL3BpcGVXaXRoLmpzXCI7XG5pbXBvcnQgcmV2ZXJzZSBmcm9tIFwiLi9yZXZlcnNlLmpzXCI7XG4vKipcbiAqIFBlcmZvcm1zIHJpZ2h0LXRvLWxlZnQgZnVuY3Rpb24gY29tcG9zaXRpb24gdXNpbmcgdHJhbnNmb3JtaW5nIGZ1bmN0aW9uLiBUaGUgbGFzdCBhcmd1bWVudCBtYXkgaGF2ZVxuICogYW55IGFyaXR5OyB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cyBtdXN0IGJlIHVuYXJ5LlxuICpcbiAqICoqTm90ZToqKiBUaGUgcmVzdWx0IG9mIGNvbXBvc2UgaXMgbm90IGF1dG9tYXRpY2FsbHkgY3VycmllZC4gVHJhbnNmb3JtaW5nIGZ1bmN0aW9uIGlzIG5vdCB1c2VkIG9uIHRoZVxuICogbGFzdCBhcmd1bWVudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yNi4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKCgqIC0+ICopLCBbKHkgLT4geiksICh4IC0+IHkpLCAuLi4sIChvIC0+IHApLCAoKGEsIGIsIC4uLiwgbikgLT4gbyldKSAtPiAoKGEsIGIsIC4uLiwgbikgLT4geilcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259IC4uLmZ1bmN0aW9ucyBUaGUgZnVuY3Rpb25zIHRvIGNvbXBvc2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHNlZSBSLmNvbXBvc2UsIFIucGlwZVdpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBjb21wb3NlV2hpbGVOb3ROaWwgPSBSLmNvbXBvc2VXaXRoKChmLCByZXMpID0+IFIuaXNOaWwocmVzKSA/IHJlcyA6IGYocmVzKSk7XG4gKlxuICogICAgICBjb21wb3NlV2hpbGVOb3ROaWwoW1IuaW5jLCBSLnByb3AoJ2FnZScpXSkoe2FnZTogMX0pIC8vPT4gMlxuICogICAgICBjb21wb3NlV2hpbGVOb3ROaWwoW1IuaW5jLCBSLnByb3AoJ2FnZScpXSkoe30pIC8vPT4gdW5kZWZpbmVkXG4gKlxuICogQHN5bWIgUi5jb21wb3NlV2l0aChmKShbZywgaCwgaV0pKC4uLmFyZ3MpID0gZihnLCBmKGgsIGkoLi4uYXJncykpKVxuICovXG5cbnZhciBjb21wb3NlV2l0aCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIGNvbXBvc2VXaXRoKHhmLCBsaXN0KSB7XG4gIHJldHVybiBwaXBlV2l0aC5hcHBseSh0aGlzLCBbeGYsIHJldmVyc2UobGlzdCldKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBjb21wb3NlV2l0aDsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlGcm9tSXRlcmF0b3IoaXRlcikge1xuICB2YXIgbGlzdCA9IFtdO1xuICB2YXIgbmV4dDtcblxuICB3aGlsZSAoIShuZXh0ID0gaXRlci5uZXh0KCkpLmRvbmUpIHtcbiAgICBsaXN0LnB1c2gobmV4dC52YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaW5jbHVkZXNXaXRoKHByZWQsIHgsIGxpc3QpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgaWYgKHByZWQoeCwgbGlzdFtpZHhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2Z1bmN0aW9uTmFtZShmKSB7XG4gIC8vIFN0cmluZyh4ID0+IHgpIGV2YWx1YXRlcyB0byBcInggPT4geFwiLCBzbyB0aGUgcGF0dGVybiBtYXkgbm90IG1hdGNoLlxuICB2YXIgbWF0Y2ggPSBTdHJpbmcoZikubWF0Y2goL15mdW5jdGlvbiAoXFx3KikvKTtcbiAgcmV0dXJuIG1hdGNoID09IG51bGwgPyAnJyA6IG1hdGNoWzFdO1xufSIsIi8vIEJhc2VkIG9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuZnVuY3Rpb24gX29iamVjdElzKGEsIGIpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoYSA9PT0gYikge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgcmV0dXJuIGEgIT09IDAgfHwgMSAvIGEgPT09IDEgLyBiO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgcmV0dXJuIGEgIT09IGEgJiYgYiAhPT0gYjtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogX29iamVjdElzOyIsImltcG9ydCBfYXJyYXlGcm9tSXRlcmF0b3IgZnJvbSBcIi4vX2FycmF5RnJvbUl0ZXJhdG9yLmpzXCI7XG5pbXBvcnQgX2luY2x1ZGVzV2l0aCBmcm9tIFwiLi9faW5jbHVkZXNXaXRoLmpzXCI7XG5pbXBvcnQgX2Z1bmN0aW9uTmFtZSBmcm9tIFwiLi9fZnVuY3Rpb25OYW1lLmpzXCI7XG5pbXBvcnQgX2hhcyBmcm9tIFwiLi9faGFzLmpzXCI7XG5pbXBvcnQgX29iamVjdElzIGZyb20gXCIuL19vYmplY3RJcy5qc1wiO1xuaW1wb3J0IGtleXMgZnJvbSBcIi4uL2tleXMuanNcIjtcbmltcG9ydCB0eXBlIGZyb20gXCIuLi90eXBlLmpzXCI7XG4vKipcbiAqIHByaXZhdGUgX3VuaXFDb250ZW50RXF1YWxzIGZ1bmN0aW9uLlxuICogVGhhdCBmdW5jdGlvbiBpcyBjaGVja2luZyBlcXVhbGl0eSBvZiAyIGl0ZXJhdG9yIGNvbnRlbnRzIHdpdGggMiBhc3N1bXB0aW9uc1xuICogLSBpdGVyYXRvcnMgbGVuZ3RocyBhcmUgdGhlIHNhbWVcbiAqIC0gaXRlcmF0b3JzIHZhbHVlcyBhcmUgdW5pcXVlXG4gKlxuICogZmFsc2UtcG9zaXRpdmUgcmVzdWx0IHdpbGwgYmUgcmV0dXJuZWQgZm9yIGNvbXBhcmlzaW9uIG9mLCBlLmcuXG4gKiAtIFsxLDIsM10gYW5kIFsxLDIsMyw0XVxuICogLSBbMSwxLDFdIGFuZCBbMSwyLDNdXG4gKiAqL1xuXG5mdW5jdGlvbiBfdW5pcUNvbnRlbnRFcXVhbHMoYUl0ZXJhdG9yLCBiSXRlcmF0b3IsIHN0YWNrQSwgc3RhY2tCKSB7XG4gIHZhciBhID0gX2FycmF5RnJvbUl0ZXJhdG9yKGFJdGVyYXRvcik7XG5cbiAgdmFyIGIgPSBfYXJyYXlGcm9tSXRlcmF0b3IoYkl0ZXJhdG9yKTtcblxuICBmdW5jdGlvbiBlcShfYSwgX2IpIHtcbiAgICByZXR1cm4gX2VxdWFscyhfYSwgX2IsIHN0YWNrQS5zbGljZSgpLCBzdGFja0Iuc2xpY2UoKSk7XG4gIH0gLy8gaWYgKmEqIGFycmF5IGNvbnRhaW5zIGFueSBlbGVtZW50IHRoYXQgaXMgbm90IGluY2x1ZGVkIGluICpiKlxuXG5cbiAgcmV0dXJuICFfaW5jbHVkZXNXaXRoKGZ1bmN0aW9uIChiLCBhSXRlbSkge1xuICAgIHJldHVybiAhX2luY2x1ZGVzV2l0aChlcSwgYUl0ZW0sIGIpO1xuICB9LCBiLCBhKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2VxdWFscyhhLCBiLCBzdGFja0EsIHN0YWNrQikge1xuICBpZiAoX29iamVjdElzKGEsIGIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgdHlwZUEgPSB0eXBlKGEpO1xuXG4gIGlmICh0eXBlQSAhPT0gdHlwZShiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBhWydmYW50YXN5LWxhbmQvZXF1YWxzJ10gPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGJbJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlb2YgYVsnZmFudGFzeS1sYW5kL2VxdWFscyddID09PSAnZnVuY3Rpb24nICYmIGFbJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnXShiKSAmJiB0eXBlb2YgYlsnZmFudGFzeS1sYW5kL2VxdWFscyddID09PSAnZnVuY3Rpb24nICYmIGJbJ2ZhbnRhc3ktbGFuZC9lcXVhbHMnXShhKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYS5lcXVhbHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGIuZXF1YWxzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhLmVxdWFscyA9PT0gJ2Z1bmN0aW9uJyAmJiBhLmVxdWFscyhiKSAmJiB0eXBlb2YgYi5lcXVhbHMgPT09ICdmdW5jdGlvbicgJiYgYi5lcXVhbHMoYSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGVBKSB7XG4gICAgY2FzZSAnQXJndW1lbnRzJzpcbiAgICBjYXNlICdBcnJheSc6XG4gICAgY2FzZSAnT2JqZWN0JzpcbiAgICAgIGlmICh0eXBlb2YgYS5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiBfZnVuY3Rpb25OYW1lKGEuY29uc3RydWN0b3IpID09PSAnUHJvbWlzZScpIHtcbiAgICAgICAgcmV0dXJuIGEgPT09IGI7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnQm9vbGVhbic6XG4gICAgY2FzZSAnTnVtYmVyJzpcbiAgICBjYXNlICdTdHJpbmcnOlxuICAgICAgaWYgKCEodHlwZW9mIGEgPT09IHR5cGVvZiBiICYmIF9vYmplY3RJcyhhLnZhbHVlT2YoKSwgYi52YWx1ZU9mKCkpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnRGF0ZSc6XG4gICAgICBpZiAoIV9vYmplY3RJcyhhLnZhbHVlT2YoKSwgYi52YWx1ZU9mKCkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdFcnJvcic6XG4gICAgICByZXR1cm4gYS5uYW1lID09PSBiLm5hbWUgJiYgYS5tZXNzYWdlID09PSBiLm1lc3NhZ2U7XG5cbiAgICBjYXNlICdSZWdFeHAnOlxuICAgICAgaWYgKCEoYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZ2xvYmFsID09PSBiLmdsb2JhbCAmJiBhLmlnbm9yZUNhc2UgPT09IGIuaWdub3JlQ2FzZSAmJiBhLm11bHRpbGluZSA9PT0gYi5tdWx0aWxpbmUgJiYgYS5zdGlja3kgPT09IGIuc3RpY2t5ICYmIGEudW5pY29kZSA9PT0gYi51bmljb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIGlkeCA9IHN0YWNrQS5sZW5ndGggLSAxO1xuXG4gIHdoaWxlIChpZHggPj0gMCkge1xuICAgIGlmIChzdGFja0FbaWR4XSA9PT0gYSkge1xuICAgICAgcmV0dXJuIHN0YWNrQltpZHhdID09PSBiO1xuICAgIH1cblxuICAgIGlkeCAtPSAxO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlQSkge1xuICAgIGNhc2UgJ01hcCc6XG4gICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3VuaXFDb250ZW50RXF1YWxzKGEuZW50cmllcygpLCBiLmVudHJpZXMoKSwgc3RhY2tBLmNvbmNhdChbYV0pLCBzdGFja0IuY29uY2F0KFtiXSkpO1xuXG4gICAgY2FzZSAnU2V0JzpcbiAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdW5pcUNvbnRlbnRFcXVhbHMoYS52YWx1ZXMoKSwgYi52YWx1ZXMoKSwgc3RhY2tBLmNvbmNhdChbYV0pLCBzdGFja0IuY29uY2F0KFtiXSkpO1xuXG4gICAgY2FzZSAnQXJndW1lbnRzJzpcbiAgICBjYXNlICdBcnJheSc6XG4gICAgY2FzZSAnT2JqZWN0JzpcbiAgICBjYXNlICdCb29sZWFuJzpcbiAgICBjYXNlICdOdW1iZXInOlxuICAgIGNhc2UgJ1N0cmluZyc6XG4gICAgY2FzZSAnRGF0ZSc6XG4gICAgY2FzZSAnRXJyb3InOlxuICAgIGNhc2UgJ1JlZ0V4cCc6XG4gICAgY2FzZSAnSW50OEFycmF5JzpcbiAgICBjYXNlICdVaW50OEFycmF5JzpcbiAgICBjYXNlICdVaW50OENsYW1wZWRBcnJheSc6XG4gICAgY2FzZSAnSW50MTZBcnJheSc6XG4gICAgY2FzZSAnVWludDE2QXJyYXknOlxuICAgIGNhc2UgJ0ludDMyQXJyYXknOlxuICAgIGNhc2UgJ1VpbnQzMkFycmF5JzpcbiAgICBjYXNlICdGbG9hdDMyQXJyYXknOlxuICAgIGNhc2UgJ0Zsb2F0NjRBcnJheSc6XG4gICAgY2FzZSAnQXJyYXlCdWZmZXInOlxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gVmFsdWVzIG9mIG90aGVyIHR5cGVzIGFyZSBvbmx5IGVxdWFsIGlmIGlkZW50aWNhbC5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IGtleXMoYSk7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5cyhiKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXh0ZW5kZWRTdGFja0EgPSBzdGFja0EuY29uY2F0KFthXSk7XG4gIHZhciBleHRlbmRlZFN0YWNrQiA9IHN0YWNrQi5jb25jYXQoW2JdKTtcbiAgaWR4ID0ga2V5c0EubGVuZ3RoIC0gMTtcblxuICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICB2YXIga2V5ID0ga2V5c0FbaWR4XTtcblxuICAgIGlmICghKF9oYXMoa2V5LCBiKSAmJiBfZXF1YWxzKGJba2V5XSwgYVtrZXldLCBleHRlbmRlZFN0YWNrQSwgZXh0ZW5kZWRTdGFja0IpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlkeCAtPSAxO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9lcXVhbHMgZnJvbSBcIi4vaW50ZXJuYWwvX2VxdWFscy5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBpdHMgYXJndW1lbnRzIGFyZSBlcXVpdmFsZW50LCBgZmFsc2VgIG90aGVyd2lzZS4gSGFuZGxlc1xuICogY3ljbGljYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuICpcbiAqIERpc3BhdGNoZXMgc3ltbWV0cmljYWxseSB0byB0aGUgYGVxdWFsc2AgbWV0aG9kcyBvZiBib3RoIGFyZ3VtZW50cywgaWZcbiAqIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTUuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIGEgLT4gYiAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmVxdWFscygxLCAxKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuZXF1YWxzKDEsICcxJyk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5lcXVhbHMoWzEsIDIsIDNdLCBbMSwgMiwgM10pOyAvLz0+IHRydWVcbiAqXG4gKiAgICAgIGNvbnN0IGEgPSB7fTsgYS52ID0gYTtcbiAqICAgICAgY29uc3QgYiA9IHt9OyBiLnYgPSBiO1xuICogICAgICBSLmVxdWFscyhhLCBiKTsgLy89PiB0cnVlXG4gKi9cblxudmFyIGVxdWFscyA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBfZXF1YWxzKGEsIGIsIFtdLCBbXSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZXF1YWxzOyIsImltcG9ydCBlcXVhbHMgZnJvbSBcIi4uL2VxdWFscy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2luZGV4T2YobGlzdCwgYSwgaWR4KSB7XG4gIHZhciBpbmYsIGl0ZW07IC8vIEFycmF5LnByb3RvdHlwZS5pbmRleE9mIGRvZXNuJ3QgZXhpc3QgYmVsb3cgSUU5XG5cbiAgaWYgKHR5cGVvZiBsaXN0LmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBhKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgICAgIC8vIG1hbnVhbGx5IGNyYXdsIHRoZSBsaXN0IHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gKzAgYW5kIC0wXG4gICAgICAgICAgaW5mID0gMSAvIGE7XG5cbiAgICAgICAgICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2lkeF07XG5cbiAgICAgICAgICAgIGlmIChpdGVtID09PSAwICYmIDEgLyBpdGVtID09PSBpbmYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGlkeDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGEgIT09IGEpIHtcbiAgICAgICAgICAvLyBOYU5cbiAgICAgICAgICB3aGlsZSAoaWR4IDwgbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBsaXN0W2lkeF07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gJ251bWJlcicgJiYgaXRlbSAhPT0gaXRlbSkge1xuICAgICAgICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gLy8gbm9uLXplcm8gbnVtYmVycyBjYW4gdXRpbGlzZSBTZXRcblxuXG4gICAgICAgIHJldHVybiBsaXN0LmluZGV4T2YoYSwgaWR4KTtcbiAgICAgIC8vIGFsbCB0aGVzZSB0eXBlcyBjYW4gdXRpbGlzZSBTZXRcblxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIGxpc3QuaW5kZXhPZihhLCBpZHgpO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoYSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIG51bGwgY2FuIHV0aWxpc2UgU2V0XG4gICAgICAgICAgcmV0dXJuIGxpc3QuaW5kZXhPZihhLCBpZHgpO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH0gLy8gYW55dGhpbmcgZWxzZSBub3QgY292ZXJlZCBhYm92ZSwgZGVmZXIgdG8gUi5lcXVhbHNcblxuXG4gIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgIGlmIChlcXVhbHMobGlzdFtpZHhdLCBhKSkge1xuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG5cbiAgICBpZHggKz0gMTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn0iLCJpbXBvcnQgX2luZGV4T2YgZnJvbSBcIi4vX2luZGV4T2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pbmNsdWRlcyhhLCBsaXN0KSB7XG4gIHJldHVybiBfaW5kZXhPZihsaXN0LCBhLCAwKSA+PSAwO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9xdW90ZShzKSB7XG4gIHZhciBlc2NhcGVkID0gcy5yZXBsYWNlKC9cXFxcL2csICdcXFxcXFxcXCcpLnJlcGxhY2UoL1tcXGJdL2csICdcXFxcYicpIC8vIFxcYiBtYXRjaGVzIHdvcmQgYm91bmRhcnk7IFtcXGJdIG1hdGNoZXMgYmFja3NwYWNlXG4gIC5yZXBsYWNlKC9cXGYvZywgJ1xcXFxmJykucmVwbGFjZSgvXFxuL2csICdcXFxcbicpLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKS5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JykucmVwbGFjZSgvXFx2L2csICdcXFxcdicpLnJlcGxhY2UoL1xcMC9nLCAnXFxcXDAnKTtcbiAgcmV0dXJuICdcIicgKyBlc2NhcGVkLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSArICdcIic7XG59IiwiLyoqXG4gKiBQb2x5ZmlsbCBmcm9tIDxodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvSVNPU3RyaW5nPi5cbiAqL1xudmFyIHBhZCA9IGZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiAobiA8IDEwID8gJzAnIDogJycpICsgbjtcbn07XG5cbnZhciBfdG9JU09TdHJpbmcgPSB0eXBlb2YgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcgPT09ICdmdW5jdGlvbicgPyBmdW5jdGlvbiBfdG9JU09TdHJpbmcoZCkge1xuICByZXR1cm4gZC50b0lTT1N0cmluZygpO1xufSA6IGZ1bmN0aW9uIF90b0lTT1N0cmluZyhkKSB7XG4gIHJldHVybiBkLmdldFVUQ0Z1bGxZZWFyKCkgKyAnLScgKyBwYWQoZC5nZXRVVENNb250aCgpICsgMSkgKyAnLScgKyBwYWQoZC5nZXRVVENEYXRlKCkpICsgJ1QnICsgcGFkKGQuZ2V0VVRDSG91cnMoKSkgKyAnOicgKyBwYWQoZC5nZXRVVENNaW51dGVzKCkpICsgJzonICsgcGFkKGQuZ2V0VVRDU2Vjb25kcygpKSArICcuJyArIChkLmdldFVUQ01pbGxpc2Vjb25kcygpIC8gMTAwMCkudG9GaXhlZCgzKS5zbGljZSgyLCA1KSArICdaJztcbn07XG5cbmV4cG9ydCBkZWZhdWx0IF90b0lTT1N0cmluZzsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY29tcGxlbWVudChmKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICFmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2ZpbHRlcihmbiwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGlmIChmbihsaXN0W2lkeF0pKSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBsaXN0W2lkeF07XG4gICAgfVxuXG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pc09iamVjdCh4KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufSIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL19jdXJyeTIuanNcIjtcbmltcG9ydCBfeGZCYXNlIGZyb20gXCIuL194ZkJhc2UuanNcIjtcblxudmFyIFhGaWx0ZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYRmlsdGVyKGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gIH1cblxuICBYRmlsdGVyLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWEZpbHRlci5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuXG4gIFhGaWx0ZXIucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICByZXR1cm4gdGhpcy5mKGlucHV0KSA/IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCkgOiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIFhGaWx0ZXI7XG59KCk7XG5cbnZhciBfeGZpbHRlciA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIF94ZmlsdGVyKGYsIHhmKSB7XG4gIHJldHVybiBuZXcgWEZpbHRlcihmLCB4Zik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgX3hmaWx0ZXI7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSBcIi4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZS5qc1wiO1xuaW1wb3J0IF9maWx0ZXIgZnJvbSBcIi4vaW50ZXJuYWwvX2ZpbHRlci5qc1wiO1xuaW1wb3J0IF9pc09iamVjdCBmcm9tIFwiLi9pbnRlcm5hbC9faXNPYmplY3QuanNcIjtcbmltcG9ydCBfcmVkdWNlIGZyb20gXCIuL2ludGVybmFsL19yZWR1Y2UuanNcIjtcbmltcG9ydCBfeGZpbHRlciBmcm9tIFwiLi9pbnRlcm5hbC9feGZpbHRlci5qc1wiO1xuaW1wb3J0IGtleXMgZnJvbSBcIi4va2V5cy5qc1wiO1xuLyoqXG4gKiBUYWtlcyBhIHByZWRpY2F0ZSBhbmQgYSBgRmlsdGVyYWJsZWAsIGFuZCByZXR1cm5zIGEgbmV3IGZpbHRlcmFibGUgb2YgdGhlXG4gKiBzYW1lIHR5cGUgY29udGFpbmluZyB0aGUgbWVtYmVycyBvZiB0aGUgZ2l2ZW4gZmlsdGVyYWJsZSB3aGljaCBzYXRpc2Z5IHRoZVxuICogZ2l2ZW4gcHJlZGljYXRlLiBGaWx0ZXJhYmxlIG9iamVjdHMgaW5jbHVkZSBwbGFpbiBvYmplY3RzIG9yIGFueSBvYmplY3RcbiAqIHRoYXQgaGFzIGEgZmlsdGVyIG1ldGhvZCBzdWNoIGFzIGBBcnJheWAuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGZpbHRlcmAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4pIC0+IGYgYSAtPiBmIGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGZpbHRlcmFibGVcbiAqIEByZXR1cm4ge0FycmF5fSBGaWx0ZXJhYmxlXG4gKiBAc2VlIFIucmVqZWN0LCBSLnRyYW5zZHVjZSwgUi5hZGRJbmRleFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGlzRXZlbiA9IG4gPT4gbiAlIDIgPT09IDA7XG4gKlxuICogICAgICBSLmZpbHRlcihpc0V2ZW4sIFsxLCAyLCAzLCA0XSk7IC8vPT4gWzIsIDRdXG4gKlxuICogICAgICBSLmZpbHRlcihpc0V2ZW4sIHthOiAxLCBiOiAyLCBjOiAzLCBkOiA0fSk7IC8vPT4ge2I6IDIsIGQ6IDR9XG4gKi9cblxudmFyIGZpbHRlciA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKFxuLyojX19QVVJFX18qL1xuX2Rpc3BhdGNoYWJsZShbJ2ZpbHRlciddLCBfeGZpbHRlciwgZnVuY3Rpb24gKHByZWQsIGZpbHRlcmFibGUpIHtcbiAgcmV0dXJuIF9pc09iamVjdChmaWx0ZXJhYmxlKSA/IF9yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgaWYgKHByZWQoZmlsdGVyYWJsZVtrZXldKSkge1xuICAgICAgYWNjW2tleV0gPSBmaWx0ZXJhYmxlW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30sIGtleXMoZmlsdGVyYWJsZSkpIDogLy8gZWxzZVxuICBfZmlsdGVyKHByZWQsIGZpbHRlcmFibGUpO1xufSkpO1xuXG5leHBvcnQgZGVmYXVsdCBmaWx0ZXI7IiwiaW1wb3J0IF9jb21wbGVtZW50IGZyb20gXCIuL2ludGVybmFsL19jb21wbGVtZW50LmpzXCI7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgZmlsdGVyIGZyb20gXCIuL2ZpbHRlci5qc1wiO1xuLyoqXG4gKiBUaGUgY29tcGxlbWVudCBvZiBbYGZpbHRlcmBdKCNmaWx0ZXIpLlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi4gRmlsdGVyYWJsZVxuICogb2JqZWN0cyBpbmNsdWRlIHBsYWluIG9iamVjdHMgb3IgYW55IG9iamVjdCB0aGF0IGhhcyBhIGZpbHRlciBtZXRob2Qgc3VjaFxuICogYXMgYEFycmF5YC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIEZpbHRlcmFibGUgZiA9PiAoYSAtPiBCb29sZWFuKSAtPiBmIGEgLT4gZiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkXG4gKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJhYmxlXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBzZWUgUi5maWx0ZXIsIFIudHJhbnNkdWNlLCBSLmFkZEluZGV4XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgaXNPZGQgPSAobikgPT4gbiAlIDIgPT09IDE7XG4gKlxuICogICAgICBSLnJlamVjdChpc09kZCwgWzEsIDIsIDMsIDRdKTsgLy89PiBbMiwgNF1cbiAqXG4gKiAgICAgIFIucmVqZWN0KGlzT2RkLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHtiOiAyLCBkOiA0fVxuICovXG5cbnZhciByZWplY3QgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiByZWplY3QocHJlZCwgZmlsdGVyYWJsZSkge1xuICByZXR1cm4gZmlsdGVyKF9jb21wbGVtZW50KHByZWQpLCBmaWx0ZXJhYmxlKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCByZWplY3Q7IiwiaW1wb3J0IF9pbmNsdWRlcyBmcm9tIFwiLi9faW5jbHVkZXMuanNcIjtcbmltcG9ydCBfbWFwIGZyb20gXCIuL19tYXAuanNcIjtcbmltcG9ydCBfcXVvdGUgZnJvbSBcIi4vX3F1b3RlLmpzXCI7XG5pbXBvcnQgX3RvSVNPU3RyaW5nIGZyb20gXCIuL190b0lTT1N0cmluZy5qc1wiO1xuaW1wb3J0IGtleXMgZnJvbSBcIi4uL2tleXMuanNcIjtcbmltcG9ydCByZWplY3QgZnJvbSBcIi4uL3JlamVjdC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3RvU3RyaW5nKHgsIHNlZW4pIHtcbiAgdmFyIHJlY3VyID0gZnVuY3Rpb24gcmVjdXIoeSkge1xuICAgIHZhciB4cyA9IHNlZW4uY29uY2F0KFt4XSk7XG4gICAgcmV0dXJuIF9pbmNsdWRlcyh5LCB4cykgPyAnPENpcmN1bGFyPicgOiBfdG9TdHJpbmcoeSwgeHMpO1xuICB9OyAvLyAgbWFwUGFpcnMgOjogKE9iamVjdCwgW1N0cmluZ10pIC0+IFtTdHJpbmddXG5cblxuICB2YXIgbWFwUGFpcnMgPSBmdW5jdGlvbiAob2JqLCBrZXlzKSB7XG4gICAgcmV0dXJuIF9tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgIHJldHVybiBfcXVvdGUoaykgKyAnOiAnICsgcmVjdXIob2JqW2tdKTtcbiAgICB9LCBrZXlzLnNsaWNlKCkuc29ydCgpKTtcbiAgfTtcblxuICBzd2l0Y2ggKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSkge1xuICAgIGNhc2UgJ1tvYmplY3QgQXJndW1lbnRzXSc6XG4gICAgICByZXR1cm4gJyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgnICsgX21hcChyZWN1ciwgeCkuam9pbignLCAnKSArICcpKSc7XG5cbiAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6XG4gICAgICByZXR1cm4gJ1snICsgX21hcChyZWN1ciwgeCkuY29uY2F0KG1hcFBhaXJzKHgsIHJlamVjdChmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gL15cXGQrJC8udGVzdChrKTtcbiAgICAgIH0sIGtleXMoeCkpKSkuam9pbignLCAnKSArICddJztcblxuICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyA/ICduZXcgQm9vbGVhbignICsgcmVjdXIoeC52YWx1ZU9mKCkpICsgJyknIDogeC50b1N0cmluZygpO1xuXG4gICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XG4gICAgICByZXR1cm4gJ25ldyBEYXRlKCcgKyAoaXNOYU4oeC52YWx1ZU9mKCkpID8gcmVjdXIoTmFOKSA6IF9xdW90ZShfdG9JU09TdHJpbmcoeCkpKSArICcpJztcblxuICAgIGNhc2UgJ1tvYmplY3QgTnVsbF0nOlxuICAgICAgcmV0dXJuICdudWxsJztcblxuICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnID8gJ25ldyBOdW1iZXIoJyArIHJlY3VyKHgudmFsdWVPZigpKSArICcpJyA6IDEgLyB4ID09PSAtSW5maW5pdHkgPyAnLTAnIDogeC50b1N0cmluZygxMCk7XG5cbiAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyA/ICduZXcgU3RyaW5nKCcgKyByZWN1cih4LnZhbHVlT2YoKSkgKyAnKScgOiBfcXVvdGUoeCk7XG5cbiAgICBjYXNlICdbb2JqZWN0IFVuZGVmaW5lZF0nOlxuICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0eXBlb2YgeC50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcmVwciA9IHgudG9TdHJpbmcoKTtcblxuICAgICAgICBpZiAocmVwciAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgICByZXR1cm4gcmVwcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ3snICsgbWFwUGFpcnMoeCwga2V5cyh4KSkuam9pbignLCAnKSArICd9JztcbiAgfVxufSIsImltcG9ydCBfY3VycnkxIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTEuanNcIjtcbmltcG9ydCBfdG9TdHJpbmcgZnJvbSBcIi4vaW50ZXJuYWwvX3RvU3RyaW5nLmpzXCI7XG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gdmFsdWUuIGBldmFsYCdpbmcgdGhlIG91dHB1dFxuICogc2hvdWxkIHJlc3VsdCBpbiBhIHZhbHVlIGVxdWl2YWxlbnQgdG8gdGhlIGlucHV0IHZhbHVlLiBNYW55IG9mIHRoZSBidWlsdC1pblxuICogYHRvU3RyaW5nYCBtZXRob2RzIGRvIG5vdCBzYXRpc2Z5IHRoaXMgcmVxdWlyZW1lbnQuXG4gKlxuICogSWYgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGBbb2JqZWN0IE9iamVjdF1gIHdpdGggYSBgdG9TdHJpbmdgIG1ldGhvZCBvdGhlclxuICogdGhhbiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AsIHRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2l0aCBubyBhcmd1bWVudHNcbiAqIHRvIHByb2R1Y2UgdGhlIHJldHVybiB2YWx1ZS4gVGhpcyBtZWFucyB1c2VyLWRlZmluZWQgY29uc3RydWN0b3IgZnVuY3Rpb25zXG4gKiBjYW4gcHJvdmlkZSBhIHN1aXRhYmxlIGB0b1N0cmluZ2AgbWV0aG9kLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgZnVuY3Rpb24gUG9pbnQoeCwgeSkge1xuICogICAgICAgdGhpcy54ID0geDtcbiAqICAgICAgIHRoaXMueSA9IHk7XG4gKiAgICAgfVxuICpcbiAqICAgICBQb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAqICAgICAgIHJldHVybiAnbmV3IFBvaW50KCcgKyB0aGlzLnggKyAnLCAnICsgdGhpcy55ICsgJyknO1xuICogICAgIH07XG4gKlxuICogICAgIFIudG9TdHJpbmcobmV3IFBvaW50KDEsIDIpKTsgLy89PiAnbmV3IFBvaW50KDEsIDIpJ1xuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBzaWcgKiAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50b1N0cmluZyg0Mik7IC8vPT4gJzQyJ1xuICogICAgICBSLnRvU3RyaW5nKCdhYmMnKTsgLy89PiAnXCJhYmNcIidcbiAqICAgICAgUi50b1N0cmluZyhbMSwgMiwgM10pOyAvLz0+ICdbMSwgMiwgM10nXG4gKiAgICAgIFIudG9TdHJpbmcoe2ZvbzogMSwgYmFyOiAyLCBiYXo6IDN9KTsgLy89PiAne1wiYmFyXCI6IDIsIFwiYmF6XCI6IDMsIFwiZm9vXCI6IDF9J1xuICogICAgICBSLnRvU3RyaW5nKG5ldyBEYXRlKCcyMDAxLTAyLTAzVDA0OjA1OjA2WicpKTsgLy89PiAnbmV3IERhdGUoXCIyMDAxLTAyLTAzVDA0OjA1OjA2LjAwMFpcIiknXG4gKi9cblxudmFyIHRvU3RyaW5nID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoZnVuY3Rpb24gdG9TdHJpbmcodmFsKSB7XG4gIHJldHVybiBfdG9TdHJpbmcodmFsLCBbXSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdG9TdHJpbmc7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9pc0FycmF5IGZyb20gXCIuL2ludGVybmFsL19pc0FycmF5LmpzXCI7XG5pbXBvcnQgX2lzRnVuY3Rpb24gZnJvbSBcIi4vaW50ZXJuYWwvX2lzRnVuY3Rpb24uanNcIjtcbmltcG9ydCBfaXNTdHJpbmcgZnJvbSBcIi4vaW50ZXJuYWwvX2lzU3RyaW5nLmpzXCI7XG5pbXBvcnQgdG9TdHJpbmcgZnJvbSBcIi4vdG9TdHJpbmcuanNcIjtcbi8qKlxuICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGNvbmNhdGVuYXRpbmcgdGhlIGdpdmVuIGxpc3RzIG9yIHN0cmluZ3MuXG4gKlxuICogTm90ZTogYFIuY29uY2F0YCBleHBlY3RzIGJvdGggYXJndW1lbnRzIHRvIGJlIG9mIHRoZSBzYW1lIHR5cGUsXG4gKiB1bmxpa2UgdGhlIG5hdGl2ZSBgQXJyYXkucHJvdG90eXBlLmNvbmNhdGAgbWV0aG9kLiBJdCB3aWxsIHRocm93XG4gKiBhbiBlcnJvciBpZiB5b3UgYGNvbmNhdGAgYW4gQXJyYXkgd2l0aCBhIG5vbi1BcnJheSB2YWx1ZS5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgY29uY2F0YCBtZXRob2Qgb2YgdGhlIGZpcnN0IGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICogQ2FuIGFsc28gY29uY2F0ZW5hdGUgdHdvIG1lbWJlcnMgb2YgYSBbZmFudGFzeS1sYW5kXG4gKiBjb21wYXRpYmxlIHNlbWlncm91cF0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNzZW1pZ3JvdXApLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IFthXSAtPiBbYV1cbiAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBmaXJzdExpc3QgVGhlIGZpcnN0IGxpc3RcbiAqIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBzZWNvbmRMaXN0IFRoZSBzZWNvbmQgbGlzdFxuICogQHJldHVybiB7QXJyYXl8U3RyaW5nfSBBIGxpc3QgY29uc2lzdGluZyBvZiB0aGUgZWxlbWVudHMgb2YgYGZpcnN0TGlzdGAgZm9sbG93ZWQgYnkgdGhlIGVsZW1lbnRzIG9mXG4gKiBgc2Vjb25kTGlzdGAuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuY29uY2F0KCdBQkMnLCAnREVGJyk7IC8vICdBQkNERUYnXG4gKiAgICAgIFIuY29uY2F0KFs0LCA1LCA2XSwgWzEsIDIsIDNdKTsgLy89PiBbNCwgNSwgNiwgMSwgMiwgM11cbiAqICAgICAgUi5jb25jYXQoW10sIFtdKTsgLy89PiBbXVxuICovXG5cbnZhciBjb25jYXQgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBjb25jYXQoYSwgYikge1xuICBpZiAoX2lzQXJyYXkoYSkpIHtcbiAgICBpZiAoX2lzQXJyYXkoYikpIHtcbiAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHRvU3RyaW5nKGIpICsgJyBpcyBub3QgYW4gYXJyYXknKTtcbiAgfVxuXG4gIGlmIChfaXNTdHJpbmcoYSkpIHtcbiAgICBpZiAoX2lzU3RyaW5nKGIpKSB7XG4gICAgICByZXR1cm4gYSArIGI7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcih0b1N0cmluZyhiKSArICcgaXMgbm90IGEgc3RyaW5nJyk7XG4gIH1cblxuICBpZiAoYSAhPSBudWxsICYmIF9pc0Z1bmN0aW9uKGFbJ2ZhbnRhc3ktbGFuZC9jb25jYXQnXSkpIHtcbiAgICByZXR1cm4gYVsnZmFudGFzeS1sYW5kL2NvbmNhdCddKGIpO1xuICB9XG5cbiAgaWYgKGEgIT0gbnVsbCAmJiBfaXNGdW5jdGlvbihhLmNvbmNhdCkpIHtcbiAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKHRvU3RyaW5nKGEpICsgJyBkb2VzIG5vdCBoYXZlIGEgbWV0aG9kIG5hbWVkIFwiY29uY2F0XCIgb3IgXCJmYW50YXN5LWxhbmQvY29uY2F0XCInKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBjb25jYXQ7IiwiaW1wb3J0IF9hcml0eSBmcm9tIFwiLi9pbnRlcm5hbC9fYXJpdHkuanNcIjtcbmltcG9ydCBfY3VycnkxIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTEuanNcIjtcbmltcG9ydCBtYXAgZnJvbSBcIi4vbWFwLmpzXCI7XG5pbXBvcnQgbWF4IGZyb20gXCIuL21heC5qc1wiO1xuaW1wb3J0IHJlZHVjZSBmcm9tIFwiLi9yZWR1Y2UuanNcIjtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uLCBgZm5gLCB3aGljaCBlbmNhcHN1bGF0ZXMgYGlmL2Vsc2UsIGlmL2Vsc2UsIC4uLmAgbG9naWMuXG4gKiBgUi5jb25kYCB0YWtlcyBhIGxpc3Qgb2YgW3ByZWRpY2F0ZSwgdHJhbnNmb3JtZXJdIHBhaXJzLiBBbGwgb2YgdGhlIGFyZ3VtZW50c1xuICogdG8gYGZuYCBhcmUgYXBwbGllZCB0byBlYWNoIG9mIHRoZSBwcmVkaWNhdGVzIGluIHR1cm4gdW50aWwgb25lIHJldHVybnMgYVxuICogXCJ0cnV0aHlcIiB2YWx1ZSwgYXQgd2hpY2ggcG9pbnQgYGZuYCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgaXRzXG4gKiBhcmd1bWVudHMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgdHJhbnNmb3JtZXIuIElmIG5vbmUgb2YgdGhlIHByZWRpY2F0ZXNcbiAqIG1hdGNoZXMsIGBmbmAgcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNi4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgW1soKi4uLiAtPiBCb29sZWFuKSwoKi4uLiAtPiAqKV1dIC0+ICgqLi4uIC0+ICopXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlycyBBIGxpc3Qgb2YgW3ByZWRpY2F0ZSwgdHJhbnNmb3JtZXJdXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzZWUgUi5pZkVsc2UsIFIudW5sZXNzLCBSLndoZW5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBmbiA9IFIuY29uZChbXG4gKiAgICAgICAgW1IuZXF1YWxzKDApLCAgIFIuYWx3YXlzKCd3YXRlciBmcmVlemVzIGF0IDDCsEMnKV0sXG4gKiAgICAgICAgW1IuZXF1YWxzKDEwMCksIFIuYWx3YXlzKCd3YXRlciBib2lscyBhdCAxMDDCsEMnKV0sXG4gKiAgICAgICAgW1IuVCwgICAgICAgICAgIHRlbXAgPT4gJ25vdGhpbmcgc3BlY2lhbCBoYXBwZW5zIGF0ICcgKyB0ZW1wICsgJ8KwQyddXG4gKiAgICAgIF0pO1xuICogICAgICBmbigwKTsgLy89PiAnd2F0ZXIgZnJlZXplcyBhdCAwwrBDJ1xuICogICAgICBmbig1MCk7IC8vPT4gJ25vdGhpbmcgc3BlY2lhbCBoYXBwZW5zIGF0IDUwwrBDJ1xuICogICAgICBmbigxMDApOyAvLz0+ICd3YXRlciBib2lscyBhdCAxMDDCsEMnXG4gKi9cblxudmFyIGNvbmQgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiBjb25kKHBhaXJzKSB7XG4gIHZhciBhcml0eSA9IHJlZHVjZShtYXgsIDAsIG1hcChmdW5jdGlvbiAocGFpcikge1xuICAgIHJldHVybiBwYWlyWzBdLmxlbmd0aDtcbiAgfSwgcGFpcnMpKTtcbiAgcmV0dXJuIF9hcml0eShhcml0eSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZHggPSAwO1xuXG4gICAgd2hpbGUgKGlkeCA8IHBhaXJzLmxlbmd0aCkge1xuICAgICAgaWYgKHBhaXJzW2lkeF1bMF0uYXBwbHkodGhpcywgYXJndW1lbnRzKSkge1xuICAgICAgICByZXR1cm4gcGFpcnNbaWR4XVsxXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICBpZHggKz0gMTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbmQ7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IGN1cnJ5IGZyb20gXCIuL2N1cnJ5LmpzXCI7XG5pbXBvcnQgbkFyeSBmcm9tIFwiLi9uQXJ5LmpzXCI7XG4vKipcbiAqIFdyYXBzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gaW5zaWRlIGEgY3VycmllZCBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWRcbiAqIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIGFuZCByZXR1cm5zIHRoZSBzYW1lIHR5cGUuIFRoZSBhcml0eSBvZiB0aGUgZnVuY3Rpb25cbiAqIHJldHVybmVkIGlzIHNwZWNpZmllZCB0byBhbGxvdyB1c2luZyB2YXJpYWRpYyBjb25zdHJ1Y3RvciBmdW5jdGlvbnMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgTnVtYmVyIC0+ICgqIC0+IHsqfSkgLT4gKCogLT4geyp9KVxuICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIGFyaXR5IG9mIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IEZuIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiB0byB3cmFwLlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgd3JhcHBlZCwgY3VycmllZCBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyBWYXJpYWRpYyBDb25zdHJ1Y3RvciBmdW5jdGlvblxuICogICAgICBmdW5jdGlvbiBTYWxhZCgpIHtcbiAqICAgICAgICB0aGlzLmluZ3JlZGllbnRzID0gYXJndW1lbnRzO1xuICogICAgICB9XG4gKlxuICogICAgICBTYWxhZC5wcm90b3R5cGUucmVjaXBlID0gZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gUi5tYXAoaW5ncmVkaWVudCA9PiAnQWRkIGEgZG9sbG9wIG9mICcgKyBpbmdyZWRpZW50LCB0aGlzLmluZ3JlZGllbnRzKTtcbiAqICAgICAgICByZXR1cm4gUi5qb2luKCdcXG4nLCBpbnN0cnVjdGlvbnMpO1xuICogICAgICB9O1xuICpcbiAqICAgICAgY29uc3QgVGhyZWVMYXllclNhbGFkID0gUi5jb25zdHJ1Y3ROKDMsIFNhbGFkKTtcbiAqXG4gKiAgICAgIC8vIE5vdGljZSB3ZSBubyBsb25nZXIgbmVlZCB0aGUgJ25ldycga2V5d29yZCwgYW5kIHRoZSBjb25zdHJ1Y3RvciBpcyBjdXJyaWVkIGZvciAzIGFyZ3VtZW50cy5cbiAqICAgICAgY29uc3Qgc2FsYWQgPSBUaHJlZUxheWVyU2FsYWQoJ01heW9ubmFpc2UnKSgnUG90YXRvIENoaXBzJykoJ0tldGNodXAnKTtcbiAqXG4gKiAgICAgIGNvbnNvbGUubG9nKHNhbGFkLnJlY2lwZSgpKTtcbiAqICAgICAgLy8gQWRkIGEgZG9sbG9wIG9mIE1heW9ubmFpc2VcbiAqICAgICAgLy8gQWRkIGEgZG9sbG9wIG9mIFBvdGF0byBDaGlwc1xuICogICAgICAvLyBBZGQgYSBkb2xsb3Agb2YgS2V0Y2h1cFxuICovXG5cbnZhciBjb25zdHJ1Y3ROID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gY29uc3RydWN0TihuLCBGbikge1xuICBpZiAobiA+IDEwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb25zdHJ1Y3RvciB3aXRoIGdyZWF0ZXIgdGhhbiB0ZW4gYXJndW1lbnRzJyk7XG4gIH1cblxuICBpZiAobiA9PT0gMCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IEZuKCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBjdXJyeShuQXJ5KG4sIGZ1bmN0aW9uICgkMCwgJDEsICQyLCAkMywgJDQsICQ1LCAkNiwgJDcsICQ4LCAkOSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gbmV3IEZuKCQwKTtcblxuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSk7XG5cbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIG5ldyBGbigkMCwgJDEsICQyKTtcblxuICAgICAgY2FzZSA0OlxuICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzKTtcblxuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCk7XG5cbiAgICAgIGNhc2UgNjpcbiAgICAgICAgcmV0dXJuIG5ldyBGbigkMCwgJDEsICQyLCAkMywgJDQsICQ1KTtcblxuICAgICAgY2FzZSA3OlxuICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2KTtcblxuICAgICAgY2FzZSA4OlxuICAgICAgICByZXR1cm4gbmV3IEZuKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNyk7XG5cbiAgICAgIGNhc2UgOTpcbiAgICAgICAgcmV0dXJuIG5ldyBGbigkMCwgJDEsICQyLCAkMywgJDQsICQ1LCAkNiwgJDcsICQ4KTtcblxuICAgICAgY2FzZSAxMDpcbiAgICAgICAgcmV0dXJuIG5ldyBGbigkMCwgJDEsICQyLCAkMywgJDQsICQ1LCAkNiwgJDcsICQ4LCAkOSk7XG4gICAgfVxuICB9KSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY29uc3RydWN0TjsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkxLmpzXCI7XG5pbXBvcnQgY29uc3RydWN0TiBmcm9tIFwiLi9jb25zdHJ1Y3ROLmpzXCI7XG4vKipcbiAqIFdyYXBzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gaW5zaWRlIGEgY3VycmllZCBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWRcbiAqIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzIGFuZCByZXR1cm5zIHRoZSBzYW1lIHR5cGUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKCogLT4geyp9KSAtPiAoKiAtPiB7Kn0pXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIHdyYXBwZWQsIGN1cnJpZWQgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKiBAc2VlIFIuaW52b2tlclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIC8vIENvbnN0cnVjdG9yIGZ1bmN0aW9uXG4gKiAgICAgIGZ1bmN0aW9uIEFuaW1hbChraW5kKSB7XG4gKiAgICAgICAgdGhpcy5raW5kID0ga2luZDtcbiAqICAgICAgfTtcbiAqICAgICAgQW5pbWFsLnByb3RvdHlwZS5zaWdodGluZyA9IGZ1bmN0aW9uKCkge1xuICogICAgICAgIHJldHVybiBcIkl0J3MgYSBcIiArIHRoaXMua2luZCArIFwiIVwiO1xuICogICAgICB9XG4gKlxuICogICAgICBjb25zdCBBbmltYWxDb25zdHJ1Y3RvciA9IFIuY29uc3RydWN0KEFuaW1hbClcbiAqXG4gKiAgICAgIC8vIE5vdGljZSB3ZSBubyBsb25nZXIgbmVlZCB0aGUgJ25ldycga2V5d29yZDpcbiAqICAgICAgQW5pbWFsQ29uc3RydWN0b3IoJ1BpZycpOyAvLz0+IHtcImtpbmRcIjogXCJQaWdcIiwgXCJzaWdodGluZ1wiOiBmdW5jdGlvbiAoKXsuLi59fTtcbiAqXG4gKiAgICAgIGNvbnN0IGFuaW1hbFR5cGVzID0gW1wiTGlvblwiLCBcIlRpZ2VyXCIsIFwiQmVhclwiXTtcbiAqICAgICAgY29uc3QgYW5pbWFsU2lnaHRpbmcgPSBSLmludm9rZXIoMCwgJ3NpZ2h0aW5nJyk7XG4gKiAgICAgIGNvbnN0IHNpZ2h0TmV3QW5pbWFsID0gUi5jb21wb3NlKGFuaW1hbFNpZ2h0aW5nLCBBbmltYWxDb25zdHJ1Y3Rvcik7XG4gKiAgICAgIFIubWFwKHNpZ2h0TmV3QW5pbWFsLCBhbmltYWxUeXBlcyk7IC8vPT4gW1wiSXQncyBhIExpb24hXCIsIFwiSXQncyBhIFRpZ2VyIVwiLCBcIkl0J3MgYSBCZWFyIVwiXVxuICovXG5cbnZhciBjb25zdHJ1Y3QgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiBjb25zdHJ1Y3QoRm4pIHtcbiAgcmV0dXJuIGNvbnN0cnVjdE4oRm4ubGVuZ3RoLCBGbik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgY29uc3RydWN0OyIsImltcG9ydCBfaW5jbHVkZXMgZnJvbSBcIi4vaW50ZXJuYWwvX2luY2x1ZGVzLmpzXCI7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgZXF1YWwsIGluIFtgUi5lcXVhbHNgXSgjZXF1YWxzKVxuICogdGVybXMsIHRvIGF0IGxlYXN0IG9uZSBlbGVtZW50IG9mIHRoZSBnaXZlbiBsaXN0OyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqIFdvcmtzIGFsc28gd2l0aCBzdHJpbmdzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgYSAtPiBbYV0gLT4gQm9vbGVhblxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIGl0ZW0gdG8gY29tcGFyZSBhZ2FpbnN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYW4gZXF1aXZhbGVudCBpdGVtIGlzIGluIHRoZSBsaXN0LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqIEBzZWUgUi5pbmNsdWRlc1xuICogQGRlcHJlY2F0ZWQgc2luY2UgdjAuMjYuMFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuY29udGFpbnMoMywgWzEsIDIsIDNdKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuY29udGFpbnMoNCwgWzEsIDIsIDNdKTsgLy89PiBmYWxzZVxuICogICAgICBSLmNvbnRhaW5zKHsgbmFtZTogJ0ZyZWQnIH0sIFt7IG5hbWU6ICdGcmVkJyB9XSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmNvbnRhaW5zKFs0Ml0sIFtbNDJdXSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmNvbnRhaW5zKCdiYScsICdiYW5hbmEnKTsgLy89PnRydWVcbiAqL1xuXG52YXIgY29udGFpbnMgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihfaW5jbHVkZXMpO1xuXG5leHBvcnQgZGVmYXVsdCBjb250YWluczsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgX21hcCBmcm9tIFwiLi9pbnRlcm5hbC9fbWFwLmpzXCI7XG5pbXBvcnQgY3VycnlOIGZyb20gXCIuL2N1cnJ5Ti5qc1wiO1xuaW1wb3J0IG1heCBmcm9tIFwiLi9tYXguanNcIjtcbmltcG9ydCBwbHVjayBmcm9tIFwiLi9wbHVjay5qc1wiO1xuaW1wb3J0IHJlZHVjZSBmcm9tIFwiLi9yZWR1Y2UuanNcIjtcbi8qKlxuICogQWNjZXB0cyBhIGNvbnZlcmdpbmcgZnVuY3Rpb24gYW5kIGEgbGlzdCBvZiBicmFuY2hpbmcgZnVuY3Rpb25zIGFuZCByZXR1cm5zXG4gKiBhIG5ldyBmdW5jdGlvbi4gVGhlIGFyaXR5IG9mIHRoZSBuZXcgZnVuY3Rpb24gaXMgdGhlIHNhbWUgYXMgdGhlIGFyaXR5IG9mXG4gKiB0aGUgbG9uZ2VzdCBicmFuY2hpbmcgZnVuY3Rpb24uIFdoZW4gaW52b2tlZCwgdGhpcyBuZXcgZnVuY3Rpb24gaXMgYXBwbGllZFxuICogdG8gc29tZSBhcmd1bWVudHMsIGFuZCBlYWNoIGJyYW5jaGluZyBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIHRob3NlIHNhbWVcbiAqIGFyZ3VtZW50cy4gVGhlIHJlc3VsdHMgb2YgZWFjaCBicmFuY2hpbmcgZnVuY3Rpb24gYXJlIHBhc3NlZCBhcyBhcmd1bWVudHNcbiAqIHRvIHRoZSBjb252ZXJnaW5nIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHJldHVybiB2YWx1ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC40LjJcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKHgxLCB4MiwgLi4uKSAtPiB6KSAtPiBbKChhLCBiLCAuLi4pIC0+IHgxKSwgKChhLCBiLCAuLi4pIC0+IHgyKSwgLi4uXSAtPiAoYSAtPiBiIC0+IC4uLiAtPiB6KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYWZ0ZXIgQSBmdW5jdGlvbi4gYGFmdGVyYCB3aWxsIGJlIGludm9rZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlcyBvZlxuICogICAgICAgIGBmbjFgIGFuZCBgZm4yYCBhcyBpdHMgYXJndW1lbnRzLlxuICogQHBhcmFtIHtBcnJheX0gZnVuY3Rpb25zIEEgbGlzdCBvZiBmdW5jdGlvbnMuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24uXG4gKiBAc2VlIFIudXNlV2l0aFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGF2ZXJhZ2UgPSBSLmNvbnZlcmdlKFIuZGl2aWRlLCBbUi5zdW0sIFIubGVuZ3RoXSlcbiAqICAgICAgYXZlcmFnZShbMSwgMiwgMywgNCwgNSwgNiwgN10pIC8vPT4gNFxuICpcbiAqICAgICAgY29uc3Qgc3RyYW5nZUNvbmNhdCA9IFIuY29udmVyZ2UoUi5jb25jYXQsIFtSLnRvVXBwZXIsIFIudG9Mb3dlcl0pXG4gKiAgICAgIHN0cmFuZ2VDb25jYXQoXCJZb2RlbFwiKSAvLz0+IFwiWU9ERUx5b2RlbFwiXG4gKlxuICogQHN5bWIgUi5jb252ZXJnZShmLCBbZywgaF0pKGEsIGIpID0gZihnKGEsIGIpLCBoKGEsIGIpKVxuICovXG5cbnZhciBjb252ZXJnZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIGNvbnZlcmdlKGFmdGVyLCBmbnMpIHtcbiAgcmV0dXJuIGN1cnJ5TihyZWR1Y2UobWF4LCAwLCBwbHVjaygnbGVuZ3RoJywgZm5zKSksIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgcmV0dXJuIGFmdGVyLmFwcGx5KGNvbnRleHQsIF9tYXAoZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfSwgZm5zKSk7XG4gIH0pO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGNvbnZlcmdlOyIsImltcG9ydCBfY3VycnlOIGZyb20gXCIuL19jdXJyeU4uanNcIjtcbmltcG9ydCBfaGFzIGZyb20gXCIuL19oYXMuanNcIjtcbmltcG9ydCBfeGZCYXNlIGZyb20gXCIuL194ZkJhc2UuanNcIjtcblxudmFyIFhSZWR1Y2VCeSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhSZWR1Y2VCeSh2YWx1ZUZuLCB2YWx1ZUFjYywga2V5Rm4sIHhmKSB7XG4gICAgdGhpcy52YWx1ZUZuID0gdmFsdWVGbjtcbiAgICB0aGlzLnZhbHVlQWNjID0gdmFsdWVBY2M7XG4gICAgdGhpcy5rZXlGbiA9IGtleUZuO1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmlucHV0cyA9IHt9O1xuICB9XG5cbiAgWFJlZHVjZUJ5LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcblxuICBYUmVkdWNlQnkucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgdmFyIGtleTtcblxuICAgIGZvciAoa2V5IGluIHRoaXMuaW5wdXRzKSB7XG4gICAgICBpZiAoX2hhcyhrZXksIHRoaXMuaW5wdXRzKSkge1xuICAgICAgICByZXN1bHQgPSB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdGhpcy5pbnB1dHNba2V5XSk7XG5cbiAgICAgICAgaWYgKHJlc3VsdFsnQEB0cmFuc2R1Y2VyL3JlZHVjZWQnXSkge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdFsnQEB0cmFuc2R1Y2VyL3ZhbHVlJ107XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmlucHV0cyA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9O1xuXG4gIFhSZWR1Y2VCeS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIHZhciBrZXkgPSB0aGlzLmtleUZuKGlucHV0KTtcbiAgICB0aGlzLmlucHV0c1trZXldID0gdGhpcy5pbnB1dHNba2V5XSB8fCBba2V5LCB0aGlzLnZhbHVlQWNjXTtcbiAgICB0aGlzLmlucHV0c1trZXldWzFdID0gdGhpcy52YWx1ZUZuKHRoaXMuaW5wdXRzW2tleV1bMV0sIGlucHV0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBYUmVkdWNlQnk7XG59KCk7XG5cbnZhciBfeHJlZHVjZUJ5ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeU4oNCwgW10sIGZ1bmN0aW9uIF94cmVkdWNlQnkodmFsdWVGbiwgdmFsdWVBY2MsIGtleUZuLCB4Zikge1xuICByZXR1cm4gbmV3IFhSZWR1Y2VCeSh2YWx1ZUZuLCB2YWx1ZUFjYywga2V5Rm4sIHhmKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBfeHJlZHVjZUJ5OyIsImltcG9ydCBfY2xvbmUgZnJvbSBcIi4vaW50ZXJuYWwvX2Nsb25lLmpzXCI7XG5pbXBvcnQgX2N1cnJ5TiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnlOLmpzXCI7XG5pbXBvcnQgX2Rpc3BhdGNoYWJsZSBmcm9tIFwiLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlLmpzXCI7XG5pbXBvcnQgX2hhcyBmcm9tIFwiLi9pbnRlcm5hbC9faGFzLmpzXCI7XG5pbXBvcnQgX3JlZHVjZSBmcm9tIFwiLi9pbnRlcm5hbC9fcmVkdWNlLmpzXCI7XG5pbXBvcnQgX3hyZWR1Y2VCeSBmcm9tIFwiLi9pbnRlcm5hbC9feHJlZHVjZUJ5LmpzXCI7XG4vKipcbiAqIEdyb3VwcyB0aGUgZWxlbWVudHMgb2YgdGhlIGxpc3QgYWNjb3JkaW5nIHRvIHRoZSByZXN1bHQgb2YgY2FsbGluZ1xuICogdGhlIFN0cmluZy1yZXR1cm5pbmcgZnVuY3Rpb24gYGtleUZuYCBvbiBlYWNoIGVsZW1lbnQgYW5kIHJlZHVjZXMgdGhlIGVsZW1lbnRzXG4gKiBvZiBlYWNoIGdyb3VwIHRvIGEgc2luZ2xlIHZhbHVlIHZpYSB0aGUgcmVkdWNlciBmdW5jdGlvbiBgdmFsdWVGbmAuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBiYXNpY2FsbHkgYSBtb3JlIGdlbmVyYWwgW2Bncm91cEJ5YF0oI2dyb3VwQnkpIGZ1bmN0aW9uLlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yMC4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoKGEsIGIpIC0+IGEpIC0+IGEgLT4gKGIgLT4gU3RyaW5nKSAtPiBbYl0gLT4ge1N0cmluZzogYX1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHZhbHVlRm4gVGhlIGZ1bmN0aW9uIHRoYXQgcmVkdWNlcyB0aGUgZWxlbWVudHMgb2YgZWFjaCBncm91cCB0byBhIHNpbmdsZVxuICogICAgICAgIHZhbHVlLiBSZWNlaXZlcyB0d28gdmFsdWVzLCBhY2N1bXVsYXRvciBmb3IgYSBwYXJ0aWN1bGFyIGdyb3VwIGFuZCB0aGUgY3VycmVudCBlbGVtZW50LlxuICogQHBhcmFtIHsqfSBhY2MgVGhlIChpbml0aWFsKSBhY2N1bXVsYXRvciB2YWx1ZSBmb3IgZWFjaCBncm91cC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleUZuIFRoZSBmdW5jdGlvbiB0aGF0IG1hcHMgdGhlIGxpc3QncyBlbGVtZW50IGludG8gYSBrZXkuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBncm91cC5cbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIG91dHB1dCBvZiBga2V5Rm5gIGZvciBrZXlzLCBtYXBwZWQgdG8gdGhlIG91dHB1dCBvZlxuICogICAgICAgICBgdmFsdWVGbmAgZm9yIGVsZW1lbnRzIHdoaWNoIHByb2R1Y2VkIHRoYXQga2V5IHdoZW4gcGFzc2VkIHRvIGBrZXlGbmAuXG4gKiBAc2VlIFIuZ3JvdXBCeSwgUi5yZWR1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBncm91cE5hbWVzID0gKGFjYywge25hbWV9KSA9PiBhY2MuY29uY2F0KG5hbWUpXG4gKiAgICAgIGNvbnN0IHRvR3JhZGUgPSAoe3Njb3JlfSkgPT5cbiAqICAgICAgICBzY29yZSA8IDY1ID8gJ0YnIDpcbiAqICAgICAgICBzY29yZSA8IDcwID8gJ0QnIDpcbiAqICAgICAgICBzY29yZSA8IDgwID8gJ0MnIDpcbiAqICAgICAgICBzY29yZSA8IDkwID8gJ0InIDogJ0EnXG4gKlxuICogICAgICB2YXIgc3R1ZGVudHMgPSBbXG4gKiAgICAgICAge25hbWU6ICdBYmJ5Jywgc2NvcmU6IDgzfSxcbiAqICAgICAgICB7bmFtZTogJ0JhcnQnLCBzY29yZTogNjJ9LFxuICogICAgICAgIHtuYW1lOiAnQ3VydCcsIHNjb3JlOiA4OH0sXG4gKiAgICAgICAge25hbWU6ICdEb3JhJywgc2NvcmU6IDkyfSxcbiAqICAgICAgXVxuICpcbiAqICAgICAgcmVkdWNlQnkoZ3JvdXBOYW1lcywgW10sIHRvR3JhZGUsIHN0dWRlbnRzKVxuICogICAgICAvLz0+IHtcIkFcIjogW1wiRG9yYVwiXSwgXCJCXCI6IFtcIkFiYnlcIiwgXCJDdXJ0XCJdLCBcIkZcIjogW1wiQmFydFwiXX1cbiAqL1xuXG52YXIgcmVkdWNlQnkgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5Tig0LCBbXSxcbi8qI19fUFVSRV9fKi9cbl9kaXNwYXRjaGFibGUoW10sIF94cmVkdWNlQnksIGZ1bmN0aW9uIHJlZHVjZUJ5KHZhbHVlRm4sIHZhbHVlQWNjLCBrZXlGbiwgbGlzdCkge1xuICByZXR1cm4gX3JlZHVjZShmdW5jdGlvbiAoYWNjLCBlbHQpIHtcbiAgICB2YXIga2V5ID0ga2V5Rm4oZWx0KTtcbiAgICBhY2Nba2V5XSA9IHZhbHVlRm4oX2hhcyhrZXksIGFjYykgPyBhY2Nba2V5XSA6IF9jbG9uZSh2YWx1ZUFjYywgW10sIFtdLCBmYWxzZSksIGVsdCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30sIGxpc3QpO1xufSkpO1xuXG5leHBvcnQgZGVmYXVsdCByZWR1Y2VCeTsiLCJpbXBvcnQgcmVkdWNlQnkgZnJvbSBcIi4vcmVkdWNlQnkuanNcIjtcbi8qKlxuICogQ291bnRzIHRoZSBlbGVtZW50cyBvZiBhIGxpc3QgYWNjb3JkaW5nIHRvIGhvdyBtYW55IG1hdGNoIGVhY2ggdmFsdWUgb2YgYVxuICoga2V5IGdlbmVyYXRlZCBieSB0aGUgc3VwcGxpZWQgZnVuY3Rpb24uIFJldHVybnMgYW4gb2JqZWN0IG1hcHBpbmcgdGhlIGtleXNcbiAqIHByb2R1Y2VkIGJ5IGBmbmAgdG8gdGhlIG51bWJlciBvZiBvY2N1cnJlbmNlcyBpbiB0aGUgbGlzdC4gTm90ZSB0aGF0IGFsbFxuICoga2V5cyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGJlY2F1c2Ugb2YgaG93IEphdmFTY3JpcHQgb2JqZWN0cyB3b3JrLlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyAoYSAtPiBTdHJpbmcpIC0+IFthXSAtPiB7Kn1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB1c2VkIHRvIG1hcCB2YWx1ZXMgdG8ga2V5cy5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gY291bnQgZWxlbWVudHMgZnJvbS5cbiAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IG1hcHBpbmcga2V5cyB0byBudW1iZXIgb2Ygb2NjdXJyZW5jZXMgaW4gdGhlIGxpc3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgbnVtYmVycyA9IFsxLjAsIDEuMSwgMS4yLCAyLjAsIDMuMCwgMi4yXTtcbiAqICAgICAgUi5jb3VudEJ5KE1hdGguZmxvb3IpKG51bWJlcnMpOyAgICAvLz0+IHsnMSc6IDMsICcyJzogMiwgJzMnOiAxfVxuICpcbiAqICAgICAgY29uc3QgbGV0dGVycyA9IFsnYScsICdiJywgJ0EnLCAnYScsICdCJywgJ2MnXTtcbiAqICAgICAgUi5jb3VudEJ5KFIudG9Mb3dlcikobGV0dGVycyk7ICAgLy89PiB7J2EnOiAzLCAnYic6IDIsICdjJzogMX1cbiAqL1xuXG52YXIgY291bnRCeSA9XG4vKiNfX1BVUkVfXyovXG5yZWR1Y2VCeShmdW5jdGlvbiAoYWNjLCBlbGVtKSB7XG4gIHJldHVybiBhY2MgKyAxO1xufSwgMCk7XG5leHBvcnQgZGVmYXVsdCBjb3VudEJ5OyIsImltcG9ydCBhZGQgZnJvbSBcIi4vYWRkLmpzXCI7XG4vKipcbiAqIERlY3JlbWVudHMgaXRzIGFyZ3VtZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge051bWJlcn0gbiAtIDFcbiAqIEBzZWUgUi5pbmNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmRlYyg0Mik7IC8vPT4gNDFcbiAqL1xuXG52YXIgZGVjID1cbi8qI19fUFVSRV9fKi9cbmFkZCgtMSk7XG5leHBvcnQgZGVmYXVsdCBkZWM7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBzZWNvbmQgYXJndW1lbnQgaWYgaXQgaXMgbm90IGBudWxsYCwgYHVuZGVmaW5lZGAgb3IgYE5hTmA7XG4gKiBvdGhlcndpc2UgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIHJldHVybmVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyBhIC0+IGIgLT4gYSB8IGJcbiAqIEBwYXJhbSB7YX0gZGVmYXVsdCBUaGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSB7Yn0gdmFsIGB2YWxgIHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiBgZGVmYXVsdGAgdW5sZXNzIGB2YWxgIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAgb3IgYE5hTmAuXG4gKiBAcmV0dXJuIHsqfSBUaGUgc2Vjb25kIHZhbHVlIGlmIGl0IGlzIG5vdCBgbnVsbGAsIGB1bmRlZmluZWRgIG9yIGBOYU5gLCBvdGhlcndpc2UgdGhlIGRlZmF1bHQgdmFsdWVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBkZWZhdWx0VG80MiA9IFIuZGVmYXVsdFRvKDQyKTtcbiAqXG4gKiAgICAgIGRlZmF1bHRUbzQyKG51bGwpOyAgLy89PiA0MlxuICogICAgICBkZWZhdWx0VG80Mih1bmRlZmluZWQpOyAgLy89PiA0MlxuICogICAgICBkZWZhdWx0VG80MihmYWxzZSk7ICAvLz0+IGZhbHNlXG4gKiAgICAgIGRlZmF1bHRUbzQyKCdSYW1kYScpOyAgLy89PiAnUmFtZGEnXG4gKiAgICAgIC8vIHBhcnNlSW50KCdzdHJpbmcnKSByZXN1bHRzIGluIE5hTlxuICogICAgICBkZWZhdWx0VG80MihwYXJzZUludCgnc3RyaW5nJykpOyAvLz0+IDQyXG4gKi9cblxudmFyIGRlZmF1bHRUbyA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIGRlZmF1bHRUbyhkLCB2KSB7XG4gIHJldHVybiB2ID09IG51bGwgfHwgdiAhPT0gdiA/IGQgOiB2O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRlZmF1bHRUbzsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkzLmpzXCI7XG4vKipcbiAqIE1ha2VzIGEgZGVzY2VuZGluZyBjb21wYXJhdG9yIGZ1bmN0aW9uIG91dCBvZiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHZhbHVlXG4gKiB0aGF0IGNhbiBiZSBjb21wYXJlZCB3aXRoIGA8YCBhbmQgYD5gLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIzLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBPcmQgYiA9PiAoYSAtPiBiKSAtPiBhIC0+IGEgLT4gTnVtYmVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBBIGZ1bmN0aW9uIG9mIGFyaXR5IG9uZSB0aGF0IHJldHVybnMgYSB2YWx1ZSB0aGF0IGNhbiBiZSBjb21wYXJlZFxuICogQHBhcmFtIHsqfSBhIFRoZSBmaXJzdCBpdGVtIHRvIGJlIGNvbXBhcmVkLlxuICogQHBhcmFtIHsqfSBiIFRoZSBzZWNvbmQgaXRlbSB0byBiZSBjb21wYXJlZC5cbiAqIEByZXR1cm4ge051bWJlcn0gYC0xYCBpZiBmbihhKSA+IGZuKGIpLCBgMWAgaWYgZm4oYikgPiBmbihhKSwgb3RoZXJ3aXNlIGAwYFxuICogQHNlZSBSLmFzY2VuZFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGJ5QWdlID0gUi5kZXNjZW5kKFIucHJvcCgnYWdlJykpO1xuICogICAgICBjb25zdCBwZW9wbGUgPSBbXG4gKiAgICAgICAgeyBuYW1lOiAnRW1tYScsIGFnZTogNzAgfSxcbiAqICAgICAgICB7IG5hbWU6ICdQZXRlcicsIGFnZTogNzggfSxcbiAqICAgICAgICB7IG5hbWU6ICdNaWtoYWlsJywgYWdlOiA2MiB9LFxuICogICAgICBdO1xuICogICAgICBjb25zdCBwZW9wbGVCeU9sZGVzdEZpcnN0ID0gUi5zb3J0KGJ5QWdlLCBwZW9wbGUpO1xuICogICAgICAgIC8vPT4gW3sgbmFtZTogJ1BldGVyJywgYWdlOiA3OCB9LCB7IG5hbWU6ICdFbW1hJywgYWdlOiA3MCB9LCB7IG5hbWU6ICdNaWtoYWlsJywgYWdlOiA2MiB9XVxuICovXG5cbnZhciBkZXNjZW5kID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTMoZnVuY3Rpb24gZGVzY2VuZChmbiwgYSwgYikge1xuICB2YXIgYWEgPSBmbihhKTtcbiAgdmFyIGJiID0gZm4oYik7XG4gIHJldHVybiBhYSA+IGJiID8gLTEgOiBhYSA8IGJiID8gMSA6IDA7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZGVzY2VuZDsiLCJpbXBvcnQgX2luY2x1ZGVzIGZyb20gXCIuL19pbmNsdWRlcy5qc1wiO1xuXG52YXIgX1NldCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIF9TZXQoKSB7XG4gICAgLyogZ2xvYmFscyBTZXQgKi9cbiAgICB0aGlzLl9uYXRpdmVTZXQgPSB0eXBlb2YgU2V0ID09PSAnZnVuY3Rpb24nID8gbmV3IFNldCgpIDogbnVsbDtcbiAgICB0aGlzLl9pdGVtcyA9IHt9O1xuICB9XG5cbiAgLy8gdW50aWwgd2UgZmlndXJlIG91dCB3aHkganNkb2MgY2hva2VzIG9uIHRoaXNcbiAgLy8gQHBhcmFtIGl0ZW0gVGhlIGl0ZW0gdG8gYWRkIHRvIHRoZSBTZXRcbiAgLy8gQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIGl0ZW0gZGlkIG5vdCBleGlzdCBwcmlvciwgb3RoZXJ3aXNlIGZhbHNlXG4gIC8vXG4gIF9TZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuICFoYXNPckFkZChpdGVtLCB0cnVlLCB0aGlzKTtcbiAgfTsgLy9cbiAgLy8gQHBhcmFtIGl0ZW0gVGhlIGl0ZW0gdG8gY2hlY2sgZm9yIGV4aXN0ZW5jZSBpbiB0aGUgU2V0XG4gIC8vIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSBpdGVtIGV4aXN0cyBpbiB0aGUgU2V0LCBvdGhlcndpc2UgZmFsc2VcbiAgLy9cblxuXG4gIF9TZXQucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGhhc09yQWRkKGl0ZW0sIGZhbHNlLCB0aGlzKTtcbiAgfTsgLy9cbiAgLy8gQ29tYmluZXMgdGhlIGxvZ2ljIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIGl0ZW0gaXMgYSBtZW1iZXIgb2YgdGhlIHNldCBhbmRcbiAgLy8gZm9yIGFkZGluZyBhIG5ldyBpdGVtIHRvIHRoZSBzZXQuXG4gIC8vXG4gIC8vIEBwYXJhbSBpdGVtICAgICAgIFRoZSBpdGVtIHRvIGNoZWNrIG9yIGFkZCB0byB0aGUgU2V0IGluc3RhbmNlLlxuICAvLyBAcGFyYW0gc2hvdWxkQWRkICBJZiB0cnVlLCB0aGUgaXRlbSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzZXQgaWYgaXQgZG9lc24ndFxuICAvLyAgICAgICAgICAgICAgICAgICBhbHJlYWR5IGV4aXN0LlxuICAvLyBAcGFyYW0gc2V0ICAgICAgICBUaGUgc2V0IGluc3RhbmNlIHRvIGNoZWNrIG9yIGFkZCB0by5cbiAgLy8gQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgaXRlbSBhbHJlYWR5IGV4aXN0ZWQsIG90aGVyd2lzZSBmYWxzZS5cbiAgLy9cblxuXG4gIHJldHVybiBfU2V0O1xufSgpO1xuXG5mdW5jdGlvbiBoYXNPckFkZChpdGVtLCBzaG91bGRBZGQsIHNldCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBpdGVtO1xuICB2YXIgcHJldlNpemUsIG5ld1NpemU7XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgLy8gZGlzdGluZ3Vpc2ggYmV0d2VlbiArMCBhbmQgLTBcbiAgICAgIGlmIChpdGVtID09PSAwICYmIDEgLyBpdGVtID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgaWYgKHNldC5faXRlbXNbJy0wJ10pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICBzZXQuX2l0ZW1zWyctMCddID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gdGhlc2UgdHlwZXMgY2FuIGFsbCB1dGlsaXNlIHRoZSBuYXRpdmUgU2V0XG5cblxuICAgICAgaWYgKHNldC5fbmF0aXZlU2V0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICBwcmV2U2l6ZSA9IHNldC5fbmF0aXZlU2V0LnNpemU7XG5cbiAgICAgICAgICBzZXQuX25hdGl2ZVNldC5hZGQoaXRlbSk7XG5cbiAgICAgICAgICBuZXdTaXplID0gc2V0Ll9uYXRpdmVTZXQuc2l6ZTtcbiAgICAgICAgICByZXR1cm4gbmV3U2l6ZSA9PT0gcHJldlNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNldC5fbmF0aXZlU2V0LmhhcyhpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEodHlwZSBpbiBzZXQuX2l0ZW1zKSkge1xuICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV0gPSB7fTtcbiAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV1baXRlbV0gPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtIGluIHNldC5faXRlbXNbdHlwZV0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdW2l0ZW1dID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgLy8gc2V0Ll9pdGVtc1snYm9vbGVhbiddIGhvbGRzIGEgdHdvIGVsZW1lbnQgYXJyYXlcbiAgICAgIC8vIHJlcHJlc2VudGluZyBbIGZhbHNlRXhpc3RzLCB0cnVlRXhpc3RzIF1cbiAgICAgIGlmICh0eXBlIGluIHNldC5faXRlbXMpIHtcbiAgICAgICAgdmFyIGJJZHggPSBpdGVtID8gMSA6IDA7XG5cbiAgICAgICAgaWYgKHNldC5faXRlbXNbdHlwZV1bYklkeF0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdW2JJZHhdID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdID0gaXRlbSA/IFtmYWxzZSwgdHJ1ZV0gOiBbdHJ1ZSwgZmFsc2VdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgLy8gY29tcGFyZSBmdW5jdGlvbnMgZm9yIHJlZmVyZW5jZSBlcXVhbGl0eVxuICAgICAgaWYgKHNldC5fbmF0aXZlU2V0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICBwcmV2U2l6ZSA9IHNldC5fbmF0aXZlU2V0LnNpemU7XG5cbiAgICAgICAgICBzZXQuX25hdGl2ZVNldC5hZGQoaXRlbSk7XG5cbiAgICAgICAgICBuZXdTaXplID0gc2V0Ll9uYXRpdmVTZXQuc2l6ZTtcbiAgICAgICAgICByZXR1cm4gbmV3U2l6ZSA9PT0gcHJldlNpemU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNldC5fbmF0aXZlU2V0LmhhcyhpdGVtKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCEodHlwZSBpbiBzZXQuX2l0ZW1zKSkge1xuICAgICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICAgIHNldC5faXRlbXNbdHlwZV0gPSBbaXRlbV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFfaW5jbHVkZXMoaXRlbSwgc2V0Ll9pdGVtc1t0eXBlXSkpIHtcbiAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdLnB1c2goaXRlbSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgaWYgKHNldC5faXRlbXNbdHlwZV0pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgc2V0Ll9pdGVtc1t0eXBlXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKGl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFzZXQuX2l0ZW1zWydudWxsJ10pIHtcbiAgICAgICAgICBpZiAoc2hvdWxkQWRkKSB7XG4gICAgICAgICAgICBzZXQuX2l0ZW1zWydudWxsJ10gPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIHJlZHVjZSB0aGUgc2VhcmNoIHNpemUgb2YgaGV0ZXJvZ2VuZW91cyBzZXRzIGJ5IGNyZWF0aW5nIGJ1Y2tldHNcbiAgICAgIC8vIGZvciBlYWNoIHR5cGUuXG4gICAgICB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZW0pO1xuXG4gICAgICBpZiAoISh0eXBlIGluIHNldC5faXRlbXMpKSB7XG4gICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdID0gW2l0ZW1dO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSAvLyBzY2FuIHRocm91Z2ggYWxsIHByZXZpb3VzbHkgYXBwbGllZCBpdGVtc1xuXG5cbiAgICAgIGlmICghX2luY2x1ZGVzKGl0ZW0sIHNldC5faXRlbXNbdHlwZV0pKSB7XG4gICAgICAgIGlmIChzaG91bGRBZGQpIHtcbiAgICAgICAgICBzZXQuX2l0ZW1zW3R5cGVdLnB1c2goaXRlbSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59IC8vIEEgc2ltcGxlIFNldCB0eXBlIHRoYXQgaG9ub3VycyBSLmVxdWFscyBzZW1hbnRpY3NcblxuXG5leHBvcnQgZGVmYXVsdCBfU2V0OyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbmltcG9ydCBfU2V0IGZyb20gXCIuL2ludGVybmFsL19TZXQuanNcIjtcbi8qKlxuICogRmluZHMgdGhlIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBvZiBhbGwgZWxlbWVudHMgaW4gdGhlIGZpcnN0IGxpc3Qgbm90XG4gKiBjb250YWluZWQgaW4gdGhlIHNlY29uZCBsaXN0LiBPYmplY3RzIGFuZCBBcnJheXMgYXJlIGNvbXBhcmVkIGluIHRlcm1zIG9mXG4gKiB2YWx1ZSBlcXVhbGl0eSwgbm90IHJlZmVyZW5jZSBlcXVhbGl0eS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBbKl0gLT4gWypdIC0+IFsqXVxuICogQHBhcmFtIHtBcnJheX0gbGlzdDEgVGhlIGZpcnN0IGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGVsZW1lbnRzIGluIGBsaXN0MWAgdGhhdCBhcmUgbm90IGluIGBsaXN0MmAuXG4gKiBAc2VlIFIuZGlmZmVyZW5jZVdpdGgsIFIuc3ltbWV0cmljRGlmZmVyZW5jZSwgUi5zeW1tZXRyaWNEaWZmZXJlbmNlV2l0aCwgUi53aXRob3V0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5kaWZmZXJlbmNlKFsxLDIsMyw0XSwgWzcsNiw1LDQsM10pOyAvLz0+IFsxLDJdXG4gKiAgICAgIFIuZGlmZmVyZW5jZShbNyw2LDUsNCwzXSwgWzEsMiwzLDRdKTsgLy89PiBbNyw2LDVdXG4gKiAgICAgIFIuZGlmZmVyZW5jZShbe2E6IDF9LCB7YjogMn1dLCBbe2E6IDF9LCB7YzogM31dKSAvLz0+IFt7YjogMn1dXG4gKi9cblxudmFyIGRpZmZlcmVuY2UgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBkaWZmZXJlbmNlKGZpcnN0LCBzZWNvbmQpIHtcbiAgdmFyIG91dCA9IFtdO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGZpcnN0TGVuID0gZmlyc3QubGVuZ3RoO1xuICB2YXIgc2Vjb25kTGVuID0gc2Vjb25kLmxlbmd0aDtcbiAgdmFyIHRvRmlsdGVyT3V0ID0gbmV3IF9TZXQoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlY29uZExlbjsgaSArPSAxKSB7XG4gICAgdG9GaWx0ZXJPdXQuYWRkKHNlY29uZFtpXSk7XG4gIH1cblxuICB3aGlsZSAoaWR4IDwgZmlyc3RMZW4pIHtcbiAgICBpZiAodG9GaWx0ZXJPdXQuYWRkKGZpcnN0W2lkeF0pKSB7XG4gICAgICBvdXRbb3V0Lmxlbmd0aF0gPSBmaXJzdFtpZHhdO1xuICAgIH1cblxuICAgIGlkeCArPSAxO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBkaWZmZXJlbmNlOyIsImltcG9ydCBfaW5jbHVkZXNXaXRoIGZyb20gXCIuL2ludGVybmFsL19pbmNsdWRlc1dpdGguanNcIjtcbmltcG9ydCBfY3VycnkzIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTMuanNcIjtcbi8qKlxuICogRmluZHMgdGhlIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBvZiBhbGwgZWxlbWVudHMgaW4gdGhlIGZpcnN0IGxpc3Qgbm90XG4gKiBjb250YWluZWQgaW4gdGhlIHNlY29uZCBsaXN0LiBEdXBsaWNhdGlvbiBpcyBkZXRlcm1pbmVkIGFjY29yZGluZyB0byB0aGVcbiAqIHZhbHVlIHJldHVybmVkIGJ5IGFwcGx5aW5nIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgdG8gdHdvIGxpc3QgZWxlbWVudHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgKChhLCBhKSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSB1c2VkIHRvIHRlc3Qgd2hldGhlciB0d28gaXRlbXMgYXJlIGVxdWFsLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDEgVGhlIGZpcnN0IGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGVsZW1lbnRzIGluIGBsaXN0MWAgdGhhdCBhcmUgbm90IGluIGBsaXN0MmAuXG4gKiBAc2VlIFIuZGlmZmVyZW5jZSwgUi5zeW1tZXRyaWNEaWZmZXJlbmNlLCBSLnN5bW1ldHJpY0RpZmZlcmVuY2VXaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgY21wID0gKHgsIHkpID0+IHguYSA9PT0geS5hO1xuICogICAgICBjb25zdCBsMSA9IFt7YTogMX0sIHthOiAyfSwge2E6IDN9XTtcbiAqICAgICAgY29uc3QgbDIgPSBbe2E6IDN9LCB7YTogNH1dO1xuICogICAgICBSLmRpZmZlcmVuY2VXaXRoKGNtcCwgbDEsIGwyKTsgLy89PiBbe2E6IDF9LCB7YTogMn1dXG4gKi9cblxudmFyIGRpZmZlcmVuY2VXaXRoID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTMoZnVuY3Rpb24gZGlmZmVyZW5jZVdpdGgocHJlZCwgZmlyc3QsIHNlY29uZCkge1xuICB2YXIgb3V0ID0gW107XG4gIHZhciBpZHggPSAwO1xuICB2YXIgZmlyc3RMZW4gPSBmaXJzdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGlkeCA8IGZpcnN0TGVuKSB7XG4gICAgaWYgKCFfaW5jbHVkZXNXaXRoKHByZWQsIGZpcnN0W2lkeF0sIHNlY29uZCkgJiYgIV9pbmNsdWRlc1dpdGgocHJlZCwgZmlyc3RbaWR4XSwgb3V0KSkge1xuICAgICAgb3V0LnB1c2goZmlyc3RbaWR4XSk7XG4gICAgfVxuXG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRpZmZlcmVuY2VXaXRoOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogUmV0dXJucyBhIG5ldyBvYmplY3QgdGhhdCBkb2VzIG5vdCBjb250YWluIGEgYHByb3BgIHByb3BlcnR5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgU3RyaW5nIC0+IHtrOiB2fSAtPiB7azogdn1cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBkaXNzb2NpYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2xvbmVcbiAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IGVxdWl2YWxlbnQgdG8gdGhlIG9yaWdpbmFsIGJ1dCB3aXRob3V0IHRoZSBzcGVjaWZpZWQgcHJvcGVydHlcbiAqIEBzZWUgUi5hc3NvYywgUi5vbWl0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5kaXNzb2MoJ2InLCB7YTogMSwgYjogMiwgYzogM30pOyAvLz0+IHthOiAxLCBjOiAzfVxuICovXG5cbnZhciBkaXNzb2MgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBkaXNzb2MocHJvcCwgb2JqKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBmb3IgKHZhciBwIGluIG9iaikge1xuICAgIHJlc3VsdFtwXSA9IG9ialtwXTtcbiAgfVxuXG4gIGRlbGV0ZSByZXN1bHRbcHJvcF07XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZGlzc29jOyIsImltcG9ydCBfY3VycnkzIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTMuanNcIjtcbi8qKlxuICogUmVtb3ZlcyB0aGUgc3ViLWxpc3Qgb2YgYGxpc3RgIHN0YXJ0aW5nIGF0IGluZGV4IGBzdGFydGAgYW5kIGNvbnRhaW5pbmdcbiAqIGBjb3VudGAgZWxlbWVudHMuIF9Ob3RlIHRoYXQgdGhpcyBpcyBub3QgZGVzdHJ1Y3RpdmVfOiBpdCByZXR1cm5zIGEgY29weSBvZlxuICogdGhlIGxpc3Qgd2l0aCB0aGUgY2hhbmdlcy5cbiAqIDxzbWFsbD5ObyBsaXN0cyBoYXZlIGJlZW4gaGFybWVkIGluIHRoZSBhcHBsaWNhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uLjwvc21hbGw+XG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMi4yXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBUaGUgcG9zaXRpb24gdG8gc3RhcnQgcmVtb3ZpbmcgZWxlbWVudHNcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJlbW92ZVxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byByZW1vdmUgZnJvbVxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IEFycmF5IHdpdGggYGNvdW50YCBlbGVtZW50cyBmcm9tIGBzdGFydGAgcmVtb3ZlZC5cbiAqIEBzZWUgUi53aXRob3V0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5yZW1vdmUoMiwgMywgWzEsMiwzLDQsNSw2LDcsOF0pOyAvLz0+IFsxLDIsNiw3LDhdXG4gKi9cblxudmFyIHJlbW92ZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKGZ1bmN0aW9uIHJlbW92ZShzdGFydCwgY291bnQsIGxpc3QpIHtcbiAgdmFyIHJlc3VsdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIDApO1xuICByZXN1bHQuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVtb3ZlOyIsImltcG9ydCBfY3VycnkzIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTMuanNcIjtcbmltcG9ydCBhZGp1c3QgZnJvbSBcIi4vYWRqdXN0LmpzXCI7XG5pbXBvcnQgYWx3YXlzIGZyb20gXCIuL2Fsd2F5cy5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGNvcHkgb2YgdGhlIGFycmF5IHdpdGggdGhlIGVsZW1lbnQgYXQgdGhlIHByb3ZpZGVkIGluZGV4XG4gKiByZXBsYWNlZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNC4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gYSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge051bWJlcn0gaWR4IFRoZSBpbmRleCB0byB1cGRhdGUuXG4gKiBAcGFyYW0geyp9IHggVGhlIHZhbHVlIHRvIGV4aXN0IGF0IHRoZSBnaXZlbiBpbmRleCBvZiB0aGUgcmV0dXJuZWQgYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fEFyZ3VtZW50c30gbGlzdCBUaGUgc291cmNlIGFycmF5LWxpa2Ugb2JqZWN0IHRvIGJlIHVwZGF0ZWQuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBjb3B5IG9mIGBsaXN0YCB3aXRoIHRoZSB2YWx1ZSBhdCBpbmRleCBgaWR4YCByZXBsYWNlZCB3aXRoIGB4YC5cbiAqIEBzZWUgUi5hZGp1c3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnVwZGF0ZSgxLCAnXycsIFsnYScsICdiJywgJ2MnXSk7ICAgICAgLy89PiBbJ2EnLCAnXycsICdjJ11cbiAqICAgICAgUi51cGRhdGUoLTEsICdfJywgWydhJywgJ2InLCAnYyddKTsgICAgIC8vPT4gWydhJywgJ2InLCAnXyddXG4gKiBAc3ltYiBSLnVwZGF0ZSgtMSwgYSwgW2IsIGNdKSA9IFtiLCBhXVxuICogQHN5bWIgUi51cGRhdGUoMCwgYSwgW2IsIGNdKSA9IFthLCBjXVxuICogQHN5bWIgUi51cGRhdGUoMSwgYSwgW2IsIGNdKSA9IFtiLCBhXVxuICovXG5cbnZhciB1cGRhdGUgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MyhmdW5jdGlvbiB1cGRhdGUoaWR4LCB4LCBsaXN0KSB7XG4gIHJldHVybiBhZGp1c3QoaWR4LCBhbHdheXMoeCksIGxpc3QpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHVwZGF0ZTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgX2lzSW50ZWdlciBmcm9tIFwiLi9pbnRlcm5hbC9faXNJbnRlZ2VyLmpzXCI7XG5pbXBvcnQgX2lzQXJyYXkgZnJvbSBcIi4vaW50ZXJuYWwvX2lzQXJyYXkuanNcIjtcbmltcG9ydCBhc3NvYyBmcm9tIFwiLi9hc3NvYy5qc1wiO1xuaW1wb3J0IGRpc3NvYyBmcm9tIFwiLi9kaXNzb2MuanNcIjtcbmltcG9ydCByZW1vdmUgZnJvbSBcIi4vcmVtb3ZlLmpzXCI7XG5pbXBvcnQgdXBkYXRlIGZyb20gXCIuL3VwZGF0ZS5qc1wiO1xuLyoqXG4gKiBNYWtlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYW4gb2JqZWN0LCBvbWl0dGluZyB0aGUgcHJvcGVydHkgYXQgdGhlIGdpdmVuIHBhdGguXG4gKiBOb3RlIHRoYXQgdGhpcyBjb3BpZXMgYW5kIGZsYXR0ZW5zIHByb3RvdHlwZSBwcm9wZXJ0aWVzIG9udG8gdGhlIG5ldyBvYmplY3RcbiAqIGFzIHdlbGwuIEFsbCBub24tcHJpbWl0aXZlIHByb3BlcnRpZXMgYXJlIGNvcGllZCBieSByZWZlcmVuY2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHR5cGVkZWZuIElkeCA9IFN0cmluZyB8IEludFxuICogQHNpZyBbSWR4XSAtPiB7azogdn0gLT4ge2s6IHZ9XG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIHRoZSB2YWx1ZSB0byBvbWl0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2xvbmVcbiAqIEByZXR1cm4ge09iamVjdH0gQSBuZXcgb2JqZWN0IHdpdGhvdXQgdGhlIHByb3BlcnR5IGF0IHBhdGhcbiAqIEBzZWUgUi5hc3NvY1BhdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmRpc3NvY1BhdGgoWydhJywgJ2InLCAnYyddLCB7YToge2I6IHtjOiA0Mn19fSk7IC8vPT4ge2E6IHtiOiB7fX19XG4gKi9cblxudmFyIGRpc3NvY1BhdGggPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBkaXNzb2NQYXRoKHBhdGgsIG9iaikge1xuICBzd2l0Y2ggKHBhdGgubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIG9iajtcblxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBfaXNJbnRlZ2VyKHBhdGhbMF0pICYmIF9pc0FycmF5KG9iaikgPyByZW1vdmUocGF0aFswXSwgMSwgb2JqKSA6IGRpc3NvYyhwYXRoWzBdLCBvYmopO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBoZWFkID0gcGF0aFswXTtcbiAgICAgIHZhciB0YWlsID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwocGF0aCwgMSk7XG5cbiAgICAgIGlmIChvYmpbaGVhZF0gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSBlbHNlIGlmIChfaXNJbnRlZ2VyKGhlYWQpICYmIF9pc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZShoZWFkLCBkaXNzb2NQYXRoKHRhaWwsIG9ialtoZWFkXSksIG9iaik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYXNzb2MoaGVhZCwgZGlzc29jUGF0aCh0YWlsLCBvYmpbaGVhZF0pLCBvYmopO1xuICAgICAgfVxuXG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBkaXNzb2NQYXRoOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogRGl2aWRlcyB0d28gbnVtYmVycy4gRXF1aXZhbGVudCB0byBgYSAvIGJgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBiIFRoZSBzZWNvbmQgdmFsdWUuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXN1bHQgb2YgYGEgLyBiYC5cbiAqIEBzZWUgUi5tdWx0aXBseVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZGl2aWRlKDcxLCAxMDApOyAvLz0+IDAuNzFcbiAqXG4gKiAgICAgIGNvbnN0IGhhbGYgPSBSLmRpdmlkZShSLl9fLCAyKTtcbiAqICAgICAgaGFsZig0Mik7IC8vPT4gMjFcbiAqXG4gKiAgICAgIGNvbnN0IHJlY2lwcm9jYWwgPSBSLmRpdmlkZSgxKTtcbiAqICAgICAgcmVjaXByb2NhbCg0KTsgICAvLz0+IDAuMjVcbiAqL1xuXG52YXIgZGl2aWRlID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gZGl2aWRlKGEsIGIpIHtcbiAgcmV0dXJuIGEgLyBiO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRpdmlkZTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9fY3VycnkyLmpzXCI7XG5pbXBvcnQgX3hmQmFzZSBmcm9tIFwiLi9feGZCYXNlLmpzXCI7XG5cbnZhciBYRHJvcCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhEcm9wKG4sIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMubiA9IG47XG4gIH1cblxuICBYRHJvcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhEcm9wLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gX3hmQmFzZS5yZXN1bHQ7XG5cbiAgWERyb3AucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICBpZiAodGhpcy5uID4gMCkge1xuICAgICAgdGhpcy5uIC09IDE7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgaW5wdXQpO1xuICB9O1xuXG4gIHJldHVybiBYRHJvcDtcbn0oKTtcblxudmFyIF94ZHJvcCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIF94ZHJvcChuLCB4Zikge1xuICByZXR1cm4gbmV3IFhEcm9wKG4sIHhmKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBfeGRyb3A7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSBcIi4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZS5qc1wiO1xuaW1wb3J0IF94ZHJvcCBmcm9tIFwiLi9pbnRlcm5hbC9feGRyb3AuanNcIjtcbmltcG9ydCBzbGljZSBmcm9tIFwiLi9zbGljZS5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGFsbCBidXQgdGhlIGZpcnN0IGBuYCBlbGVtZW50cyBvZiB0aGUgZ2l2ZW4gbGlzdCwgc3RyaW5nLCBvclxuICogdHJhbnNkdWNlci90cmFuc2Zvcm1lciAob3Igb2JqZWN0IHdpdGggYSBgZHJvcGAgbWV0aG9kKS5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgZHJvcGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IFthXVxuICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEBwYXJhbSB7Kn0gbGlzdFxuICogQHJldHVybiB7Kn0gQSBjb3B5IG9mIGxpc3Qgd2l0aG91dCB0aGUgZmlyc3QgYG5gIGVsZW1lbnRzXG4gKiBAc2VlIFIudGFrZSwgUi50cmFuc2R1Y2UsIFIuZHJvcExhc3QsIFIuZHJvcFdoaWxlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5kcm9wKDEsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydiYXInLCAnYmF6J11cbiAqICAgICAgUi5kcm9wKDIsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydiYXonXVxuICogICAgICBSLmRyb3AoMywgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbXVxuICogICAgICBSLmRyb3AoNCwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbXVxuICogICAgICBSLmRyb3AoMywgJ3JhbWRhJyk7ICAgICAgICAgICAgICAgLy89PiAnZGEnXG4gKi9cblxudmFyIGRyb3AgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5Mihcbi8qI19fUFVSRV9fKi9cbl9kaXNwYXRjaGFibGUoWydkcm9wJ10sIF94ZHJvcCwgZnVuY3Rpb24gZHJvcChuLCB4cykge1xuICByZXR1cm4gc2xpY2UoTWF0aC5tYXgoMCwgbiksIEluZmluaXR5LCB4cyk7XG59KSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRyb3A7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9yZWR1Y2VkIGZyb20gXCIuL19yZWR1Y2VkLmpzXCI7XG5pbXBvcnQgX3hmQmFzZSBmcm9tIFwiLi9feGZCYXNlLmpzXCI7XG5cbnZhciBYVGFrZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhUYWtlKG4sIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMubiA9IG47XG4gICAgdGhpcy5pID0gMDtcbiAgfVxuXG4gIFhUYWtlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWFRha2UucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcblxuICBYVGFrZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIHRoaXMuaSArPSAxO1xuICAgIHZhciByZXQgPSB0aGlzLm4gPT09IDAgPyByZXN1bHQgOiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgaW5wdXQpO1xuICAgIHJldHVybiB0aGlzLm4gPj0gMCAmJiB0aGlzLmkgPj0gdGhpcy5uID8gX3JlZHVjZWQocmV0KSA6IHJldDtcbiAgfTtcblxuICByZXR1cm4gWFRha2U7XG59KCk7XG5cbnZhciBfeHRha2UgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBfeHRha2UobiwgeGYpIHtcbiAgcmV0dXJuIG5ldyBYVGFrZShuLCB4Zik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgX3h0YWtlOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gXCIuL2ludGVybmFsL19kaXNwYXRjaGFibGUuanNcIjtcbmltcG9ydCBfeHRha2UgZnJvbSBcIi4vaW50ZXJuYWwvX3h0YWtlLmpzXCI7XG5pbXBvcnQgc2xpY2UgZnJvbSBcIi4vc2xpY2UuanNcIjtcbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgYG5gIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBsaXN0LCBzdHJpbmcsIG9yXG4gKiB0cmFuc2R1Y2VyL3RyYW5zZm9ybWVyIChvciBvYmplY3Qgd2l0aCBhIGB0YWtlYCBtZXRob2QpLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGB0YWtlYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW2FdXG4gKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLmRyb3BcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRha2UoMSwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbyddXG4gKiAgICAgIFIudGFrZSgyLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhciddXG4gKiAgICAgIFIudGFrZSgzLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJywgJ2JhcicsICdiYXonXVxuICogICAgICBSLnRha2UoNCwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAqICAgICAgUi50YWtlKDMsICdyYW1kYScpOyAgICAgICAgICAgICAgIC8vPT4gJ3JhbSdcbiAqXG4gKiAgICAgIGNvbnN0IHBlcnNvbm5lbCA9IFtcbiAqICAgICAgICAnRGF2ZSBCcnViZWNrJyxcbiAqICAgICAgICAnUGF1bCBEZXNtb25kJyxcbiAqICAgICAgICAnRXVnZW5lIFdyaWdodCcsXG4gKiAgICAgICAgJ0pvZSBNb3JlbGxvJyxcbiAqICAgICAgICAnR2VycnkgTXVsbGlnYW4nLFxuICogICAgICAgICdCb2IgQmF0ZXMnLFxuICogICAgICAgICdKb2UgRG9kZ2UnLFxuICogICAgICAgICdSb24gQ3JvdHR5J1xuICogICAgICBdO1xuICpcbiAqICAgICAgY29uc3QgdGFrZUZpdmUgPSBSLnRha2UoNSk7XG4gKiAgICAgIHRha2VGaXZlKHBlcnNvbm5lbCk7XG4gKiAgICAgIC8vPT4gWydEYXZlIEJydWJlY2snLCAnUGF1bCBEZXNtb25kJywgJ0V1Z2VuZSBXcmlnaHQnLCAnSm9lIE1vcmVsbG8nLCAnR2VycnkgTXVsbGlnYW4nXVxuICogQHN5bWIgUi50YWtlKC0xLCBbYSwgYl0pID0gW2EsIGJdXG4gKiBAc3ltYiBSLnRha2UoMCwgW2EsIGJdKSA9IFtdXG4gKiBAc3ltYiBSLnRha2UoMSwgW2EsIGJdKSA9IFthXVxuICogQHN5bWIgUi50YWtlKDIsIFthLCBiXSkgPSBbYSwgYl1cbiAqL1xuXG52YXIgdGFrZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKFxuLyojX19QVVJFX18qL1xuX2Rpc3BhdGNoYWJsZShbJ3Rha2UnXSwgX3h0YWtlLCBmdW5jdGlvbiB0YWtlKG4sIHhzKSB7XG4gIHJldHVybiBzbGljZSgwLCBuIDwgMCA/IEluZmluaXR5IDogbiwgeHMpO1xufSkpO1xuXG5leHBvcnQgZGVmYXVsdCB0YWtlOyIsImltcG9ydCB0YWtlIGZyb20gXCIuLi90YWtlLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkcm9wTGFzdChuLCB4cykge1xuICByZXR1cm4gdGFrZShuIDwgeHMubGVuZ3RoID8geHMubGVuZ3RoIC0gbiA6IDAsIHhzKTtcbn0iLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9fY3VycnkyLmpzXCI7XG5pbXBvcnQgX3hmQmFzZSBmcm9tIFwiLi9feGZCYXNlLmpzXCI7XG5cbnZhciBYRHJvcExhc3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYRHJvcExhc3QobiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMuZnVsbCA9IGZhbHNlO1xuICAgIHRoaXMuYWNjID0gbmV3IEFycmF5KG4pO1xuICB9XG5cbiAgWERyb3BMYXN0LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcblxuICBYRHJvcExhc3QucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgdGhpcy5hY2MgPSBudWxsO1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgfTtcblxuICBYRHJvcExhc3QucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICBpZiAodGhpcy5mdWxsKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdGhpcy5hY2NbdGhpcy5wb3NdKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0b3JlKGlucHV0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIFhEcm9wTGFzdC5wcm90b3R5cGUuc3RvcmUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB0aGlzLmFjY1t0aGlzLnBvc10gPSBpbnB1dDtcbiAgICB0aGlzLnBvcyArPSAxO1xuXG4gICAgaWYgKHRoaXMucG9zID09PSB0aGlzLmFjYy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgIHRoaXMuZnVsbCA9IHRydWU7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBYRHJvcExhc3Q7XG59KCk7XG5cbnZhciBfeGRyb3BMYXN0ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gX3hkcm9wTGFzdChuLCB4Zikge1xuICByZXR1cm4gbmV3IFhEcm9wTGFzdChuLCB4Zik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgX3hkcm9wTGFzdDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgX2Rpc3BhdGNoYWJsZSBmcm9tIFwiLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlLmpzXCI7XG5pbXBvcnQgX2Ryb3BMYXN0IGZyb20gXCIuL2ludGVybmFsL19kcm9wTGFzdC5qc1wiO1xuaW1wb3J0IF94ZHJvcExhc3QgZnJvbSBcIi4vaW50ZXJuYWwvX3hkcm9wTGFzdC5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBjb250YWluaW5nIGFsbCBidXQgdGhlIGxhc3QgYG5gIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBgbGlzdGAuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE2LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW2FdXG4gKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIGBsaXN0YCB0byBza2lwLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCBvZiBlbGVtZW50cyB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fSBBIGNvcHkgb2YgdGhlIGxpc3Qgd2l0aCBvbmx5IHRoZSBmaXJzdCBgbGlzdC5sZW5ndGggLSBuYCBlbGVtZW50c1xuICogQHNlZSBSLnRha2VMYXN0LCBSLmRyb3AsIFIuZHJvcFdoaWxlLCBSLmRyb3BMYXN0V2hpbGVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmRyb3BMYXN0KDEsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydmb28nLCAnYmFyJ11cbiAqICAgICAgUi5kcm9wTGFzdCgyLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFsnZm9vJ11cbiAqICAgICAgUi5kcm9wTGFzdCgzLCBbJ2ZvbycsICdiYXInLCAnYmF6J10pOyAvLz0+IFtdXG4gKiAgICAgIFIuZHJvcExhc3QoNCwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbXVxuICogICAgICBSLmRyb3BMYXN0KDMsICdyYW1kYScpOyAgICAgICAgICAgICAgIC8vPT4gJ3JhJ1xuICovXG5cbnZhciBkcm9wTGFzdCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKFxuLyojX19QVVJFX18qL1xuX2Rpc3BhdGNoYWJsZShbXSwgX3hkcm9wTGFzdCwgX2Ryb3BMYXN0KSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRyb3BMYXN0OyIsImltcG9ydCBzbGljZSBmcm9tIFwiLi4vc2xpY2UuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRyb3BMYXN0V2hpbGUocHJlZCwgeHMpIHtcbiAgdmFyIGlkeCA9IHhzLmxlbmd0aCAtIDE7XG5cbiAgd2hpbGUgKGlkeCA+PSAwICYmIHByZWQoeHNbaWR4XSkpIHtcbiAgICBpZHggLT0gMTtcbiAgfVxuXG4gIHJldHVybiBzbGljZSgwLCBpZHggKyAxLCB4cyk7XG59IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9yZWR1Y2UgZnJvbSBcIi4vX3JlZHVjZS5qc1wiO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSBcIi4vX3hmQmFzZS5qc1wiO1xuXG52YXIgWERyb3BMYXN0V2hpbGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYRHJvcExhc3RXaGlsZShmbiwgeGYpIHtcbiAgICB0aGlzLmYgPSBmbjtcbiAgICB0aGlzLnJldGFpbmVkID0gW107XG4gICAgdGhpcy54ZiA9IHhmO1xuICB9XG5cbiAgWERyb3BMYXN0V2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuXG4gIFhEcm9wTGFzdFdoaWxlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHRoaXMucmV0YWluZWQgPSBudWxsO1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgfTtcblxuICBYRHJvcExhc3RXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIHJldHVybiB0aGlzLmYoaW5wdXQpID8gdGhpcy5yZXRhaW4ocmVzdWx0LCBpbnB1dCkgOiB0aGlzLmZsdXNoKHJlc3VsdCwgaW5wdXQpO1xuICB9O1xuXG4gIFhEcm9wTGFzdFdoaWxlLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgcmVzdWx0ID0gX3JlZHVjZSh0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddLCByZXN1bHQsIHRoaXMucmV0YWluZWQpO1xuICAgIHRoaXMucmV0YWluZWQgPSBbXTtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgfTtcblxuICBYRHJvcExhc3RXaGlsZS5wcm90b3R5cGUucmV0YWluID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICB0aGlzLnJldGFpbmVkLnB1c2goaW5wdXQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIFhEcm9wTGFzdFdoaWxlO1xufSgpO1xuXG52YXIgX3hkcm9wTGFzdFdoaWxlID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gX3hkcm9wTGFzdFdoaWxlKGZuLCB4Zikge1xuICByZXR1cm4gbmV3IFhEcm9wTGFzdFdoaWxlKGZuLCB4Zik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgX3hkcm9wTGFzdFdoaWxlOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gXCIuL2ludGVybmFsL19kaXNwYXRjaGFibGUuanNcIjtcbmltcG9ydCBfZHJvcExhc3RXaGlsZSBmcm9tIFwiLi9pbnRlcm5hbC9fZHJvcExhc3RXaGlsZS5qc1wiO1xuaW1wb3J0IF94ZHJvcExhc3RXaGlsZSBmcm9tIFwiLi9pbnRlcm5hbC9feGRyb3BMYXN0V2hpbGUuanNcIjtcbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IGV4Y2x1ZGluZyBhbGwgdGhlIHRhaWxpbmcgZWxlbWVudHMgb2YgYSBnaXZlbiBsaXN0IHdoaWNoXG4gKiBzYXRpc2Z5IHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgZnVuY3Rpb24uIEl0IHBhc3NlcyBlYWNoIHZhbHVlIGZyb20gdGhlIHJpZ2h0XG4gKiB0byB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIGZ1bmN0aW9uLCBza2lwcGluZyBlbGVtZW50cyB1bnRpbCB0aGUgcHJlZGljYXRlXG4gKiBmdW5jdGlvbiByZXR1cm5zIGEgYGZhbHN5YCB2YWx1ZS4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIG9uZSBhcmd1bWVudDpcbiAqICoodmFsdWUpKi5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXVxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbiBlYWNoIGVsZW1lbnRcbiAqIEBwYXJhbSB7QXJyYXl9IHhzIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBhcnJheSB3aXRob3V0IGFueSB0cmFpbGluZyBlbGVtZW50cyB0aGF0IHJldHVybiBgZmFsc3lgIHZhbHVlcyBmcm9tIHRoZSBgcHJlZGljYXRlYC5cbiAqIEBzZWUgUi50YWtlTGFzdFdoaWxlLCBSLmFkZEluZGV4LCBSLmRyb3AsIFIuZHJvcFdoaWxlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgbHRlVGhyZWUgPSB4ID0+IHggPD0gMztcbiAqXG4gKiAgICAgIFIuZHJvcExhc3RXaGlsZShsdGVUaHJlZSwgWzEsIDIsIDMsIDQsIDMsIDIsIDFdKTsgLy89PiBbMSwgMiwgMywgNF1cbiAqXG4gKiAgICAgIFIuZHJvcExhc3RXaGlsZSh4ID0+IHggIT09ICdkJyAsICdSYW1kYScpOyAvLz0+ICdSYW1kJ1xuICovXG5cbnZhciBkcm9wTGFzdFdoaWxlID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoXG4vKiNfX1BVUkVfXyovXG5fZGlzcGF0Y2hhYmxlKFtdLCBfeGRyb3BMYXN0V2hpbGUsIF9kcm9wTGFzdFdoaWxlKSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRyb3BMYXN0V2hpbGU7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSBcIi4vX3hmQmFzZS5qc1wiO1xuXG52YXIgWERyb3BSZXBlYXRzV2l0aCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhEcm9wUmVwZWF0c1dpdGgocHJlZCwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5wcmVkID0gcHJlZDtcbiAgICB0aGlzLmxhc3RWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNlZW5GaXJzdFZhbHVlID0gZmFsc2U7XG4gIH1cblxuICBYRHJvcFJlcGVhdHNXaXRoLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWERyb3BSZXBlYXRzV2l0aC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuXG4gIFhEcm9wUmVwZWF0c1dpdGgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICB2YXIgc2FtZUFzTGFzdCA9IGZhbHNlO1xuXG4gICAgaWYgKCF0aGlzLnNlZW5GaXJzdFZhbHVlKSB7XG4gICAgICB0aGlzLnNlZW5GaXJzdFZhbHVlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJlZCh0aGlzLmxhc3RWYWx1ZSwgaW5wdXQpKSB7XG4gICAgICBzYW1lQXNMYXN0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RWYWx1ZSA9IGlucHV0O1xuICAgIHJldHVybiBzYW1lQXNMYXN0ID8gcmVzdWx0IDogdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgfTtcblxuICByZXR1cm4gWERyb3BSZXBlYXRzV2l0aDtcbn0oKTtcblxudmFyIF94ZHJvcFJlcGVhdHNXaXRoID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gX3hkcm9wUmVwZWF0c1dpdGgocHJlZCwgeGYpIHtcbiAgcmV0dXJuIG5ldyBYRHJvcFJlcGVhdHNXaXRoKHByZWQsIHhmKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBfeGRyb3BSZXBlYXRzV2l0aDsiLCJpbXBvcnQgbnRoIGZyb20gXCIuL250aC5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuNFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IGEgfCBVbmRlZmluZWRcbiAqIEBzaWcgU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHsqfSBsaXN0XG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLmluaXQsIFIuaGVhZCwgUi50YWlsXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5sYXN0KFsnZmknLCAnZm8nLCAnZnVtJ10pOyAvLz0+ICdmdW0nXG4gKiAgICAgIFIubGFzdChbXSk7IC8vPT4gdW5kZWZpbmVkXG4gKlxuICogICAgICBSLmxhc3QoJ2FiYycpOyAvLz0+ICdjJ1xuICogICAgICBSLmxhc3QoJycpOyAvLz0+ICcnXG4gKi9cblxudmFyIGxhc3QgPVxuLyojX19QVVJFX18qL1xubnRoKC0xKTtcbmV4cG9ydCBkZWZhdWx0IGxhc3Q7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSBcIi4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZS5qc1wiO1xuaW1wb3J0IF94ZHJvcFJlcGVhdHNXaXRoIGZyb20gXCIuL2ludGVybmFsL194ZHJvcFJlcGVhdHNXaXRoLmpzXCI7XG5pbXBvcnQgbGFzdCBmcm9tIFwiLi9sYXN0LmpzXCI7XG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCB3aXRob3V0IGFueSBjb25zZWN1dGl2ZWx5IHJlcGVhdGluZyBlbGVtZW50cy4gRXF1YWxpdHkgaXNcbiAqIGRldGVybWluZWQgYnkgYXBwbHlpbmcgdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSB0byBlYWNoIHBhaXIgb2YgY29uc2VjdXRpdmUgZWxlbWVudHMuIFRoZVxuICogZmlyc3QgZWxlbWVudCBpbiBhIHNlcmllcyBvZiBlcXVhbCBlbGVtZW50cyB3aWxsIGJlIHByZXNlcnZlZC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTQuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKChhLCBhKSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHVzZWQgdG8gdGVzdCB3aGV0aGVyIHR3byBpdGVtcyBhcmUgZXF1YWwuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fSBgbGlzdGAgd2l0aG91dCByZXBlYXRpbmcgZWxlbWVudHMuXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgbCA9IFsxLCAtMSwgMSwgMywgNCwgLTQsIC00LCAtNSwgNSwgMywgM107XG4gKiAgICAgIFIuZHJvcFJlcGVhdHNXaXRoKFIuZXFCeShNYXRoLmFicyksIGwpOyAvLz0+IFsxLCAzLCA0LCAtNSwgM11cbiAqL1xuXG52YXIgZHJvcFJlcGVhdHNXaXRoID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoXG4vKiNfX1BVUkVfXyovXG5fZGlzcGF0Y2hhYmxlKFtdLCBfeGRyb3BSZXBlYXRzV2l0aCwgZnVuY3Rpb24gZHJvcFJlcGVhdHNXaXRoKHByZWQsIGxpc3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaWR4ID0gMTtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuXG4gIGlmIChsZW4gIT09IDApIHtcbiAgICByZXN1bHRbMF0gPSBsaXN0WzBdO1xuXG4gICAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgICAgaWYgKCFwcmVkKGxhc3QocmVzdWx0KSwgbGlzdFtpZHhdKSkge1xuICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBsaXN0W2lkeF07XG4gICAgICB9XG5cbiAgICAgIGlkeCArPSAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59KSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRyb3BSZXBlYXRzV2l0aDsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkxLmpzXCI7XG5pbXBvcnQgX2Rpc3BhdGNoYWJsZSBmcm9tIFwiLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlLmpzXCI7XG5pbXBvcnQgX3hkcm9wUmVwZWF0c1dpdGggZnJvbSBcIi4vaW50ZXJuYWwvX3hkcm9wUmVwZWF0c1dpdGguanNcIjtcbmltcG9ydCBkcm9wUmVwZWF0c1dpdGggZnJvbSBcIi4vZHJvcFJlcGVhdHNXaXRoLmpzXCI7XG5pbXBvcnQgZXF1YWxzIGZyb20gXCIuL2VxdWFscy5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3Qgd2l0aG91dCBhbnkgY29uc2VjdXRpdmVseSByZXBlYXRpbmcgZWxlbWVudHMuXG4gKiBbYFIuZXF1YWxzYF0oI2VxdWFscykgaXMgdXNlZCB0byBkZXRlcm1pbmUgZXF1YWxpdHkuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7QXJyYXl9IGBsaXN0YCB3aXRob3V0IHJlcGVhdGluZyBlbGVtZW50cy5cbiAqIEBzZWUgUi50cmFuc2R1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIFIuZHJvcFJlcGVhdHMoWzEsIDEsIDEsIDIsIDMsIDQsIDQsIDIsIDJdKTsgLy89PiBbMSwgMiwgMywgNCwgMl1cbiAqL1xuXG52YXIgZHJvcFJlcGVhdHMgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShcbi8qI19fUFVSRV9fKi9cbl9kaXNwYXRjaGFibGUoW10sXG4vKiNfX1BVUkVfXyovXG5feGRyb3BSZXBlYXRzV2l0aChlcXVhbHMpLFxuLyojX19QVVJFX18qL1xuZHJvcFJlcGVhdHNXaXRoKGVxdWFscykpKTtcblxuZXhwb3J0IGRlZmF1bHQgZHJvcFJlcGVhdHM7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSBcIi4vX3hmQmFzZS5qc1wiO1xuXG52YXIgWERyb3BXaGlsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhEcm9wV2hpbGUoZiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5mID0gZjtcbiAgfVxuXG4gIFhEcm9wV2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuICBYRHJvcFdoaWxlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gX3hmQmFzZS5yZXN1bHQ7XG5cbiAgWERyb3BXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIGlmICh0aGlzLmYpIHtcbiAgICAgIGlmICh0aGlzLmYoaW5wdXQpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZiA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCk7XG4gIH07XG5cbiAgcmV0dXJuIFhEcm9wV2hpbGU7XG59KCk7XG5cbnZhciBfeGRyb3BXaGlsZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIF94ZHJvcFdoaWxlKGYsIHhmKSB7XG4gIHJldHVybiBuZXcgWERyb3BXaGlsZShmLCB4Zik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgX3hkcm9wV2hpbGU7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSBcIi4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZS5qc1wiO1xuaW1wb3J0IF94ZHJvcFdoaWxlIGZyb20gXCIuL2ludGVybmFsL194ZHJvcFdoaWxlLmpzXCI7XG5pbXBvcnQgc2xpY2UgZnJvbSBcIi4vc2xpY2UuanNcIjtcbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IGV4Y2x1ZGluZyB0aGUgbGVhZGluZyBlbGVtZW50cyBvZiBhIGdpdmVuIGxpc3Qgd2hpY2hcbiAqIHNhdGlzZnkgdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSBmdW5jdGlvbi4gSXQgcGFzc2VzIGVhY2ggdmFsdWUgdG8gdGhlIHN1cHBsaWVkXG4gKiBwcmVkaWNhdGUgZnVuY3Rpb24sIHNraXBwaW5nIGVsZW1lbnRzIHdoaWxlIHRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gcmV0dXJuc1xuICogYHRydWVgLiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uIGlzIGFwcGxpZWQgdG8gb25lIGFyZ3VtZW50OiAqKHZhbHVlKSouXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGRyb3BXaGlsZWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IFthXVxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgYXJyYXkuXG4gKiBAc2VlIFIudGFrZVdoaWxlLCBSLnRyYW5zZHVjZSwgUi5hZGRJbmRleFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGx0ZVR3byA9IHggPT4geCA8PSAyO1xuICpcbiAqICAgICAgUi5kcm9wV2hpbGUobHRlVHdvLCBbMSwgMiwgMywgNCwgMywgMiwgMV0pOyAvLz0+IFszLCA0LCAzLCAyLCAxXVxuICpcbiAqICAgICAgUi5kcm9wV2hpbGUoeCA9PiB4ICE9PSAnZCcgLCAnUmFtZGEnKTsgLy89PiAnZGEnXG4gKi9cblxudmFyIGRyb3BXaGlsZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKFxuLyojX19QVVJFX18qL1xuX2Rpc3BhdGNoYWJsZShbJ2Ryb3BXaGlsZSddLCBfeGRyb3BXaGlsZSwgZnVuY3Rpb24gZHJvcFdoaWxlKHByZWQsIHhzKSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0geHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpZHggPCBsZW4gJiYgcHJlZCh4c1tpZHhdKSkge1xuICAgIGlkeCArPSAxO1xuICB9XG5cbiAgcmV0dXJuIHNsaWNlKGlkeCwgSW5maW5pdHksIHhzKTtcbn0pKTtcblxuZXhwb3J0IGRlZmF1bHQgZHJvcFdoaWxlOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgb25lIG9yIGJvdGggb2YgaXRzIGFyZ3VtZW50cyBhcmUgYHRydWVgLiBSZXR1cm5zIGBmYWxzZWBcbiAqIGlmIGJvdGggYXJndW1lbnRzIGFyZSBgZmFsc2VgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIGEgLT4gYiAtPiBhIHwgYlxuICogQHBhcmFtIHtBbnl9IGFcbiAqIEBwYXJhbSB7QW55fSBiXG4gKiBAcmV0dXJuIHtBbnl9IHRoZSBmaXJzdCBhcmd1bWVudCBpZiB0cnV0aHksIG90aGVyd2lzZSB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICogQHNlZSBSLmVpdGhlciwgUi54b3JcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm9yKHRydWUsIHRydWUpOyAvLz0+IHRydWVcbiAqICAgICAgUi5vcih0cnVlLCBmYWxzZSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLm9yKGZhbHNlLCB0cnVlKTsgLy89PiB0cnVlXG4gKiAgICAgIFIub3IoZmFsc2UsIGZhbHNlKTsgLy89PiBmYWxzZVxuICovXG5cbnZhciBvciA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIG9yKGEsIGIpIHtcbiAgcmV0dXJuIGEgfHwgYjtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBvcjsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgX2lzRnVuY3Rpb24gZnJvbSBcIi4vaW50ZXJuYWwvX2lzRnVuY3Rpb24uanNcIjtcbmltcG9ydCBsaWZ0IGZyb20gXCIuL2xpZnQuanNcIjtcbmltcG9ydCBvciBmcm9tIFwiLi9vci5qc1wiO1xuLyoqXG4gKiBBIGZ1bmN0aW9uIHdyYXBwaW5nIGNhbGxzIHRvIHRoZSB0d28gZnVuY3Rpb25zIGluIGFuIGB8fGAgb3BlcmF0aW9uLFxuICogcmV0dXJuaW5nIHRoZSByZXN1bHQgb2YgdGhlIGZpcnN0IGZ1bmN0aW9uIGlmIGl0IGlzIHRydXRoLXkgYW5kIHRoZSByZXN1bHRcbiAqIG9mIHRoZSBzZWNvbmQgZnVuY3Rpb24gb3RoZXJ3aXNlLiBOb3RlIHRoYXQgdGhpcyBpcyBzaG9ydC1jaXJjdWl0ZWQsXG4gKiBtZWFuaW5nIHRoYXQgdGhlIHNlY29uZCBmdW5jdGlvbiB3aWxsIG5vdCBiZSBpbnZva2VkIGlmIHRoZSBmaXJzdCByZXR1cm5zIGFcbiAqIHRydXRoLXkgdmFsdWUuXG4gKlxuICogSW4gYWRkaXRpb24gdG8gZnVuY3Rpb25zLCBgUi5laXRoZXJgIGFsc28gYWNjZXB0cyBhbnkgZmFudGFzeS1sYW5kIGNvbXBhdGlibGVcbiAqIGFwcGxpY2F0aXZlIGZ1bmN0b3IuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTIuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnICgqLi4uIC0+IEJvb2xlYW4pIC0+ICgqLi4uIC0+IEJvb2xlYW4pIC0+ICgqLi4uIC0+IEJvb2xlYW4pXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIGEgcHJlZGljYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnIGFub3RoZXIgcHJlZGljYXRlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IGFwcGxpZXMgaXRzIGFyZ3VtZW50cyB0byBgZmAgYW5kIGBnYCBhbmQgYHx8YHMgdGhlaXIgb3V0cHV0cyB0b2dldGhlci5cbiAqIEBzZWUgUi5vclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGd0MTAgPSB4ID0+IHggPiAxMDtcbiAqICAgICAgY29uc3QgZXZlbiA9IHggPT4geCAlIDIgPT09IDA7XG4gKiAgICAgIGNvbnN0IGYgPSBSLmVpdGhlcihndDEwLCBldmVuKTtcbiAqICAgICAgZigxMDEpOyAvLz0+IHRydWVcbiAqICAgICAgZig4KTsgLy89PiB0cnVlXG4gKlxuICogICAgICBSLmVpdGhlcihNYXliZS5KdXN0KGZhbHNlKSwgTWF5YmUuSnVzdCg1NSkpOyAvLyA9PiBNYXliZS5KdXN0KDU1KVxuICogICAgICBSLmVpdGhlcihbZmFsc2UsIGZhbHNlLCAnYSddLCBbMTFdKSAvLyA9PiBbMTEsIDExLCBcImFcIl1cbiAqL1xuXG52YXIgZWl0aGVyID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gZWl0aGVyKGYsIGcpIHtcbiAgcmV0dXJuIF9pc0Z1bmN0aW9uKGYpID8gZnVuY3Rpb24gX2VpdGhlcigpIHtcbiAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IGcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSA6IGxpZnQob3IpKGYsIGcpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGVpdGhlcjsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkxLmpzXCI7XG5pbXBvcnQgX2lzQXJndW1lbnRzIGZyb20gXCIuL2ludGVybmFsL19pc0FyZ3VtZW50cy5qc1wiO1xuaW1wb3J0IF9pc0FycmF5IGZyb20gXCIuL2ludGVybmFsL19pc0FycmF5LmpzXCI7XG5pbXBvcnQgX2lzT2JqZWN0IGZyb20gXCIuL2ludGVybmFsL19pc09iamVjdC5qc1wiO1xuaW1wb3J0IF9pc1N0cmluZyBmcm9tIFwiLi9pbnRlcm5hbC9faXNTdHJpbmcuanNcIjtcbi8qKlxuICogUmV0dXJucyB0aGUgZW1wdHkgdmFsdWUgb2YgaXRzIGFyZ3VtZW50J3MgdHlwZS4gUmFtZGEgZGVmaW5lcyB0aGUgZW1wdHlcbiAqIHZhbHVlIG9mIEFycmF5IChgW11gKSwgT2JqZWN0IChge31gKSwgU3RyaW5nIChgJydgKSwgYW5kIEFyZ3VtZW50cy4gT3RoZXJcbiAqIHR5cGVzIGFyZSBzdXBwb3J0ZWQgaWYgdGhleSBkZWZpbmUgYDxUeXBlPi5lbXB0eWAsXG4gKiBgPFR5cGU+LnByb3RvdHlwZS5lbXB0eWAgb3IgaW1wbGVtZW50IHRoZVxuICogW0ZhbnRhc3lMYW5kIE1vbm9pZCBzcGVjXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI21vbm9pZCkuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGVtcHR5YCBtZXRob2Qgb2YgdGhlIGZpcnN0IGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjMuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIGEgLT4gYVxuICogQHBhcmFtIHsqfSB4XG4gKiBAcmV0dXJuIHsqfVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZW1wdHkoSnVzdCg0MikpOyAgICAgIC8vPT4gTm90aGluZygpXG4gKiAgICAgIFIuZW1wdHkoWzEsIDIsIDNdKTsgICAgIC8vPT4gW11cbiAqICAgICAgUi5lbXB0eSgndW5pY29ybnMnKTsgICAgLy89PiAnJ1xuICogICAgICBSLmVtcHR5KHt4OiAxLCB5OiAyfSk7ICAvLz0+IHt9XG4gKi9cblxudmFyIGVtcHR5ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoZnVuY3Rpb24gZW1wdHkoeCkge1xuICByZXR1cm4geCAhPSBudWxsICYmIHR5cGVvZiB4WydmYW50YXN5LWxhbmQvZW1wdHknXSA9PT0gJ2Z1bmN0aW9uJyA/IHhbJ2ZhbnRhc3ktbGFuZC9lbXB0eSddKCkgOiB4ICE9IG51bGwgJiYgeC5jb25zdHJ1Y3RvciAhPSBudWxsICYmIHR5cGVvZiB4LmNvbnN0cnVjdG9yWydmYW50YXN5LWxhbmQvZW1wdHknXSA9PT0gJ2Z1bmN0aW9uJyA/IHguY29uc3RydWN0b3JbJ2ZhbnRhc3ktbGFuZC9lbXB0eSddKCkgOiB4ICE9IG51bGwgJiYgdHlwZW9mIHguZW1wdHkgPT09ICdmdW5jdGlvbicgPyB4LmVtcHR5KCkgOiB4ICE9IG51bGwgJiYgeC5jb25zdHJ1Y3RvciAhPSBudWxsICYmIHR5cGVvZiB4LmNvbnN0cnVjdG9yLmVtcHR5ID09PSAnZnVuY3Rpb24nID8geC5jb25zdHJ1Y3Rvci5lbXB0eSgpIDogX2lzQXJyYXkoeCkgPyBbXSA6IF9pc1N0cmluZyh4KSA/ICcnIDogX2lzT2JqZWN0KHgpID8ge30gOiBfaXNBcmd1bWVudHMoeCkgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cztcbiAgfSgpIDogdm9pZCAwIC8vIGVsc2VcbiAgO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGVtcHR5OyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbmltcG9ydCBkcm9wIGZyb20gXCIuL2Ryb3AuanNcIjtcbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIGxhc3QgYG5gIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBsaXN0LlxuICogSWYgYG4gPiBsaXN0Lmxlbmd0aGAsIHJldHVybnMgYSBsaXN0IG9mIGBsaXN0Lmxlbmd0aGAgZWxlbWVudHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbYV1cbiAqIEBzaWcgTnVtYmVyIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmV0dXJuLlxuICogQHBhcmFtIHtBcnJheX0geHMgVGhlIGNvbGxlY3Rpb24gdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBzZWUgUi5kcm9wTGFzdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudGFrZUxhc3QoMSwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2JheiddXG4gKiAgICAgIFIudGFrZUxhc3QoMiwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2JhcicsICdiYXonXVxuICogICAgICBSLnRha2VMYXN0KDMsIFsnZm9vJywgJ2JhcicsICdiYXonXSk7IC8vPT4gWydmb28nLCAnYmFyJywgJ2JheiddXG4gKiAgICAgIFIudGFrZUxhc3QoNCwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAqICAgICAgUi50YWtlTGFzdCgzLCAncmFtZGEnKTsgICAgICAgICAgICAgICAvLz0+ICdtZGEnXG4gKi9cblxudmFyIHRha2VMYXN0ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gdGFrZUxhc3QobiwgeHMpIHtcbiAgcmV0dXJuIGRyb3AobiA+PSAwID8geHMubGVuZ3RoIC0gbiA6IDAsIHhzKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB0YWtlTGFzdDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgZXF1YWxzIGZyb20gXCIuL2VxdWFscy5qc1wiO1xuaW1wb3J0IHRha2VMYXN0IGZyb20gXCIuL3Rha2VMYXN0LmpzXCI7XG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgZW5kcyB3aXRoIHRoZSBwcm92aWRlZCBzdWJsaXN0LlxuICpcbiAqIFNpbWlsYXJseSwgY2hlY2tzIGlmIGEgc3RyaW5nIGVuZHMgd2l0aCB0aGUgcHJvdmlkZWQgc3Vic3RyaW5nLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjI0LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBbYV0gLT4gQm9vbGVhblxuICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0gc3VmZml4XG4gKiBAcGFyYW0geyp9IGxpc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIuc3RhcnRzV2l0aFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZW5kc1dpdGgoJ2MnLCAnYWJjJykgICAgICAgICAgICAgICAgLy89PiB0cnVlXG4gKiAgICAgIFIuZW5kc1dpdGgoJ2InLCAnYWJjJykgICAgICAgICAgICAgICAgLy89PiBmYWxzZVxuICogICAgICBSLmVuZHNXaXRoKFsnYyddLCBbJ2EnLCAnYicsICdjJ10pICAgIC8vPT4gdHJ1ZVxuICogICAgICBSLmVuZHNXaXRoKFsnYiddLCBbJ2EnLCAnYicsICdjJ10pICAgIC8vPT4gZmFsc2VcbiAqL1xuXG52YXIgZW5kc1dpdGggPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiAoc3VmZml4LCBsaXN0KSB7XG4gIHJldHVybiBlcXVhbHModGFrZUxhc3Qoc3VmZml4Lmxlbmd0aCwgbGlzdCksIHN1ZmZpeCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZW5kc1dpdGg7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5My5qc1wiO1xuaW1wb3J0IGVxdWFscyBmcm9tIFwiLi9lcXVhbHMuanNcIjtcbi8qKlxuICogVGFrZXMgYSBmdW5jdGlvbiBhbmQgdHdvIHZhbHVlcyBpbiBpdHMgZG9tYWluIGFuZCByZXR1cm5zIGB0cnVlYCBpZiB0aGVcbiAqIHZhbHVlcyBtYXAgdG8gdGhlIHNhbWUgdmFsdWUgaW4gdGhlIGNvZG9tYWluOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOC4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgKGEgLT4gYikgLT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAqIEBwYXJhbSB7Kn0geFxuICogQHBhcmFtIHsqfSB5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZXFCeShNYXRoLmFicywgNSwgLTUpOyAvLz0+IHRydWVcbiAqL1xuXG52YXIgZXFCeSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKGZ1bmN0aW9uIGVxQnkoZiwgeCwgeSkge1xuICByZXR1cm4gZXF1YWxzKGYoeCksIGYoeSkpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGVxQnk7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5My5qc1wiO1xuaW1wb3J0IGVxdWFscyBmcm9tIFwiLi9lcXVhbHMuanNcIjtcbi8qKlxuICogUmVwb3J0cyB3aGV0aGVyIHR3byBvYmplY3RzIGhhdmUgdGhlIHNhbWUgdmFsdWUsIGluIFtgUi5lcXVhbHNgXSgjZXF1YWxzKVxuICogdGVybXMsIGZvciB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LiBVc2VmdWwgYXMgYSBjdXJyaWVkIHByZWRpY2F0ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgayAtPiB7azogdn0gLT4ge2s6IHZ9IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjb21wYXJlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMVxuICogQHBhcmFtIHtPYmplY3R9IG9iajJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IG8xID0geyBhOiAxLCBiOiAyLCBjOiAzLCBkOiA0IH07XG4gKiAgICAgIGNvbnN0IG8yID0geyBhOiAxMCwgYjogMjAsIGM6IDMsIGQ6IDQwIH07XG4gKiAgICAgIFIuZXFQcm9wcygnYScsIG8xLCBvMik7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5lcVByb3BzKCdjJywgbzEsIG8yKTsgLy89PiB0cnVlXG4gKi9cblxudmFyIGVxUHJvcHMgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MyhmdW5jdGlvbiBlcVByb3BzKHByb3AsIG9iajEsIG9iajIpIHtcbiAgcmV0dXJuIGVxdWFscyhvYmoxW3Byb3BdLCBvYmoyW3Byb3BdKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBlcVByb3BzOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgYnkgcmVjdXJzaXZlbHkgZXZvbHZpbmcgYSBzaGFsbG93IGNvcHkgb2YgYG9iamVjdGAsXG4gKiBhY2NvcmRpbmcgdG8gdGhlIGB0cmFuc2Zvcm1hdGlvbmAgZnVuY3Rpb25zLiBBbGwgbm9uLXByaW1pdGl2ZSBwcm9wZXJ0aWVzXG4gKiBhcmUgY29waWVkIGJ5IHJlZmVyZW5jZS5cbiAqXG4gKiBBIGB0cmFuc2Zvcm1hdGlvbmAgZnVuY3Rpb24gd2lsbCBub3QgYmUgaW52b2tlZCBpZiBpdHMgY29ycmVzcG9uZGluZyBrZXlcbiAqIGRvZXMgbm90IGV4aXN0IGluIHRoZSBldm9sdmVkIG9iamVjdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcge2s6ICh2IC0+IHYpfSAtPiB7azogdn0gLT4ge2s6IHZ9XG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNmb3JtYXRpb25zIFRoZSBvYmplY3Qgc3BlY2lmeWluZyB0cmFuc2Zvcm1hdGlvbiBmdW5jdGlvbnMgdG8gYXBwbHlcbiAqICAgICAgICB0byB0aGUgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJlIHRyYW5zZm9ybWVkLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgdHJhbnNmb3JtZWQgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IHRvbWF0byA9IHtmaXJzdE5hbWU6ICcgIFRvbWF0byAnLCBkYXRhOiB7ZWxhcHNlZDogMTAwLCByZW1haW5pbmc6IDE0MDB9LCBpZDoxMjN9O1xuICogICAgICBjb25zdCB0cmFuc2Zvcm1hdGlvbnMgPSB7XG4gKiAgICAgICAgZmlyc3ROYW1lOiBSLnRyaW0sXG4gKiAgICAgICAgbGFzdE5hbWU6IFIudHJpbSwgLy8gV2lsbCBub3QgZ2V0IGludm9rZWQuXG4gKiAgICAgICAgZGF0YToge2VsYXBzZWQ6IFIuYWRkKDEpLCByZW1haW5pbmc6IFIuYWRkKC0xKX1cbiAqICAgICAgfTtcbiAqICAgICAgUi5ldm9sdmUodHJhbnNmb3JtYXRpb25zLCB0b21hdG8pOyAvLz0+IHtmaXJzdE5hbWU6ICdUb21hdG8nLCBkYXRhOiB7ZWxhcHNlZDogMTAxLCByZW1haW5pbmc6IDEzOTl9LCBpZDoxMjN9XG4gKi9cblxudmFyIGV2b2x2ZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIGV2b2x2ZSh0cmFuc2Zvcm1hdGlvbnMsIG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0IGluc3RhbmNlb2YgQXJyYXkgPyBbXSA6IHt9O1xuICB2YXIgdHJhbnNmb3JtYXRpb24sIGtleSwgdHlwZTtcblxuICBmb3IgKGtleSBpbiBvYmplY3QpIHtcbiAgICB0cmFuc2Zvcm1hdGlvbiA9IHRyYW5zZm9ybWF0aW9uc1trZXldO1xuICAgIHR5cGUgPSB0eXBlb2YgdHJhbnNmb3JtYXRpb247XG4gICAgcmVzdWx0W2tleV0gPSB0eXBlID09PSAnZnVuY3Rpb24nID8gdHJhbnNmb3JtYXRpb24ob2JqZWN0W2tleV0pIDogdHJhbnNmb3JtYXRpb24gJiYgdHlwZSA9PT0gJ29iamVjdCcgPyBldm9sdmUodHJhbnNmb3JtYXRpb24sIG9iamVjdFtrZXldKSA6IG9iamVjdFtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBldm9sdmU7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9yZWR1Y2VkIGZyb20gXCIuL19yZWR1Y2VkLmpzXCI7XG5pbXBvcnQgX3hmQmFzZSBmcm9tIFwiLi9feGZCYXNlLmpzXCI7XG5cbnZhciBYRmluZCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhGaW5kKGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gICAgdGhpcy5mb3VuZCA9IGZhbHNlO1xuICB9XG5cbiAgWEZpbmQucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuXG4gIFhGaW5kLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIGlmICghdGhpcy5mb3VuZCkge1xuICAgICAgcmVzdWx0ID0gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHZvaWQgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXShyZXN1bHQpO1xuICB9O1xuXG4gIFhGaW5kLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgaWYgKHRoaXMuZihpbnB1dCkpIHtcbiAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgcmVzdWx0ID0gX3JlZHVjZWQodGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICByZXR1cm4gWEZpbmQ7XG59KCk7XG5cbnZhciBfeGZpbmQgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBfeGZpbmQoZiwgeGYpIHtcbiAgcmV0dXJuIG5ldyBYRmluZChmLCB4Zik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgX3hmaW5kOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gXCIuL2ludGVybmFsL19kaXNwYXRjaGFibGUuanNcIjtcbmltcG9ydCBfeGZpbmQgZnJvbSBcIi4vaW50ZXJuYWwvX3hmaW5kLmpzXCI7XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGxpc3Qgd2hpY2ggbWF0Y2hlcyB0aGUgcHJlZGljYXRlLCBvclxuICogYHVuZGVmaW5lZGAgaWYgbm8gZWxlbWVudCBtYXRjaGVzLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGBmaW5kYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGluIGxpc3QgcG9zaXRpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gYSB8IHVuZGVmaW5lZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSBpZiB0aGUgZWxlbWVudCBpcyB0aGVcbiAqICAgICAgICBkZXNpcmVkIG9uZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZWxlbWVudCBmb3VuZCwgb3IgYHVuZGVmaW5lZGAuXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgeHMgPSBbe2E6IDF9LCB7YTogMn0sIHthOiAzfV07XG4gKiAgICAgIFIuZmluZChSLnByb3BFcSgnYScsIDIpKSh4cyk7IC8vPT4ge2E6IDJ9XG4gKiAgICAgIFIuZmluZChSLnByb3BFcSgnYScsIDQpKSh4cyk7IC8vPT4gdW5kZWZpbmVkXG4gKi9cblxudmFyIGZpbmQgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5Mihcbi8qI19fUFVSRV9fKi9cbl9kaXNwYXRjaGFibGUoWydmaW5kJ10sIF94ZmluZCwgZnVuY3Rpb24gZmluZChmbiwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBpZiAoZm4obGlzdFtpZHhdKSkge1xuICAgICAgcmV0dXJuIGxpc3RbaWR4XTtcbiAgICB9XG5cbiAgICBpZHggKz0gMTtcbiAgfVxufSkpO1xuXG5leHBvcnQgZGVmYXVsdCBmaW5kOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL19jdXJyeTIuanNcIjtcbmltcG9ydCBfcmVkdWNlZCBmcm9tIFwiLi9fcmVkdWNlZC5qc1wiO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSBcIi4vX3hmQmFzZS5qc1wiO1xuXG52YXIgWEZpbmRJbmRleCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhGaW5kSW5kZXgoZiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5mID0gZjtcbiAgICB0aGlzLmlkeCA9IC0xO1xuICAgIHRoaXMuZm91bmQgPSBmYWxzZTtcbiAgfVxuXG4gIFhGaW5kSW5kZXgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvaW5pdCddID0gX3hmQmFzZS5pbml0O1xuXG4gIFhGaW5kSW5kZXgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgaWYgKCF0aGlzLmZvdW5kKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgLTEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10ocmVzdWx0KTtcbiAgfTtcblxuICBYRmluZEluZGV4LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgdGhpcy5pZHggKz0gMTtcblxuICAgIGlmICh0aGlzLmYoaW5wdXQpKSB7XG4gICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgIHJlc3VsdCA9IF9yZWR1Y2VkKHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCB0aGlzLmlkeCkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIFhGaW5kSW5kZXg7XG59KCk7XG5cbnZhciBfeGZpbmRJbmRleCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIF94ZmluZEluZGV4KGYsIHhmKSB7XG4gIHJldHVybiBuZXcgWEZpbmRJbmRleChmLCB4Zik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgX3hmaW5kSW5kZXg7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9kaXNwYXRjaGFibGUgZnJvbSBcIi4vaW50ZXJuYWwvX2Rpc3BhdGNoYWJsZS5qc1wiO1xuaW1wb3J0IF94ZmluZEluZGV4IGZyb20gXCIuL2ludGVybmFsL194ZmluZEluZGV4LmpzXCI7XG4vKipcbiAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBsaXN0IHdoaWNoIG1hdGNoZXMgdGhlXG4gKiBwcmVkaWNhdGUsIG9yIGAtMWAgaWYgbm8gZWxlbWVudCBtYXRjaGVzLlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjFcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGVsZW1lbnQgaXMgdGhlXG4gKiBkZXNpcmVkIG9uZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgZm91bmQsIG9yIGAtMWAuXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgeHMgPSBbe2E6IDF9LCB7YTogMn0sIHthOiAzfV07XG4gKiAgICAgIFIuZmluZEluZGV4KFIucHJvcEVxKCdhJywgMikpKHhzKTsgLy89PiAxXG4gKiAgICAgIFIuZmluZEluZGV4KFIucHJvcEVxKCdhJywgNCkpKHhzKTsgLy89PiAtMVxuICovXG5cbnZhciBmaW5kSW5kZXggPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5Mihcbi8qI19fUFVSRV9fKi9cbl9kaXNwYXRjaGFibGUoW10sIF94ZmluZEluZGV4LCBmdW5jdGlvbiBmaW5kSW5kZXgoZm4sIGxpc3QpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgaWYgKGZuKGxpc3RbaWR4XSkpIHtcbiAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuXG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gLTE7XG59KSk7XG5cbmV4cG9ydCBkZWZhdWx0IGZpbmRJbmRleDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9fY3VycnkyLmpzXCI7XG5pbXBvcnQgX3hmQmFzZSBmcm9tIFwiLi9feGZCYXNlLmpzXCI7XG5cbnZhciBYRmluZExhc3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYRmluZExhc3QoZiwgeGYpIHtcbiAgICB0aGlzLnhmID0geGY7XG4gICAgdGhpcy5mID0gZjtcbiAgfVxuXG4gIFhGaW5kTGFzdC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG5cbiAgWEZpbmRMYXN0LnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3Jlc3VsdCddID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiB0aGlzLnhmWydAQHRyYW5zZHVjZXIvcmVzdWx0J10odGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIHRoaXMubGFzdCkpO1xuICB9O1xuXG4gIFhGaW5kTGFzdC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9zdGVwJ10gPSBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIGlmICh0aGlzLmYoaW5wdXQpKSB7XG4gICAgICB0aGlzLmxhc3QgPSBpbnB1dDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHJldHVybiBYRmluZExhc3Q7XG59KCk7XG5cbnZhciBfeGZpbmRMYXN0ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gX3hmaW5kTGFzdChmLCB4Zikge1xuICByZXR1cm4gbmV3IFhGaW5kTGFzdChmLCB4Zik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgX3hmaW5kTGFzdDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgX2Rpc3BhdGNoYWJsZSBmcm9tIFwiLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlLmpzXCI7XG5pbXBvcnQgX3hmaW5kTGFzdCBmcm9tIFwiLi9pbnRlcm5hbC9feGZpbmRMYXN0LmpzXCI7XG4vKipcbiAqIFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgbGlzdCB3aGljaCBtYXRjaGVzIHRoZSBwcmVkaWNhdGUsIG9yXG4gKiBgdW5kZWZpbmVkYCBpZiBubyBlbGVtZW50IG1hdGNoZXMuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMVxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW2FdIC0+IGEgfCB1bmRlZmluZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGVsZW1lbnQgaXMgdGhlXG4gKiBkZXNpcmVkIG9uZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZWxlbWVudCBmb3VuZCwgb3IgYHVuZGVmaW5lZGAuXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgeHMgPSBbe2E6IDEsIGI6IDB9LCB7YToxLCBiOiAxfV07XG4gKiAgICAgIFIuZmluZExhc3QoUi5wcm9wRXEoJ2EnLCAxKSkoeHMpOyAvLz0+IHthOiAxLCBiOiAxfVxuICogICAgICBSLmZpbmRMYXN0KFIucHJvcEVxKCdhJywgNCkpKHhzKTsgLy89PiB1bmRlZmluZWRcbiAqL1xuXG52YXIgZmluZExhc3QgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5Mihcbi8qI19fUFVSRV9fKi9cbl9kaXNwYXRjaGFibGUoW10sIF94ZmluZExhc3QsIGZ1bmN0aW9uIGZpbmRMYXN0KGZuLCBsaXN0KSB7XG4gIHZhciBpZHggPSBsaXN0Lmxlbmd0aCAtIDE7XG5cbiAgd2hpbGUgKGlkeCA+PSAwKSB7XG4gICAgaWYgKGZuKGxpc3RbaWR4XSkpIHtcbiAgICAgIHJldHVybiBsaXN0W2lkeF07XG4gICAgfVxuXG4gICAgaWR4IC09IDE7XG4gIH1cbn0pKTtcblxuZXhwb3J0IGRlZmF1bHQgZmluZExhc3Q7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF94ZkJhc2UgZnJvbSBcIi4vX3hmQmFzZS5qc1wiO1xuXG52YXIgWEZpbmRMYXN0SW5kZXggPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYRmluZExhc3RJbmRleChmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICAgIHRoaXMuaWR4ID0gLTE7XG4gICAgdGhpcy5sYXN0SWR4ID0gLTE7XG4gIH1cblxuICBYRmluZExhc3RJbmRleC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG5cbiAgWEZpbmRMYXN0SW5kZXgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHRoaXMueGZbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSh0aGlzLnhmWydAQHRyYW5zZHVjZXIvc3RlcCddKHJlc3VsdCwgdGhpcy5sYXN0SWR4KSk7XG4gIH07XG5cbiAgWEZpbmRMYXN0SW5kZXgucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICB0aGlzLmlkeCArPSAxO1xuXG4gICAgaWYgKHRoaXMuZihpbnB1dCkpIHtcbiAgICAgIHRoaXMubGFzdElkeCA9IHRoaXMuaWR4O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIFhGaW5kTGFzdEluZGV4O1xufSgpO1xuXG52YXIgX3hmaW5kTGFzdEluZGV4ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gX3hmaW5kTGFzdEluZGV4KGYsIHhmKSB7XG4gIHJldHVybiBuZXcgWEZpbmRMYXN0SW5kZXgoZiwgeGYpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IF94ZmluZExhc3RJbmRleDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgX2Rpc3BhdGNoYWJsZSBmcm9tIFwiLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlLmpzXCI7XG5pbXBvcnQgX3hmaW5kTGFzdEluZGV4IGZyb20gXCIuL2ludGVybmFsL194ZmluZExhc3RJbmRleC5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBlbGVtZW50IG9mIHRoZSBsaXN0IHdoaWNoIG1hdGNoZXMgdGhlXG4gKiBwcmVkaWNhdGUsIG9yIGAtMWAgaWYgbm8gZWxlbWVudCBtYXRjaGVzLlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjFcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gdXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGVsZW1lbnQgaXMgdGhlXG4gKiBkZXNpcmVkIG9uZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgZm91bmQsIG9yIGAtMWAuXG4gKiBAc2VlIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgeHMgPSBbe2E6IDEsIGI6IDB9LCB7YToxLCBiOiAxfV07XG4gKiAgICAgIFIuZmluZExhc3RJbmRleChSLnByb3BFcSgnYScsIDEpKSh4cyk7IC8vPT4gMVxuICogICAgICBSLmZpbmRMYXN0SW5kZXgoUi5wcm9wRXEoJ2EnLCA0KSkoeHMpOyAvLz0+IC0xXG4gKi9cblxudmFyIGZpbmRMYXN0SW5kZXggPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5Mihcbi8qI19fUFVSRV9fKi9cbl9kaXNwYXRjaGFibGUoW10sIF94ZmluZExhc3RJbmRleCwgZnVuY3Rpb24gZmluZExhc3RJbmRleChmbiwgbGlzdCkge1xuICB2YXIgaWR4ID0gbGlzdC5sZW5ndGggLSAxO1xuXG4gIHdoaWxlIChpZHggPj0gMCkge1xuICAgIGlmIChmbihsaXN0W2lkeF0pKSB7XG4gICAgICByZXR1cm4gaWR4O1xuICAgIH1cblxuICAgIGlkeCAtPSAxO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufSkpO1xuXG5leHBvcnQgZGVmYXVsdCBmaW5kTGFzdEluZGV4OyIsImltcG9ydCBfY3VycnkxIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTEuanNcIjtcbmltcG9ydCBfbWFrZUZsYXQgZnJvbSBcIi4vaW50ZXJuYWwvX21ha2VGbGF0LmpzXCI7XG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBieSBwdWxsaW5nIGV2ZXJ5IGl0ZW0gb3V0IG9mIGl0IChhbmQgYWxsIGl0cyBzdWItYXJyYXlzKVxuICogYW5kIHB1dHRpbmcgdGhlbSBpbiBhIG5ldyBhcnJheSwgZGVwdGgtZmlyc3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2JdXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgZmxhdHRlbmVkIGxpc3QuXG4gKiBAc2VlIFIudW5uZXN0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5mbGF0dGVuKFsxLCAyLCBbMywgNF0sIDUsIFs2LCBbNywgOCwgWzksIFsxMCwgMTFdLCAxMl1dXV0pO1xuICogICAgICAvLz0+IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyXVxuICovXG5cbnZhciBmbGF0dGVuID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoXG4vKiNfX1BVUkVfXyovXG5fbWFrZUZsYXQodHJ1ZSkpO1xuXG5leHBvcnQgZGVmYXVsdCBmbGF0dGVuOyIsImltcG9ydCBfY3VycnkxIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTEuanNcIjtcbmltcG9ydCBjdXJyeU4gZnJvbSBcIi4vY3VycnlOLmpzXCI7XG4vKipcbiAqIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gbXVjaCBsaWtlIHRoZSBzdXBwbGllZCBvbmUsIGV4Y2VwdCB0aGF0IHRoZSBmaXJzdCB0d29cbiAqIGFyZ3VtZW50cycgb3JkZXIgaXMgcmV2ZXJzZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKChhLCBiLCBjLCAuLi4pIC0+IHopIC0+IChiIC0+IGEgLT4gYyAtPiAuLi4gLT4geilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBpbnZva2Ugd2l0aCBpdHMgZmlyc3QgdHdvIHBhcmFtZXRlcnMgcmV2ZXJzZWQuXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmVzdWx0IG9mIGludm9raW5nIGBmbmAgd2l0aCBpdHMgZmlyc3QgdHdvIHBhcmFtZXRlcnMnIG9yZGVyIHJldmVyc2VkLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IG1lcmdlVGhyZWUgPSAoYSwgYiwgYykgPT4gW10uY29uY2F0KGEsIGIsIGMpO1xuICpcbiAqICAgICAgbWVyZ2VUaHJlZSgxLCAyLCAzKTsgLy89PiBbMSwgMiwgM11cbiAqXG4gKiAgICAgIFIuZmxpcChtZXJnZVRocmVlKSgxLCAyLCAzKTsgLy89PiBbMiwgMSwgM11cbiAqIEBzeW1iIFIuZmxpcChmKShhLCBiLCBjKSA9IGYoYiwgYSwgYylcbiAqL1xuXG52YXIgZmxpcCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKGZ1bmN0aW9uIGZsaXAoZm4pIHtcbiAgcmV0dXJuIGN1cnJ5Tihmbi5sZW5ndGgsIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgIGFyZ3NbMF0gPSBiO1xuICAgIGFyZ3NbMV0gPSBhO1xuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZmxpcDsiLCJpbXBvcnQgX2NoZWNrRm9yTWV0aG9kIGZyb20gXCIuL2ludGVybmFsL19jaGVja0Zvck1ldGhvZC5qc1wiO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gaW5wdXQgYGxpc3RgLCBjYWxsaW5nIGEgcHJvdmlkZWQgZnVuY3Rpb24gYGZuYCBmb3IgZWFjaFxuICogZWxlbWVudCBpbiB0aGUgbGlzdC5cbiAqXG4gKiBgZm5gIHJlY2VpdmVzIG9uZSBhcmd1bWVudDogKih2YWx1ZSkqLlxuICpcbiAqIE5vdGU6IGBSLmZvckVhY2hgIGRvZXMgbm90IHNraXAgZGVsZXRlZCBvciB1bmFzc2lnbmVkIGluZGljZXMgKHNwYXJzZVxuICogYXJyYXlzKSwgdW5saWtlIHRoZSBuYXRpdmUgYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2QuIEZvciBtb3JlXG4gKiBkZXRhaWxzIG9uIHRoaXMgYmVoYXZpb3IsIHNlZTpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZvckVhY2gjRGVzY3JpcHRpb25cbiAqXG4gKiBBbHNvIG5vdGUgdGhhdCwgdW5saWtlIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAsIFJhbWRhJ3MgYGZvckVhY2hgIHJldHVybnNcbiAqIHRoZSBvcmlnaW5hbCBhcnJheS4gSW4gc29tZSBsaWJyYXJpZXMgdGhpcyBmdW5jdGlvbiBpcyBuYW1lZCBgZWFjaGAuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGZvckVhY2hgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMVxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gKikgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGludm9rZS4gUmVjZWl2ZXMgb25lIGFyZ3VtZW50LCBgdmFsdWVgLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIG9yaWdpbmFsIGxpc3QuXG4gKiBAc2VlIFIuYWRkSW5kZXhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBwcmludFhQbHVzRml2ZSA9IHggPT4gY29uc29sZS5sb2coeCArIDUpO1xuICogICAgICBSLmZvckVhY2gocHJpbnRYUGx1c0ZpdmUsIFsxLCAyLCAzXSk7IC8vPT4gWzEsIDIsIDNdXG4gKiAgICAgIC8vIGxvZ3MgNlxuICogICAgICAvLyBsb2dzIDdcbiAqICAgICAgLy8gbG9ncyA4XG4gKiBAc3ltYiBSLmZvckVhY2goZiwgW2EsIGIsIGNdKSA9IFthLCBiLCBjXVxuICovXG5cbnZhciBmb3JFYWNoID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoXG4vKiNfX1BVUkVfXyovXG5fY2hlY2tGb3JNZXRob2QoJ2ZvckVhY2gnLCBmdW5jdGlvbiBmb3JFYWNoKGZuLCBsaXN0KSB7XG4gIHZhciBsZW4gPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIGlkeCA9IDA7XG5cbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGZuKGxpc3RbaWR4XSk7XG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn0pKTtcblxuZXhwb3J0IGRlZmF1bHQgZm9yRWFjaDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQga2V5cyBmcm9tIFwiLi9rZXlzLmpzXCI7XG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBpbnB1dCBgb2JqZWN0YCwgY2FsbGluZyBhIHByb3ZpZGVkIGZ1bmN0aW9uIGBmbmAgZm9yIGVhY2hcbiAqIGtleSBhbmQgdmFsdWUgaW4gdGhlIG9iamVjdC5cbiAqXG4gKiBgZm5gIHJlY2VpdmVzIHRocmVlIGFyZ3VtZW50OiAqKHZhbHVlLCBrZXksIG9iaikqLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIzLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgKChhLCBTdHJpbmcsIFN0ck1hcCBhKSAtPiBBbnkpIC0+IFN0ck1hcCBhIC0+IFN0ck1hcCBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLiBSZWNlaXZlcyB0aHJlZSBhcmd1bWVudCwgYHZhbHVlYCwgYGtleWAsIGBvYmpgLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIG9yaWdpbmFsIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBwcmludEtleUNvbmNhdFZhbHVlID0gKHZhbHVlLCBrZXkpID0+IGNvbnNvbGUubG9nKGtleSArICc6JyArIHZhbHVlKTtcbiAqICAgICAgUi5mb3JFYWNoT2JqSW5kZXhlZChwcmludEtleUNvbmNhdFZhbHVlLCB7eDogMSwgeTogMn0pOyAvLz0+IHt4OiAxLCB5OiAyfVxuICogICAgICAvLyBsb2dzIHg6MVxuICogICAgICAvLyBsb2dzIHk6MlxuICogQHN5bWIgUi5mb3JFYWNoT2JqSW5kZXhlZChmLCB7eDogYSwgeTogYn0pID0ge3g6IGEsIHk6IGJ9XG4gKi9cblxudmFyIGZvckVhY2hPYmpJbmRleGVkID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gZm9yRWFjaE9iakluZGV4ZWQoZm4sIG9iaikge1xuICB2YXIga2V5TGlzdCA9IGtleXMob2JqKTtcbiAgdmFyIGlkeCA9IDA7XG5cbiAgd2hpbGUgKGlkeCA8IGtleUxpc3QubGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IGtleUxpc3RbaWR4XTtcbiAgICBmbihvYmpba2V5XSwga2V5LCBvYmopO1xuICAgIGlkeCArPSAxO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBmb3JFYWNoT2JqSW5kZXhlZDsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkxLmpzXCI7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IGZyb20gYSBsaXN0IGtleS12YWx1ZSBwYWlycy4gSWYgYSBrZXkgYXBwZWFycyBpblxuICogbXVsdGlwbGUgcGFpcnMsIHRoZSByaWdodG1vc3QgcGFpciBpcyBpbmNsdWRlZCBpbiB0aGUgb2JqZWN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjMuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW1trLHZdXSAtPiB7azogdn1cbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIEFuIGFycmF5IG9mIHR3by1lbGVtZW50IGFycmF5cyB0aGF0IHdpbGwgYmUgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiB0aGUgb3V0cHV0IG9iamVjdC5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIG9iamVjdCBtYWRlIGJ5IHBhaXJpbmcgdXAgYGtleXNgIGFuZCBgdmFsdWVzYC5cbiAqIEBzZWUgUi50b1BhaXJzLCBSLnBhaXJcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmZyb21QYWlycyhbWydhJywgMV0sIFsnYicsIDJdLCBbJ2MnLCAzXV0pOyAvLz0+IHthOiAxLCBiOiAyLCBjOiAzfVxuICovXG5cbnZhciBmcm9tUGFpcnMgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiBmcm9tUGFpcnMocGFpcnMpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgaWR4ID0gMDtcblxuICB3aGlsZSAoaWR4IDwgcGFpcnMubGVuZ3RoKSB7XG4gICAgcmVzdWx0W3BhaXJzW2lkeF1bMF1dID0gcGFpcnNbaWR4XVsxXTtcbiAgICBpZHggKz0gMTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZnJvbVBhaXJzOyIsImltcG9ydCBfY2hlY2tGb3JNZXRob2QgZnJvbSBcIi4vaW50ZXJuYWwvX2NoZWNrRm9yTWV0aG9kLmpzXCI7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgcmVkdWNlQnkgZnJvbSBcIi4vcmVkdWNlQnkuanNcIjtcbi8qKlxuICogU3BsaXRzIGEgbGlzdCBpbnRvIHN1Yi1saXN0cyBzdG9yZWQgaW4gYW4gb2JqZWN0LCBiYXNlZCBvbiB0aGUgcmVzdWx0IG9mXG4gKiBjYWxsaW5nIGEgU3RyaW5nLXJldHVybmluZyBmdW5jdGlvbiBvbiBlYWNoIGVsZW1lbnQsIGFuZCBncm91cGluZyB0aGVcbiAqIHJlc3VsdHMgYWNjb3JkaW5nIHRvIHZhbHVlcyByZXR1cm5lZC5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgZ3JvdXBCeWAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKGEgLT4gU3RyaW5nKSAtPiBbYV0gLT4ge1N0cmluZzogW2FdfVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gOjogYSAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGdyb3VwXG4gKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBvdXRwdXQgb2YgYGZuYCBmb3Iga2V5cywgbWFwcGVkIHRvIGFycmF5cyBvZiBlbGVtZW50c1xuICogICAgICAgICB0aGF0IHByb2R1Y2VkIHRoYXQga2V5IHdoZW4gcGFzc2VkIHRvIGBmbmAuXG4gKiBAc2VlIFIucmVkdWNlQnksIFIudHJhbnNkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgYnlHcmFkZSA9IFIuZ3JvdXBCeShmdW5jdGlvbihzdHVkZW50KSB7XG4gKiAgICAgICAgY29uc3Qgc2NvcmUgPSBzdHVkZW50LnNjb3JlO1xuICogICAgICAgIHJldHVybiBzY29yZSA8IDY1ID8gJ0YnIDpcbiAqICAgICAgICAgICAgICAgc2NvcmUgPCA3MCA/ICdEJyA6XG4gKiAgICAgICAgICAgICAgIHNjb3JlIDwgODAgPyAnQycgOlxuICogICAgICAgICAgICAgICBzY29yZSA8IDkwID8gJ0InIDogJ0EnO1xuICogICAgICB9KTtcbiAqICAgICAgY29uc3Qgc3R1ZGVudHMgPSBbe25hbWU6ICdBYmJ5Jywgc2NvcmU6IDg0fSxcbiAqICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnRWRkeScsIHNjb3JlOiA1OH0sXG4gKiAgICAgICAgICAgICAgICAgICAgICAvLyAuLi5cbiAqICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnSmFjaycsIHNjb3JlOiA2OX1dO1xuICogICAgICBieUdyYWRlKHN0dWRlbnRzKTtcbiAqICAgICAgLy8ge1xuICogICAgICAvLyAgICdBJzogW3tuYW1lOiAnRGlhbm5lJywgc2NvcmU6IDk5fV0sXG4gKiAgICAgIC8vICAgJ0InOiBbe25hbWU6ICdBYmJ5Jywgc2NvcmU6IDg0fV1cbiAqICAgICAgLy8gICAvLyAuLi4sXG4gKiAgICAgIC8vICAgJ0YnOiBbe25hbWU6ICdFZGR5Jywgc2NvcmU6IDU4fV1cbiAqICAgICAgLy8gfVxuICovXG5cbnZhciBncm91cEJ5ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoXG4vKiNfX1BVUkVfXyovXG5fY2hlY2tGb3JNZXRob2QoJ2dyb3VwQnknLFxuLyojX19QVVJFX18qL1xucmVkdWNlQnkoZnVuY3Rpb24gKGFjYywgaXRlbSkge1xuICBpZiAoYWNjID09IG51bGwpIHtcbiAgICBhY2MgPSBbXTtcbiAgfVxuXG4gIGFjYy5wdXNoKGl0ZW0pO1xuICByZXR1cm4gYWNjO1xufSwgbnVsbCkpKTtcblxuZXhwb3J0IGRlZmF1bHQgZ3JvdXBCeTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG4vKipcbiAqIFRha2VzIGEgbGlzdCBhbmQgcmV0dXJucyBhIGxpc3Qgb2YgbGlzdHMgd2hlcmUgZWFjaCBzdWJsaXN0J3MgZWxlbWVudHMgYXJlXG4gKiBhbGwgc2F0aXNmaWVkIHBhaXJ3aXNlIGNvbXBhcmlzb24gYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAqIE9ubHkgYWRqYWNlbnQgZWxlbWVudHMgYXJlIHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoKGEsIGEpIOKGkiBCb29sZWFuKSDihpIgW2FdIOKGkiBbW2FdXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdHdvIGdpdmVuIChhZGphY2VudClcbiAqICAgICAgICBlbGVtZW50cyBzaG91bGQgYmUgaW4gdGhlIHNhbWUgZ3JvdXBcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGdyb3VwLiBBbHNvIGFjY2VwdHMgYSBzdHJpbmcsIHdoaWNoIHdpbGwgYmVcbiAqICAgICAgICB0cmVhdGVkIGFzIGEgbGlzdCBvZiBjaGFyYWN0ZXJzLlxuICogQHJldHVybiB7TGlzdH0gQSBsaXN0IHRoYXQgY29udGFpbnMgc3VibGlzdHMgb2YgZWxlbWVudHMsXG4gKiAgICAgICAgIHdob3NlIGNvbmNhdGVuYXRpb25zIGFyZSBlcXVhbCB0byB0aGUgb3JpZ2luYWwgbGlzdC5cbiAqIEBleGFtcGxlXG4gKlxuICogUi5ncm91cFdpdGgoUi5lcXVhbHMsIFswLCAxLCAxLCAyLCAzLCA1LCA4LCAxMywgMjFdKVxuICogLy89PiBbWzBdLCBbMSwgMV0sIFsyXSwgWzNdLCBbNV0sIFs4XSwgWzEzXSwgWzIxXV1cbiAqXG4gKiBSLmdyb3VwV2l0aCgoYSwgYikgPT4gYSArIDEgPT09IGIsIFswLCAxLCAxLCAyLCAzLCA1LCA4LCAxMywgMjFdKVxuICogLy89PiBbWzAsIDFdLCBbMSwgMiwgM10sIFs1XSwgWzhdLCBbMTNdLCBbMjFdXVxuICpcbiAqIFIuZ3JvdXBXaXRoKChhLCBiKSA9PiBhICUgMiA9PT0gYiAlIDIsIFswLCAxLCAxLCAyLCAzLCA1LCA4LCAxMywgMjFdKVxuICogLy89PiBbWzBdLCBbMSwgMV0sIFsyXSwgWzMsIDVdLCBbOF0sIFsxMywgMjFdXVxuICpcbiAqIFIuZ3JvdXBXaXRoKFIuZXFCeShpc1Zvd2VsKSwgJ2Flc3Rpb3UnKVxuICogLy89PiBbJ2FlJywgJ3N0JywgJ2lvdSddXG4gKi9cblxudmFyIGdyb3VwV2l0aCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIChmbiwgbGlzdCkge1xuICB2YXIgcmVzID0gW107XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHZhciBuZXh0aWR4ID0gaWR4ICsgMTtcblxuICAgIHdoaWxlIChuZXh0aWR4IDwgbGVuICYmIGZuKGxpc3RbbmV4dGlkeCAtIDFdLCBsaXN0W25leHRpZHhdKSkge1xuICAgICAgbmV4dGlkeCArPSAxO1xuICAgIH1cblxuICAgIHJlcy5wdXNoKGxpc3Quc2xpY2UoaWR4LCBuZXh0aWR4KSk7XG4gICAgaWR4ID0gbmV4dGlkeDtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZ3JvdXBXaXRoOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGdyZWF0ZXIgdGhhbiB0aGUgc2Vjb25kOyBgZmFsc2VgXG4gKiBvdGhlcndpc2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0gYVxuICogQHBhcmFtIHsqfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLmx0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5ndCgyLCAxKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuZ3QoMiwgMik7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5ndCgyLCAzKTsgLy89PiBmYWxzZVxuICogICAgICBSLmd0KCdhJywgJ3onKTsgLy89PiBmYWxzZVxuICogICAgICBSLmd0KCd6JywgJ2EnKTsgLy89PiB0cnVlXG4gKi9cblxudmFyIGd0ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gZ3QoYSwgYikge1xuICByZXR1cm4gYSA+IGI7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgZ3Q7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzZWNvbmQ7XG4gKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gQm9vbGVhblxuICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLmx0ZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuZ3RlKDIsIDEpOyAvLz0+IHRydWVcbiAqICAgICAgUi5ndGUoMiwgMik7IC8vPT4gdHJ1ZVxuICogICAgICBSLmd0ZSgyLCAzKTsgLy89PiBmYWxzZVxuICogICAgICBSLmd0ZSgnYScsICd6Jyk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5ndGUoJ3onLCAnYScpOyAvLz0+IHRydWVcbiAqL1xuXG52YXIgZ3RlID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gZ3RlKGEsIGIpIHtcbiAgcmV0dXJuIGEgPj0gYjtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBndGU7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9oYXMgZnJvbSBcIi4vaW50ZXJuYWwvX2hhcy5qc1wiO1xuaW1wb3J0IGlzTmlsIGZyb20gXCIuL2lzTmlsLmpzXCI7XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgYSBwYXRoIGV4aXN0cyBpbiBhbiBvYmplY3QuIE9ubHkgdGhlIG9iamVjdCdzXG4gKiBvd24gcHJvcGVydGllcyBhcmUgY2hlY2tlZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yNi4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gSWR4ID0gU3RyaW5nIHwgSW50XG4gKiBAc2lnIFtJZHhdIC0+IHthfSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIHVzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBjaGVjayB0aGUgcGF0aCBpbi5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHBhdGggZXhpc3RzLlxuICogQHNlZSBSLmhhc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaGFzUGF0aChbJ2EnLCAnYiddLCB7YToge2I6IDJ9fSk7ICAgICAgICAgLy8gPT4gdHJ1ZVxuICogICAgICBSLmhhc1BhdGgoWydhJywgJ2InXSwge2E6IHtiOiB1bmRlZmluZWR9fSk7IC8vID0+IHRydWVcbiAqICAgICAgUi5oYXNQYXRoKFsnYScsICdiJ10sIHthOiB7YzogMn19KTsgICAgICAgICAvLyA9PiBmYWxzZVxuICogICAgICBSLmhhc1BhdGgoWydhJywgJ2InXSwge30pOyAgICAgICAgICAgICAgICAgIC8vID0+IGZhbHNlXG4gKi9cblxudmFyIGhhc1BhdGggPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBoYXNQYXRoKF9wYXRoLCBvYmopIHtcbiAgaWYgKF9wYXRoLmxlbmd0aCA9PT0gMCB8fCBpc05pbChvYmopKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHZhbCA9IG9iajtcbiAgdmFyIGlkeCA9IDA7XG5cbiAgd2hpbGUgKGlkeCA8IF9wYXRoLmxlbmd0aCkge1xuICAgIGlmICghaXNOaWwodmFsKSAmJiBfaGFzKF9wYXRoW2lkeF0sIHZhbCkpIHtcbiAgICAgIHZhbCA9IHZhbFtfcGF0aFtpZHhdXTtcbiAgICAgIGlkeCArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgaGFzUGF0aDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgaGFzUGF0aCBmcm9tIFwiLi9oYXNQYXRoLmpzXCI7XG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGhhcyBhbiBvd24gcHJvcGVydHkgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWVcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgcyAtPiB7czogeH0gLT4gQm9vbGVhblxuICogQHBhcmFtIHtTdHJpbmd9IHByb3AgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGNoZWNrIGZvci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IGV4aXN0cy5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBoYXNOYW1lID0gUi5oYXMoJ25hbWUnKTtcbiAqICAgICAgaGFzTmFtZSh7bmFtZTogJ2FsaWNlJ30pOyAgIC8vPT4gdHJ1ZVxuICogICAgICBoYXNOYW1lKHtuYW1lOiAnYm9iJ30pOyAgICAgLy89PiB0cnVlXG4gKiAgICAgIGhhc05hbWUoe30pOyAgICAgICAgICAgICAgICAvLz0+IGZhbHNlXG4gKlxuICogICAgICBjb25zdCBwb2ludCA9IHt4OiAwLCB5OiAwfTtcbiAqICAgICAgY29uc3QgcG9pbnRIYXMgPSBSLmhhcyhSLl9fLCBwb2ludCk7XG4gKiAgICAgIHBvaW50SGFzKCd4Jyk7ICAvLz0+IHRydWVcbiAqICAgICAgcG9pbnRIYXMoJ3knKTsgIC8vPT4gdHJ1ZVxuICogICAgICBwb2ludEhhcygneicpOyAgLy89PiBmYWxzZVxuICovXG5cbnZhciBoYXMgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBoYXMocHJvcCwgb2JqKSB7XG4gIHJldHVybiBoYXNQYXRoKFtwcm9wXSwgb2JqKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBoYXM7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBvciBpdHMgcHJvdG90eXBlIGNoYWluIGhhcyBhIHByb3BlcnR5IHdpdGhcbiAqIHRoZSBzcGVjaWZpZWQgbmFtZVxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBzIC0+IHtzOiB4fSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY2hlY2sgZm9yLlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgZXhpc3RzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGZ1bmN0aW9uIFJlY3RhbmdsZSh3aWR0aCwgaGVpZ2h0KSB7XG4gKiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICogICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICogICAgICB9XG4gKiAgICAgIFJlY3RhbmdsZS5wcm90b3R5cGUuYXJlYSA9IGZ1bmN0aW9uKCkge1xuICogICAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQ7XG4gKiAgICAgIH07XG4gKlxuICogICAgICBjb25zdCBzcXVhcmUgPSBuZXcgUmVjdGFuZ2xlKDIsIDIpO1xuICogICAgICBSLmhhc0luKCd3aWR0aCcsIHNxdWFyZSk7ICAvLz0+IHRydWVcbiAqICAgICAgUi5oYXNJbignYXJlYScsIHNxdWFyZSk7ICAvLz0+IHRydWVcbiAqL1xuXG52YXIgaGFzSW4gPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBoYXNJbihwcm9wLCBvYmopIHtcbiAgcmV0dXJuIHByb3AgaW4gb2JqO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGhhc0luOyIsImltcG9ydCBfb2JqZWN0SXMgZnJvbSBcIi4vaW50ZXJuYWwvX29iamVjdElzLmpzXCI7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBpdHMgYXJndW1lbnRzIGFyZSBpZGVudGljYWwsIGZhbHNlIG90aGVyd2lzZS4gVmFsdWVzIGFyZVxuICogaWRlbnRpY2FsIGlmIHRoZXkgcmVmZXJlbmNlIHRoZSBzYW1lIG1lbW9yeS4gYE5hTmAgaXMgaWRlbnRpY2FsIHRvIGBOYU5gO1xuICogYDBgIGFuZCBgLTBgIGFyZSBub3QgaWRlbnRpY2FsLlxuICpcbiAqIE5vdGUgdGhpcyBpcyBtZXJlbHkgYSBjdXJyaWVkIHZlcnNpb24gb2YgRVM2IGBPYmplY3QuaXNgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE1LjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBhIC0+IGEgLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgbyA9IHt9O1xuICogICAgICBSLmlkZW50aWNhbChvLCBvKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaWRlbnRpY2FsKDEsIDEpOyAvLz0+IHRydWVcbiAqICAgICAgUi5pZGVudGljYWwoMSwgJzEnKTsgLy89PiBmYWxzZVxuICogICAgICBSLmlkZW50aWNhbChbXSwgW10pOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaWRlbnRpY2FsKDAsIC0wKTsgLy89PiBmYWxzZVxuICogICAgICBSLmlkZW50aWNhbChOYU4sIE5hTik7IC8vPT4gdHJ1ZVxuICovXG5cbnZhciBpZGVudGljYWwgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5Mihfb2JqZWN0SXMpO1xuXG5leHBvcnQgZGVmYXVsdCBpZGVudGljYWw7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5My5qc1wiO1xuaW1wb3J0IGN1cnJ5TiBmcm9tIFwiLi9jdXJyeU4uanNcIjtcbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBwcm9jZXNzIGVpdGhlciB0aGUgYG9uVHJ1ZWAgb3IgdGhlIGBvbkZhbHNlYFxuICogZnVuY3Rpb24gZGVwZW5kaW5nIHVwb24gdGhlIHJlc3VsdCBvZiB0aGUgYGNvbmRpdGlvbmAgcHJlZGljYXRlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjguMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnICgqLi4uIC0+IEJvb2xlYW4pIC0+ICgqLi4uIC0+ICopIC0+ICgqLi4uIC0+ICopIC0+ICgqLi4uIC0+ICopXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25kaXRpb24gQSBwcmVkaWNhdGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9uVHJ1ZSBBIGZ1bmN0aW9uIHRvIGludm9rZSB3aGVuIHRoZSBgY29uZGl0aW9uYCBldmFsdWF0ZXMgdG8gYSB0cnV0aHkgdmFsdWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZhbHNlIEEgZnVuY3Rpb24gdG8gaW52b2tlIHdoZW4gdGhlIGBjb25kaXRpb25gIGV2YWx1YXRlcyB0byBhIGZhbHN5IHZhbHVlLlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3IGZ1bmN0aW9uIHRoYXQgd2lsbCBwcm9jZXNzIGVpdGhlciB0aGUgYG9uVHJ1ZWAgb3IgdGhlIGBvbkZhbHNlYFxuICogICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGRlcGVuZGluZyB1cG9uIHRoZSByZXN1bHQgb2YgdGhlIGBjb25kaXRpb25gIHByZWRpY2F0ZS5cbiAqIEBzZWUgUi51bmxlc3MsIFIud2hlbiwgUi5jb25kXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgaW5jQ291bnQgPSBSLmlmRWxzZShcbiAqICAgICAgICBSLmhhcygnY291bnQnKSxcbiAqICAgICAgICBSLm92ZXIoUi5sZW5zUHJvcCgnY291bnQnKSwgUi5pbmMpLFxuICogICAgICAgIFIuYXNzb2MoJ2NvdW50JywgMSlcbiAqICAgICAgKTtcbiAqICAgICAgaW5jQ291bnQoe30pOyAgICAgICAgICAgLy89PiB7IGNvdW50OiAxIH1cbiAqICAgICAgaW5jQ291bnQoeyBjb3VudDogMSB9KTsgLy89PiB7IGNvdW50OiAyIH1cbiAqL1xuXG52YXIgaWZFbHNlID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTMoZnVuY3Rpb24gaWZFbHNlKGNvbmRpdGlvbiwgb25UcnVlLCBvbkZhbHNlKSB7XG4gIHJldHVybiBjdXJyeU4oTWF0aC5tYXgoY29uZGl0aW9uLmxlbmd0aCwgb25UcnVlLmxlbmd0aCwgb25GYWxzZS5sZW5ndGgpLCBmdW5jdGlvbiBfaWZFbHNlKCkge1xuICAgIHJldHVybiBjb25kaXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSA/IG9uVHJ1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogb25GYWxzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBpZkVsc2U7IiwiaW1wb3J0IGFkZCBmcm9tIFwiLi9hZGQuanNcIjtcbi8qKlxuICogSW5jcmVtZW50cyBpdHMgYXJndW1lbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7TnVtYmVyfSBuICsgMVxuICogQHNlZSBSLmRlY1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaW5jKDQyKTsgLy89PiA0M1xuICovXG5cbnZhciBpbmMgPVxuLyojX19QVVJFX18qL1xuYWRkKDEpO1xuZXhwb3J0IGRlZmF1bHQgaW5jOyIsImltcG9ydCBfaW5jbHVkZXMgZnJvbSBcIi4vaW50ZXJuYWwvX2luY2x1ZGVzLmpzXCI7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgZXF1YWwsIGluIFtgUi5lcXVhbHNgXSgjZXF1YWxzKVxuICogdGVybXMsIHRvIGF0IGxlYXN0IG9uZSBlbGVtZW50IG9mIHRoZSBnaXZlbiBsaXN0OyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqIFdvcmtzIGFsc28gd2l0aCBzdHJpbmdzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjI2LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIGEgLT4gW2FdIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBpdGVtIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGFuIGVxdWl2YWxlbnQgaXRlbSBpcyBpbiB0aGUgbGlzdCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKiBAc2VlIFIuYW55XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5pbmNsdWRlcygzLCBbMSwgMiwgM10pOyAvLz0+IHRydWVcbiAqICAgICAgUi5pbmNsdWRlcyg0LCBbMSwgMiwgM10pOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIuaW5jbHVkZXMoeyBuYW1lOiAnRnJlZCcgfSwgW3sgbmFtZTogJ0ZyZWQnIH1dKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaW5jbHVkZXMoWzQyXSwgW1s0Ml1dKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaW5jbHVkZXMoJ2JhJywgJ2JhbmFuYScpOyAvLz0+dHJ1ZVxuICovXG5cbnZhciBpbmNsdWRlcyA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKF9pbmNsdWRlcyk7XG5cbmV4cG9ydCBkZWZhdWx0IGluY2x1ZGVzOyIsImltcG9ydCByZWR1Y2VCeSBmcm9tIFwiLi9yZWR1Y2VCeS5qc1wiO1xuLyoqXG4gKiBHaXZlbiBhIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzIGEga2V5LCB0dXJucyBhIGxpc3Qgb2Ygb2JqZWN0cyBpbnRvIGFuXG4gKiBvYmplY3QgaW5kZXhpbmcgdGhlIG9iamVjdHMgYnkgdGhlIGdpdmVuIGtleS4gTm90ZSB0aGF0IGlmIG11bHRpcGxlXG4gKiBvYmplY3RzIGdlbmVyYXRlIHRoZSBzYW1lIHZhbHVlIGZvciB0aGUgaW5kZXhpbmcga2V5IG9ubHkgdGhlIGxhc3QgdmFsdWVcbiAqIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIGdlbmVyYXRlZCBvYmplY3QuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IFN0cmluZykgLT4gW3trOiB2fV0gLT4ge2s6IHtrOiB2fX1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIDo6IGEgLT4gU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2Ygb2JqZWN0cyB0byBpbmRleFxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgaW5kZXhpbmcgZWFjaCBhcnJheSBlbGVtZW50IGJ5IHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBsaXN0ID0gW3tpZDogJ3h5eicsIHRpdGxlOiAnQSd9LCB7aWQ6ICdhYmMnLCB0aXRsZTogJ0InfV07XG4gKiAgICAgIFIuaW5kZXhCeShSLnByb3AoJ2lkJyksIGxpc3QpO1xuICogICAgICAvLz0+IHthYmM6IHtpZDogJ2FiYycsIHRpdGxlOiAnQid9LCB4eXo6IHtpZDogJ3h5eicsIHRpdGxlOiAnQSd9fVxuICovXG5cbnZhciBpbmRleEJ5ID1cbi8qI19fUFVSRV9fKi9cbnJlZHVjZUJ5KGZ1bmN0aW9uIChhY2MsIGVsZW0pIHtcbiAgcmV0dXJuIGVsZW07XG59LCBudWxsKTtcbmV4cG9ydCBkZWZhdWx0IGluZGV4Qnk7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9pbmRleE9mIGZyb20gXCIuL2ludGVybmFsL19pbmRleE9mLmpzXCI7XG5pbXBvcnQgX2lzQXJyYXkgZnJvbSBcIi4vaW50ZXJuYWwvX2lzQXJyYXkuanNcIjtcbi8qKlxuICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSwgb3IgLTFcbiAqIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuIFtgUi5lcXVhbHNgXSgjZXF1YWxzKSBpcyB1c2VkIHRvXG4gKiBkZXRlcm1pbmUgZXF1YWxpdHkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBhIC0+IFthXSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSBpdGVtIHRvIGZpbmQuXG4gKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgYXJyYXkgdG8gc2VhcmNoIGluLlxuICogQHJldHVybiB7TnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIHRhcmdldCwgb3IgLTEgaWYgdGhlIHRhcmdldCBpcyBub3QgZm91bmQuXG4gKiBAc2VlIFIubGFzdEluZGV4T2ZcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmluZGV4T2YoMywgWzEsMiwzLDRdKTsgLy89PiAyXG4gKiAgICAgIFIuaW5kZXhPZigxMCwgWzEsMiwzLDRdKTsgLy89PiAtMVxuICovXG5cbnZhciBpbmRleE9mID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gaW5kZXhPZih0YXJnZXQsIHhzKSB7XG4gIHJldHVybiB0eXBlb2YgeHMuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJyAmJiAhX2lzQXJyYXkoeHMpID8geHMuaW5kZXhPZih0YXJnZXQpIDogX2luZGV4T2YoeHMsIHRhcmdldCwgMCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgaW5kZXhPZjsiLCJpbXBvcnQgc2xpY2UgZnJvbSBcIi4vc2xpY2UuanNcIjtcbi8qKlxuICogUmV0dXJucyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIGdpdmVuIGxpc3Qgb3Igc3RyaW5nLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IFthXVxuICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nXG4gKiBAcGFyYW0geyp9IGxpc3RcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIubGFzdCwgUi5oZWFkLCBSLnRhaWxcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmluaXQoWzEsIDIsIDNdKTsgIC8vPT4gWzEsIDJdXG4gKiAgICAgIFIuaW5pdChbMSwgMl0pOyAgICAgLy89PiBbMV1cbiAqICAgICAgUi5pbml0KFsxXSk7ICAgICAgICAvLz0+IFtdXG4gKiAgICAgIFIuaW5pdChbXSk7ICAgICAgICAgLy89PiBbXVxuICpcbiAqICAgICAgUi5pbml0KCdhYmMnKTsgIC8vPT4gJ2FiJ1xuICogICAgICBSLmluaXQoJ2FiJyk7ICAgLy89PiAnYSdcbiAqICAgICAgUi5pbml0KCdhJyk7ICAgIC8vPT4gJydcbiAqICAgICAgUi5pbml0KCcnKTsgICAgIC8vPT4gJydcbiAqL1xuXG52YXIgaW5pdCA9XG4vKiNfX1BVUkVfXyovXG5zbGljZSgwLCAtMSk7XG5leHBvcnQgZGVmYXVsdCBpbml0OyIsImltcG9ydCBfaW5jbHVkZXNXaXRoIGZyb20gXCIuL2ludGVybmFsL19pbmNsdWRlc1dpdGguanNcIjtcbmltcG9ydCBfY3VycnkzIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTMuanNcIjtcbmltcG9ydCBfZmlsdGVyIGZyb20gXCIuL2ludGVybmFsL19maWx0ZXIuanNcIjtcbi8qKlxuICogVGFrZXMgYSBwcmVkaWNhdGUgYHByZWRgLCBhIGxpc3QgYHhzYCwgYW5kIGEgbGlzdCBgeXNgLCBhbmQgcmV0dXJucyBhIGxpc3RcbiAqIGB4cydgIGNvbXByaXNpbmcgZWFjaCBvZiB0aGUgZWxlbWVudHMgb2YgYHhzYCB3aGljaCBpcyBlcXVhbCB0byBvbmUgb3IgbW9yZVxuICogZWxlbWVudHMgb2YgYHlzYCBhY2NvcmRpbmcgdG8gYHByZWRgLlxuICpcbiAqIGBwcmVkYCBtdXN0IGJlIGEgYmluYXJ5IGZ1bmN0aW9uIGV4cGVjdGluZyBhbiBlbGVtZW50IGZyb20gZWFjaCBsaXN0LlxuICpcbiAqIGB4c2AsIGB5c2AsIGFuZCBgeHMnYCBhcmUgdHJlYXRlZCBhcyBzZXRzLCBzZW1hbnRpY2FsbHksIHNvIG9yZGVyaW5nIHNob3VsZFxuICogbm90IGJlIHNpZ25pZmljYW50LCBidXQgc2luY2UgYHhzJ2AgaXMgb3JkZXJlZCB0aGUgaW1wbGVtZW50YXRpb24gZ3VhcmFudGVlc1xuICogdGhhdCBpdHMgdmFsdWVzIGFyZSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGV5IGFwcGVhciBpbiBgeHNgLiBEdXBsaWNhdGVzIGFyZVxuICogbm90IHJlbW92ZWQsIHNvIGB4cydgIG1heSBjb250YWluIGR1cGxpY2F0ZXMgaWYgYHhzYCBjb250YWlucyBkdXBsaWNhdGVzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjI0LjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyAoKGEsIGIpIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYl0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkXG4gKiBAcGFyYW0ge0FycmF5fSB4c1xuICogQHBhcmFtIHtBcnJheX0geXNcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHNlZSBSLmludGVyc2VjdGlvblxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaW5uZXJKb2luKFxuICogICAgICAgIChyZWNvcmQsIGlkKSA9PiByZWNvcmQuaWQgPT09IGlkLFxuICogICAgICAgIFt7aWQ6IDgyNCwgbmFtZTogJ1JpY2hpZSBGdXJheSd9LFxuICogICAgICAgICB7aWQ6IDk1NiwgbmFtZTogJ0Rld2V5IE1hcnRpbid9LFxuICogICAgICAgICB7aWQ6IDMxMywgbmFtZTogJ0JydWNlIFBhbG1lcid9LFxuICogICAgICAgICB7aWQ6IDQ1NiwgbmFtZTogJ1N0ZXBoZW4gU3RpbGxzJ30sXG4gKiAgICAgICAgIHtpZDogMTc3LCBuYW1lOiAnTmVpbCBZb3VuZyd9XSxcbiAqICAgICAgICBbMTc3LCA0NTYsIDk5OV1cbiAqICAgICAgKTtcbiAqICAgICAgLy89PiBbe2lkOiA0NTYsIG5hbWU6ICdTdGVwaGVuIFN0aWxscyd9LCB7aWQ6IDE3NywgbmFtZTogJ05laWwgWW91bmcnfV1cbiAqL1xuXG52YXIgaW5uZXJKb2luID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTMoZnVuY3Rpb24gaW5uZXJKb2luKHByZWQsIHhzLCB5cykge1xuICByZXR1cm4gX2ZpbHRlcihmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiBfaW5jbHVkZXNXaXRoKHByZWQsIHgsIHlzKTtcbiAgfSwgeHMpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGlubmVySm9pbjsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkzLmpzXCI7XG4vKipcbiAqIEluc2VydHMgdGhlIHN1cHBsaWVkIGVsZW1lbnQgaW50byB0aGUgbGlzdCwgYXQgdGhlIHNwZWNpZmllZCBgaW5kZXhgLiBfTm90ZSB0aGF0XG5cbiAqIHRoaXMgaXMgbm90IGRlc3RydWN0aXZlXzogaXQgcmV0dXJucyBhIGNvcHkgb2YgdGhlIGxpc3Qgd2l0aCB0aGUgY2hhbmdlcy5cbiAqIDxzbWFsbD5ObyBsaXN0cyBoYXZlIGJlZW4gaGFybWVkIGluIHRoZSBhcHBsaWNhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uLjwvc21hbGw+XG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMi4yXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gYSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge051bWJlcn0gaW5kZXggVGhlIHBvc2l0aW9uIHRvIGluc2VydCB0aGUgZWxlbWVudFxuICogQHBhcmFtIHsqfSBlbHQgVGhlIGVsZW1lbnQgdG8gaW5zZXJ0IGludG8gdGhlIEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGluc2VydCBpbnRvXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgQXJyYXkgd2l0aCBgZWx0YCBpbnNlcnRlZCBhdCBgaW5kZXhgLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuaW5zZXJ0KDIsICd4JywgWzEsMiwzLDRdKTsgLy89PiBbMSwyLCd4JywzLDRdXG4gKi9cblxudmFyIGluc2VydCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKGZ1bmN0aW9uIGluc2VydChpZHgsIGVsdCwgbGlzdCkge1xuICBpZHggPSBpZHggPCBsaXN0Lmxlbmd0aCAmJiBpZHggPj0gMCA/IGlkeCA6IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCk7XG4gIHJlc3VsdC5zcGxpY2UoaWR4LCAwLCBlbHQpO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGluc2VydDsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkzLmpzXCI7XG4vKipcbiAqIEluc2VydHMgdGhlIHN1Yi1saXN0IGludG8gdGhlIGxpc3QsIGF0IHRoZSBzcGVjaWZpZWQgYGluZGV4YC4gX05vdGUgdGhhdCB0aGlzIGlzIG5vdFxuICogZGVzdHJ1Y3RpdmVfOiBpdCByZXR1cm5zIGEgY29weSBvZiB0aGUgbGlzdCB3aXRoIHRoZSBjaGFuZ2VzLlxuICogPHNtYWxsPk5vIGxpc3RzIGhhdmUgYmVlbiBoYXJtZWQgaW4gdGhlIGFwcGxpY2F0aW9uIG9mIHRoaXMgZnVuY3Rpb24uPC9zbWFsbD5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIE51bWJlciAtPiBbYV0gLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBwb3NpdGlvbiB0byBpbnNlcnQgdGhlIHN1Yi1saXN0XG4gKiBAcGFyYW0ge0FycmF5fSBlbHRzIFRoZSBzdWItbGlzdCB0byBpbnNlcnQgaW50byB0aGUgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaW5zZXJ0IHRoZSBzdWItbGlzdCBpbnRvXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgQXJyYXkgd2l0aCBgZWx0c2AgaW5zZXJ0ZWQgc3RhcnRpbmcgYXQgYGluZGV4YC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmluc2VydEFsbCgyLCBbJ3gnLCd5JywneiddLCBbMSwyLDMsNF0pOyAvLz0+IFsxLDIsJ3gnLCd5JywneicsMyw0XVxuICovXG5cbnZhciBpbnNlcnRBbGwgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MyhmdW5jdGlvbiBpbnNlcnRBbGwoaWR4LCBlbHRzLCBsaXN0KSB7XG4gIGlkeCA9IGlkeCA8IGxpc3QubGVuZ3RoICYmIGlkeCA+PSAwID8gaWR4IDogbGlzdC5sZW5ndGg7XG4gIHJldHVybiBbXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCwgaWR4KSwgZWx0cywgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgaWR4KSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgaW5zZXJ0QWxsOyIsImltcG9ydCBfU2V0IGZyb20gXCIuL2ludGVybmFsL19TZXQuanNcIjtcbmltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgb25seSBvbmUgY29weSBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIG9yaWdpbmFsXG4gKiBsaXN0LCBiYXNlZCB1cG9uIHRoZSB2YWx1ZSByZXR1cm5lZCBieSBhcHBseWluZyB0aGUgc3VwcGxpZWQgZnVuY3Rpb24gdG9cbiAqIGVhY2ggbGlzdCBlbGVtZW50LiBQcmVmZXJzIHRoZSBmaXJzdCBpdGVtIGlmIHRoZSBzdXBwbGllZCBmdW5jdGlvbiBwcm9kdWNlc1xuICogdGhlIHNhbWUgdmFsdWUgb24gdHdvIGl0ZW1zLiBbYFIuZXF1YWxzYF0oI2VxdWFscykgaXMgdXNlZCBmb3IgY29tcGFyaXNvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBiKSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBBIGZ1bmN0aW9uIHVzZWQgdG8gcHJvZHVjZSBhIHZhbHVlIHRvIHVzZSBkdXJpbmcgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBjb25zaWRlci5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiB1bmlxdWUgaXRlbXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi51bmlxQnkoTWF0aC5hYnMsIFstMSwgLTUsIDIsIDEwLCAxLCAyXSk7IC8vPT4gWy0xLCAtNSwgMiwgMTBdXG4gKi9cblxudmFyIHVuaXFCeSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIHVuaXFCeShmbiwgbGlzdCkge1xuICB2YXIgc2V0ID0gbmV3IF9TZXQoKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGFwcGxpZWRJdGVtLCBpdGVtO1xuXG4gIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgIGl0ZW0gPSBsaXN0W2lkeF07XG4gICAgYXBwbGllZEl0ZW0gPSBmbihpdGVtKTtcblxuICAgIGlmIChzZXQuYWRkKGFwcGxpZWRJdGVtKSkge1xuICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgfVxuXG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHVuaXFCeTsiLCJpbXBvcnQgaWRlbnRpdHkgZnJvbSBcIi4vaWRlbnRpdHkuanNcIjtcbmltcG9ydCB1bmlxQnkgZnJvbSBcIi4vdW5pcUJ5LmpzXCI7XG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBjb250YWluaW5nIG9ubHkgb25lIGNvcHkgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBvcmlnaW5hbFxuICogbGlzdC4gW2BSLmVxdWFsc2BdKCNlcXVhbHMpIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGVxdWFsaXR5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IFthXVxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgdW5pcXVlIGl0ZW1zLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudW5pcShbMSwgMSwgMiwgMV0pOyAvLz0+IFsxLCAyXVxuICogICAgICBSLnVuaXEoWzEsICcxJ10pOyAgICAgLy89PiBbMSwgJzEnXVxuICogICAgICBSLnVuaXEoW1s0Ml0sIFs0Ml1dKTsgLy89PiBbWzQyXV1cbiAqL1xuXG52YXIgdW5pcSA9XG4vKiNfX1BVUkVfXyovXG51bmlxQnkoaWRlbnRpdHkpO1xuZXhwb3J0IGRlZmF1bHQgdW5pcTsiLCJpbXBvcnQgX2luY2x1ZGVzIGZyb20gXCIuL2ludGVybmFsL19pbmNsdWRlcy5qc1wiO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9maWx0ZXIgZnJvbSBcIi4vaW50ZXJuYWwvX2ZpbHRlci5qc1wiO1xuaW1wb3J0IGZsaXAgZnJvbSBcIi4vZmxpcC5qc1wiO1xuaW1wb3J0IHVuaXEgZnJvbSBcIi4vdW5pcS5qc1wiO1xuLyoqXG4gKiBDb21iaW5lcyB0d28gbGlzdHMgaW50byBhIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBjb21wb3NlZCBvZiB0aG9zZVxuICogZWxlbWVudHMgY29tbW9uIHRvIGJvdGggbGlzdHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgWypdIC0+IFsqXSAtPiBbKl1cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIGVsZW1lbnRzIGZvdW5kIGluIGJvdGggYGxpc3QxYCBhbmQgYGxpc3QyYC5cbiAqIEBzZWUgUi5pbm5lckpvaW5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmludGVyc2VjdGlvbihbMSwyLDMsNF0sIFs3LDYsNSw0LDNdKTsgLy89PiBbNCwgM11cbiAqL1xuXG52YXIgaW50ZXJzZWN0aW9uID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gaW50ZXJzZWN0aW9uKGxpc3QxLCBsaXN0Mikge1xuICB2YXIgbG9va3VwTGlzdCwgZmlsdGVyZWRMaXN0O1xuXG4gIGlmIChsaXN0MS5sZW5ndGggPiBsaXN0Mi5sZW5ndGgpIHtcbiAgICBsb29rdXBMaXN0ID0gbGlzdDE7XG4gICAgZmlsdGVyZWRMaXN0ID0gbGlzdDI7XG4gIH0gZWxzZSB7XG4gICAgbG9va3VwTGlzdCA9IGxpc3QyO1xuICAgIGZpbHRlcmVkTGlzdCA9IGxpc3QxO1xuICB9XG5cbiAgcmV0dXJuIHVuaXEoX2ZpbHRlcihmbGlwKF9pbmNsdWRlcykobG9va3VwTGlzdCksIGZpbHRlcmVkTGlzdCkpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGludGVyc2VjdGlvbjsiLCJpbXBvcnQgX2NoZWNrRm9yTWV0aG9kIGZyb20gXCIuL2ludGVybmFsL19jaGVja0Zvck1ldGhvZC5qc1wiO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGxpc3Qgd2l0aCB0aGUgc2VwYXJhdG9yIGludGVycG9zZWQgYmV0d2VlbiBlbGVtZW50cy5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgaW50ZXJzcGVyc2VgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE0LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIGEgLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHsqfSBzZXBhcmF0b3IgVGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBiZSBpbnRlcnBvc2VkLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBuZXcgbGlzdC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmludGVyc3BlcnNlKCdhJywgWydiJywgJ24nLCAnbicsICdzJ10pOyAvLz0+IFsnYicsICdhJywgJ24nLCAnYScsICduJywgJ2EnLCAncyddXG4gKi9cblxudmFyIGludGVyc3BlcnNlID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoXG4vKiNfX1BVUkVfXyovXG5fY2hlY2tGb3JNZXRob2QoJ2ludGVyc3BlcnNlJywgZnVuY3Rpb24gaW50ZXJzcGVyc2Uoc2VwYXJhdG9yLCBsaXN0KSB7XG4gIHZhciBvdXQgPSBbXTtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcblxuICB3aGlsZSAoaWR4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGlkeCA9PT0gbGVuZ3RoIC0gMSkge1xuICAgICAgb3V0LnB1c2gobGlzdFtpZHhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0LnB1c2gobGlzdFtpZHhdLCBzZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIGlkeCArPSAxO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn0pKTtcblxuZXhwb3J0IGRlZmF1bHQgaW50ZXJzcGVyc2U7IiwiaW1wb3J0IF9oYXMgZnJvbSBcIi4vX2hhcy5qc1wiOyAvLyBCYXNlZCBvbiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvYXNzaWduXG5cbmZ1bmN0aW9uIF9vYmplY3RBc3NpZ24odGFyZ2V0KSB7XG4gIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICB9XG5cbiAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuICB2YXIgaWR4ID0gMTtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cbiAgd2hpbGUgKGlkeCA8IGxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaWR4XTtcblxuICAgIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKF9oYXMobmV4dEtleSwgc291cmNlKSkge1xuICAgICAgICAgIG91dHB1dFtuZXh0S2V5XSA9IHNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlkeCArPSAxO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdHlwZW9mIE9iamVjdC5hc3NpZ24gPT09ICdmdW5jdGlvbicgPyBPYmplY3QuYXNzaWduIDogX29iamVjdEFzc2lnbjsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBzaW5nbGUga2V5OnZhbHVlIHBhaXIuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTguMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBTdHJpbmcgLT4gYSAtPiB7U3RyaW5nOmF9XG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0geyp9IHZhbFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHNlZSBSLnBhaXJcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBtYXRjaFBocmFzZXMgPSBSLmNvbXBvc2UoXG4gKiAgICAgICAgUi5vYmpPZignbXVzdCcpLFxuICogICAgICAgIFIubWFwKFIub2JqT2YoJ21hdGNoX3BocmFzZScpKVxuICogICAgICApO1xuICogICAgICBtYXRjaFBocmFzZXMoWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiB7bXVzdDogW3ttYXRjaF9waHJhc2U6ICdmb28nfSwge21hdGNoX3BocmFzZTogJ2Jhcid9LCB7bWF0Y2hfcGhyYXNlOiAnYmF6J31dfVxuICovXG5cbnZhciBvYmpPZiA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIG9iak9mKGtleSwgdmFsKSB7XG4gIHZhciBvYmogPSB7fTtcbiAgb2JqW2tleV0gPSB2YWw7XG4gIHJldHVybiBvYmo7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgb2JqT2Y7IiwiaW1wb3J0IF9vYmplY3RBc3NpZ24gZnJvbSBcIi4vX29iamVjdEFzc2lnbi5qc1wiO1xuaW1wb3J0IF9pZGVudGl0eSBmcm9tIFwiLi9faWRlbnRpdHkuanNcIjtcbmltcG9ydCBfaXNBcnJheUxpa2UgZnJvbSBcIi4vX2lzQXJyYXlMaWtlLmpzXCI7XG5pbXBvcnQgX2lzVHJhbnNmb3JtZXIgZnJvbSBcIi4vX2lzVHJhbnNmb3JtZXIuanNcIjtcbmltcG9ydCBvYmpPZiBmcm9tIFwiLi4vb2JqT2YuanNcIjtcbnZhciBfc3RlcENhdEFycmF5ID0ge1xuICAnQEB0cmFuc2R1Y2VyL2luaXQnOiBBcnJheSxcbiAgJ0BAdHJhbnNkdWNlci9zdGVwJzogZnVuY3Rpb24gKHhzLCB4KSB7XG4gICAgeHMucHVzaCh4KTtcbiAgICByZXR1cm4geHM7XG4gIH0sXG4gICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogX2lkZW50aXR5XG59O1xudmFyIF9zdGVwQ2F0U3RyaW5nID0ge1xuICAnQEB0cmFuc2R1Y2VyL2luaXQnOiBTdHJpbmcsXG4gICdAQHRyYW5zZHVjZXIvc3RlcCc6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgKyBiO1xuICB9LFxuICAnQEB0cmFuc2R1Y2VyL3Jlc3VsdCc6IF9pZGVudGl0eVxufTtcbnZhciBfc3RlcENhdE9iamVjdCA9IHtcbiAgJ0BAdHJhbnNkdWNlci9pbml0JzogT2JqZWN0LFxuICAnQEB0cmFuc2R1Y2VyL3N0ZXAnOiBmdW5jdGlvbiAocmVzdWx0LCBpbnB1dCkge1xuICAgIHJldHVybiBfb2JqZWN0QXNzaWduKHJlc3VsdCwgX2lzQXJyYXlMaWtlKGlucHV0KSA/IG9iak9mKGlucHV0WzBdLCBpbnB1dFsxXSkgOiBpbnB1dCk7XG4gIH0sXG4gICdAQHRyYW5zZHVjZXIvcmVzdWx0JzogX2lkZW50aXR5XG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3N0ZXBDYXQob2JqKSB7XG4gIGlmIChfaXNUcmFuc2Zvcm1lcihvYmopKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGlmIChfaXNBcnJheUxpa2Uob2JqKSkge1xuICAgIHJldHVybiBfc3RlcENhdEFycmF5O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIF9zdGVwQ2F0U3RyaW5nO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIF9zdGVwQ2F0T2JqZWN0O1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIHRyYW5zZm9ybWVyIGZvciAnICsgb2JqKTtcbn0iLCJpbXBvcnQgX2Nsb25lIGZyb20gXCIuL2ludGVybmFsL19jbG9uZS5qc1wiO1xuaW1wb3J0IF9jdXJyeTMgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5My5qc1wiO1xuaW1wb3J0IF9pc1RyYW5zZm9ybWVyIGZyb20gXCIuL2ludGVybmFsL19pc1RyYW5zZm9ybWVyLmpzXCI7XG5pbXBvcnQgX3JlZHVjZSBmcm9tIFwiLi9pbnRlcm5hbC9fcmVkdWNlLmpzXCI7XG5pbXBvcnQgX3N0ZXBDYXQgZnJvbSBcIi4vaW50ZXJuYWwvX3N0ZXBDYXQuanNcIjtcbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgaXRlbXMgb2YgdGhlIGxpc3Qgd2l0aCB0aGUgdHJhbnNkdWNlciBhbmQgYXBwZW5kcyB0aGVcbiAqIHRyYW5zZm9ybWVkIGl0ZW1zIHRvIHRoZSBhY2N1bXVsYXRvciB1c2luZyBhbiBhcHByb3ByaWF0ZSBpdGVyYXRvciBmdW5jdGlvblxuICogYmFzZWQgb24gdGhlIGFjY3VtdWxhdG9yIHR5cGUuXG4gKlxuICogVGhlIGFjY3VtdWxhdG9yIGNhbiBiZSBhbiBhcnJheSwgc3RyaW5nLCBvYmplY3Qgb3IgYSB0cmFuc2Zvcm1lci4gSXRlcmF0ZWRcbiAqIGl0ZW1zIHdpbGwgYmUgYXBwZW5kZWQgdG8gYXJyYXlzIGFuZCBjb25jYXRlbmF0ZWQgdG8gc3RyaW5ncy4gT2JqZWN0cyB3aWxsXG4gKiBiZSBtZXJnZWQgZGlyZWN0bHkgb3IgMi1pdGVtIGFycmF5cyB3aWxsIGJlIG1lcmdlZCBhcyBrZXksIHZhbHVlIHBhaXJzLlxuICpcbiAqIFRoZSBhY2N1bXVsYXRvciBjYW4gYWxzbyBiZSBhIHRyYW5zZm9ybWVyIG9iamVjdCB0aGF0IHByb3ZpZGVzIGEgMi1hcml0eVxuICogcmVkdWNpbmcgaXRlcmF0b3IgZnVuY3Rpb24sIHN0ZXAsIDAtYXJpdHkgaW5pdGlhbCB2YWx1ZSBmdW5jdGlvbiwgaW5pdCwgYW5kXG4gKiAxLWFyaXR5IHJlc3VsdCBleHRyYWN0aW9uIGZ1bmN0aW9uIHJlc3VsdC4gVGhlIHN0ZXAgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGVcbiAqIGl0ZXJhdG9yIGZ1bmN0aW9uIGluIHJlZHVjZS4gVGhlIHJlc3VsdCBmdW5jdGlvbiBpcyB1c2VkIHRvIGNvbnZlcnQgdGhlXG4gKiBmaW5hbCBhY2N1bXVsYXRvciBpbnRvIHRoZSByZXR1cm4gdHlwZSBhbmQgaW4gbW9zdCBjYXNlcyBpcyBSLmlkZW50aXR5LiBUaGVcbiAqIGluaXQgZnVuY3Rpb24gaXMgdXNlZCB0byBwcm92aWRlIHRoZSBpbml0aWFsIGFjY3VtdWxhdG9yLlxuICpcbiAqIFRoZSBpdGVyYXRpb24gaXMgcGVyZm9ybWVkIHdpdGggW2BSLnJlZHVjZWBdKCNyZWR1Y2UpIGFmdGVyIGluaXRpYWxpemluZyB0aGVcbiAqIHRyYW5zZHVjZXIuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTIuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgYSAtPiAoYiAtPiBiKSAtPiBbY10gLT4gYVxuICogQHBhcmFtIHsqfSBhY2MgVGhlIGluaXRpYWwgYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB4ZiBUaGUgdHJhbnNkdWNlciBmdW5jdGlvbi4gUmVjZWl2ZXMgYSB0cmFuc2Zvcm1lciBhbmQgcmV0dXJucyBhIHRyYW5zZm9ybWVyLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJuIHsqfSBUaGUgZmluYWwsIGFjY3VtdWxhdGVkIHZhbHVlLlxuICogQHNlZSBSLnRyYW5zZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IG51bWJlcnMgPSBbMSwgMiwgMywgNF07XG4gKiAgICAgIGNvbnN0IHRyYW5zZHVjZXIgPSBSLmNvbXBvc2UoUi5tYXAoUi5hZGQoMSkpLCBSLnRha2UoMikpO1xuICpcbiAqICAgICAgUi5pbnRvKFtdLCB0cmFuc2R1Y2VyLCBudW1iZXJzKTsgLy89PiBbMiwgM11cbiAqXG4gKiAgICAgIGNvbnN0IGludG9BcnJheSA9IFIuaW50byhbXSk7XG4gKiAgICAgIGludG9BcnJheSh0cmFuc2R1Y2VyLCBudW1iZXJzKTsgLy89PiBbMiwgM11cbiAqL1xuXG52YXIgaW50byA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKGZ1bmN0aW9uIGludG8oYWNjLCB4ZiwgbGlzdCkge1xuICByZXR1cm4gX2lzVHJhbnNmb3JtZXIoYWNjKSA/IF9yZWR1Y2UoeGYoYWNjKSwgYWNjWydAQHRyYW5zZHVjZXIvaW5pdCddKCksIGxpc3QpIDogX3JlZHVjZSh4Zihfc3RlcENhdChhY2MpKSwgX2Nsb25lKGFjYywgW10sIFtdLCBmYWxzZSksIGxpc3QpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGludG87IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5MS5qc1wiO1xuaW1wb3J0IF9oYXMgZnJvbSBcIi4vaW50ZXJuYWwvX2hhcy5qc1wiO1xuaW1wb3J0IGtleXMgZnJvbSBcIi4va2V5cy5qc1wiO1xuLyoqXG4gKiBTYW1lIGFzIFtgUi5pbnZlcnRPYmpgXSgjaW52ZXJ0T2JqKSwgaG93ZXZlciB0aGlzIGFjY291bnRzIGZvciBvYmplY3RzIHdpdGhcbiAqIGR1cGxpY2F0ZSB2YWx1ZXMgYnkgcHV0dGluZyB0aGUgdmFsdWVzIGludG8gYW4gYXJyYXkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtzOiB4fSAtPiB7eDogWyBzLCAuLi4gXX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCBvciBhcnJheSB0byBpbnZlcnRcbiAqIEByZXR1cm4ge09iamVjdH0gb3V0IEEgbmV3IG9iamVjdCB3aXRoIGtleXMgaW4gYW4gYXJyYXkuXG4gKiBAc2VlIFIuaW52ZXJ0T2JqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgcmFjZVJlc3VsdHNCeUZpcnN0TmFtZSA9IHtcbiAqICAgICAgICBmaXJzdDogJ2FsaWNlJyxcbiAqICAgICAgICBzZWNvbmQ6ICdqYWtlJyxcbiAqICAgICAgICB0aGlyZDogJ2FsaWNlJyxcbiAqICAgICAgfTtcbiAqICAgICAgUi5pbnZlcnQocmFjZVJlc3VsdHNCeUZpcnN0TmFtZSk7XG4gKiAgICAgIC8vPT4geyAnYWxpY2UnOiBbJ2ZpcnN0JywgJ3RoaXJkJ10sICdqYWtlJzpbJ3NlY29uZCddIH1cbiAqL1xuXG52YXIgaW52ZXJ0ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoZnVuY3Rpb24gaW52ZXJ0KG9iaikge1xuICB2YXIgcHJvcHMgPSBrZXlzKG9iaik7XG4gIHZhciBsZW4gPSBwcm9wcy5sZW5ndGg7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgb3V0ID0ge307XG5cbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpZHhdO1xuICAgIHZhciB2YWwgPSBvYmpba2V5XTtcbiAgICB2YXIgbGlzdCA9IF9oYXModmFsLCBvdXQpID8gb3V0W3ZhbF0gOiBvdXRbdmFsXSA9IFtdO1xuICAgIGxpc3RbbGlzdC5sZW5ndGhdID0ga2V5O1xuICAgIGlkeCArPSAxO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBpbnZlcnQ7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5MS5qc1wiO1xuaW1wb3J0IGtleXMgZnJvbSBcIi4va2V5cy5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBrZXlzIG9mIHRoZSBnaXZlbiBvYmplY3QgYXMgdmFsdWVzLCBhbmQgdGhlXG4gKiB2YWx1ZXMgb2YgdGhlIGdpdmVuIG9iamVjdCwgd2hpY2ggYXJlIGNvZXJjZWQgdG8gc3RyaW5ncywgYXMga2V5cy4gTm90ZVxuICogdGhhdCB0aGUgbGFzdCBrZXkgZm91bmQgaXMgcHJlZmVycmVkIHdoZW4gaGFuZGxpbmcgdGhlIHNhbWUgdmFsdWUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtzOiB4fSAtPiB7eDogc31cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCBvciBhcnJheSB0byBpbnZlcnRcbiAqIEByZXR1cm4ge09iamVjdH0gb3V0IEEgbmV3IG9iamVjdFxuICogQHNlZSBSLmludmVydFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IHJhY2VSZXN1bHRzID0ge1xuICogICAgICAgIGZpcnN0OiAnYWxpY2UnLFxuICogICAgICAgIHNlY29uZDogJ2pha2UnXG4gKiAgICAgIH07XG4gKiAgICAgIFIuaW52ZXJ0T2JqKHJhY2VSZXN1bHRzKTtcbiAqICAgICAgLy89PiB7ICdhbGljZSc6ICdmaXJzdCcsICdqYWtlJzonc2Vjb25kJyB9XG4gKlxuICogICAgICAvLyBBbHRlcm5hdGl2ZWx5OlxuICogICAgICBjb25zdCByYWNlUmVzdWx0cyA9IFsnYWxpY2UnLCAnamFrZSddO1xuICogICAgICBSLmludmVydE9iaihyYWNlUmVzdWx0cyk7XG4gKiAgICAgIC8vPT4geyAnYWxpY2UnOiAnMCcsICdqYWtlJzonMScgfVxuICovXG5cbnZhciBpbnZlcnRPYmogPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiBpbnZlcnRPYmoob2JqKSB7XG4gIHZhciBwcm9wcyA9IGtleXMob2JqKTtcbiAgdmFyIGxlbiA9IHByb3BzLmxlbmd0aDtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBvdXQgPSB7fTtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2lkeF07XG4gICAgb3V0W29ialtrZXldXSA9IGtleTtcbiAgICBpZHggKz0gMTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgaW52ZXJ0T2JqOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbmltcG9ydCBfaXNGdW5jdGlvbiBmcm9tIFwiLi9pbnRlcm5hbC9faXNGdW5jdGlvbi5qc1wiO1xuaW1wb3J0IGN1cnJ5TiBmcm9tIFwiLi9jdXJyeU4uanNcIjtcbmltcG9ydCB0b1N0cmluZyBmcm9tIFwiLi90b1N0cmluZy5qc1wiO1xuLyoqXG4gKiBUdXJucyBhIG5hbWVkIG1ldGhvZCB3aXRoIGEgc3BlY2lmaWVkIGFyaXR5IGludG8gYSBmdW5jdGlvbiB0aGF0IGNhbiBiZVxuICogY2FsbGVkIGRpcmVjdGx5IHN1cHBsaWVkIHdpdGggYXJndW1lbnRzIGFuZCBhIHRhcmdldCBvYmplY3QuXG4gKlxuICogVGhlIHJldHVybmVkIGZ1bmN0aW9uIGlzIGN1cnJpZWQgYW5kIGFjY2VwdHMgYGFyaXR5ICsgMWAgcGFyYW1ldGVycyB3aGVyZVxuICogdGhlIGZpbmFsIHBhcmFtZXRlciBpcyB0aGUgdGFyZ2V0IG9iamVjdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBOdW1iZXIgLT4gU3RyaW5nIC0+IChhIC0+IGIgLT4gLi4uIC0+IG4gLT4gT2JqZWN0IC0+ICopXG4gKiBAcGFyYW0ge051bWJlcn0gYXJpdHkgTnVtYmVyIG9mIGFyZ3VtZW50cyB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gc2hvdWxkIHRha2VcbiAqICAgICAgICBiZWZvcmUgdGhlIHRhcmdldCBvYmplY3QuXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIE5hbWUgb2YgYW55IG9mIHRoZSB0YXJnZXQgb2JqZWN0J3MgbWV0aG9kcyB0byBjYWxsLlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gKiBAc2VlIFIuY29uc3RydWN0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3Qgc2xpY2VGcm9tID0gUi5pbnZva2VyKDEsICdzbGljZScpO1xuICogICAgICBzbGljZUZyb20oNiwgJ2FiY2RlZmdoaWprbG0nKTsgLy89PiAnZ2hpamtsbSdcbiAqICAgICAgY29uc3Qgc2xpY2VGcm9tNiA9IFIuaW52b2tlcigyLCAnc2xpY2UnKSg2KTtcbiAqICAgICAgc2xpY2VGcm9tNig4LCAnYWJjZGVmZ2hpamtsbScpOyAvLz0+ICdnaCdcbiAqXG4gKiAgICAgIGNvbnN0IGRvZyA9IHtcbiAqICAgICAgICBzcGVhazogYXN5bmMgKCkgPT4gJ1dvb2YhJ1xuICogICAgICB9O1xuICogICAgICBjb25zdCBzcGVhayA9IFIuaW52b2tlcigwLCAnc3BlYWsnKTtcbiAqICAgICAgc3BlYWsoZG9nKS50aGVuKGNvbnNvbGUubG9nKSAvL34+ICdXb29mISdcbiAqXG4gKiBAc3ltYiBSLmludm9rZXIoMCwgJ21ldGhvZCcpKG8pID0gb1snbWV0aG9kJ10oKVxuICogQHN5bWIgUi5pbnZva2VyKDEsICdtZXRob2QnKShhLCBvKSA9IG9bJ21ldGhvZCddKGEpXG4gKiBAc3ltYiBSLmludm9rZXIoMiwgJ21ldGhvZCcpKGEsIGIsIG8pID0gb1snbWV0aG9kJ10oYSwgYilcbiAqL1xuXG52YXIgaW52b2tlciA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIGludm9rZXIoYXJpdHksIG1ldGhvZCkge1xuICByZXR1cm4gY3VycnlOKGFyaXR5ICsgMSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB0YXJnZXQgPSBhcmd1bWVudHNbYXJpdHldO1xuXG4gICAgaWYgKHRhcmdldCAhPSBudWxsICYmIF9pc0Z1bmN0aW9uKHRhcmdldFttZXRob2RdKSkge1xuICAgICAgcmV0dXJuIHRhcmdldFttZXRob2RdLmFwcGx5KHRhcmdldCwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwLCBhcml0eSkpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IodG9TdHJpbmcodGFyZ2V0KSArICcgZG9lcyBub3QgaGF2ZSBhIG1ldGhvZCBuYW1lZCBcIicgKyBtZXRob2QgKyAnXCInKTtcbiAgfSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgaW52b2tlcjsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG4vKipcbiAqIFNlZSBpZiBhbiBvYmplY3QgKGB2YWxgKSBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgc3VwcGxpZWQgY29uc3RydWN0b3IuIFRoaXNcbiAqIGZ1bmN0aW9uIHdpbGwgY2hlY2sgdXAgdGhlIGluaGVyaXRhbmNlIGNoYWluLCBpZiBhbnkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMy4wXG4gKiBAY2F0ZWdvcnkgVHlwZVxuICogQHNpZyAoKiAtPiB7Kn0pIC0+IGEgLT4gQm9vbGVhblxuICogQHBhcmFtIHtPYmplY3R9IGN0b3IgQSBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5pcyhPYmplY3QsIHt9KTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaXMoTnVtYmVyLCAxKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaXMoT2JqZWN0LCAxKTsgLy89PiBmYWxzZVxuICogICAgICBSLmlzKFN0cmluZywgJ3MnKTsgLy89PiB0cnVlXG4gKiAgICAgIFIuaXMoU3RyaW5nLCBuZXcgU3RyaW5nKCcnKSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmlzKE9iamVjdCwgbmV3IFN0cmluZygnJykpOyAvLz0+IHRydWVcbiAqICAgICAgUi5pcyhPYmplY3QsICdzJyk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5pcyhOdW1iZXIsIHt9KTsgLy89PiBmYWxzZVxuICovXG5cbnZhciBpcyA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIGlzKEN0b3IsIHZhbCkge1xuICByZXR1cm4gdmFsICE9IG51bGwgJiYgdmFsLmNvbnN0cnVjdG9yID09PSBDdG9yIHx8IHZhbCBpbnN0YW5jZW9mIEN0b3I7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgaXM7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5MS5qc1wiO1xuaW1wb3J0IGVtcHR5IGZyb20gXCIuL2VtcHR5LmpzXCI7XG5pbXBvcnQgZXF1YWxzIGZyb20gXCIuL2VxdWFscy5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgaXRzIHR5cGUncyBlbXB0eSB2YWx1ZTsgYGZhbHNlYFxuICogb3RoZXJ3aXNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIGEgLT4gQm9vbGVhblxuICogQHBhcmFtIHsqfSB4XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLmVtcHR5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5pc0VtcHR5KFsxLCAyLCAzXSk7ICAgLy89PiBmYWxzZVxuICogICAgICBSLmlzRW1wdHkoW10pOyAgICAgICAgICAvLz0+IHRydWVcbiAqICAgICAgUi5pc0VtcHR5KCcnKTsgICAgICAgICAgLy89PiB0cnVlXG4gKiAgICAgIFIuaXNFbXB0eShudWxsKTsgICAgICAgIC8vPT4gZmFsc2VcbiAqICAgICAgUi5pc0VtcHR5KHt9KTsgICAgICAgICAgLy89PiB0cnVlXG4gKiAgICAgIFIuaXNFbXB0eSh7bGVuZ3RoOiAwfSk7IC8vPT4gZmFsc2VcbiAqL1xuXG52YXIgaXNFbXB0eSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKGZ1bmN0aW9uIGlzRW1wdHkoeCkge1xuICByZXR1cm4geCAhPSBudWxsICYmIGVxdWFscyh4LCBlbXB0eSh4KSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgaXNFbXB0eTsiLCJpbXBvcnQgaW52b2tlciBmcm9tIFwiLi9pbnZva2VyLmpzXCI7XG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgbWFkZSBieSBpbnNlcnRpbmcgdGhlIGBzZXBhcmF0b3JgIGJldHdlZW4gZWFjaCBlbGVtZW50IGFuZFxuICogY29uY2F0ZW5hdGluZyBhbGwgdGhlIGVsZW1lbnRzIGludG8gYSBzaW5nbGUgc3RyaW5nLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgU3RyaW5nIC0+IFthXSAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gc2VwYXJhdG9yIFRoZSBzdHJpbmcgdXNlZCB0byBzZXBhcmF0ZSB0aGUgZWxlbWVudHMuXG4gKiBAcGFyYW0ge0FycmF5fSB4cyBUaGUgZWxlbWVudHMgdG8gam9pbiBpbnRvIGEgc3RyaW5nLlxuICogQHJldHVybiB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyBtYWRlIGJ5IGNvbmNhdGVuYXRpbmcgYHhzYCB3aXRoIGBzZXBhcmF0b3JgLlxuICogQHNlZSBSLnNwbGl0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3Qgc3BhY2VyID0gUi5qb2luKCcgJyk7XG4gKiAgICAgIHNwYWNlcihbJ2EnLCAyLCAzLjRdKTsgICAvLz0+ICdhIDIgMy40J1xuICogICAgICBSLmpvaW4oJ3wnLCBbMSwgMiwgM10pOyAgICAvLz0+ICcxfDJ8MydcbiAqL1xuXG52YXIgam9pbiA9XG4vKiNfX1BVUkVfXyovXG5pbnZva2VyKDEsICdqb2luJyk7XG5leHBvcnQgZGVmYXVsdCBqb2luOyIsImltcG9ydCBfY3VycnkxIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTEuanNcIjtcbmltcG9ydCBjb252ZXJnZSBmcm9tIFwiLi9jb252ZXJnZS5qc1wiO1xuLyoqXG4gKiBqdXh0IGFwcGxpZXMgYSBsaXN0IG9mIGZ1bmN0aW9ucyB0byBhIGxpc3Qgb2YgdmFsdWVzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBbKGEsIGIsIC4uLiwgbSkgLT4gbl0gLT4gKChhLCBiLCAuLi4sIG0pIC0+IFtuXSlcbiAqIEBwYXJhbSB7QXJyYXl9IGZucyBBbiBhcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGxpc3Qgb2YgdmFsdWVzIGFmdGVyIGFwcGx5aW5nIGVhY2ggb2YgdGhlIG9yaWdpbmFsIGBmbnNgIHRvIGl0cyBwYXJhbWV0ZXJzLlxuICogQHNlZSBSLmFwcGx5U3BlY1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGdldFJhbmdlID0gUi5qdXh0KFtNYXRoLm1pbiwgTWF0aC5tYXhdKTtcbiAqICAgICAgZ2V0UmFuZ2UoMywgNCwgOSwgLTMpOyAvLz0+IFstMywgOV1cbiAqIEBzeW1iIFIuanV4dChbZiwgZywgaF0pKGEsIGIpID0gW2YoYSwgYiksIGcoYSwgYiksIGgoYSwgYildXG4gKi9cblxudmFyIGp1eHQgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiBqdXh0KGZucykge1xuICByZXR1cm4gY29udmVyZ2UoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICB9LCBmbnMpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGp1eHQ7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5MS5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBjb250YWluaW5nIHRoZSBuYW1lcyBvZiBhbGwgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHN1cHBsaWVkXG4gKiBvYmplY3QsIGluY2x1ZGluZyBwcm90b3R5cGUgcHJvcGVydGllcy5cbiAqIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIG91dHB1dCBhcnJheSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBjb25zaXN0ZW50XG4gKiBhY3Jvc3MgZGlmZmVyZW50IEpTIHBsYXRmb3Jtcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcge2s6IHZ9IC0+IFtrXVxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGV4dHJhY3QgcHJvcGVydGllcyBmcm9tXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgdGhlIG9iamVjdCdzIG93biBhbmQgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKiBAc2VlIFIua2V5cywgUi52YWx1ZXNJblxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IEYgPSBmdW5jdGlvbigpIHsgdGhpcy54ID0gJ1gnOyB9O1xuICogICAgICBGLnByb3RvdHlwZS55ID0gJ1knO1xuICogICAgICBjb25zdCBmID0gbmV3IEYoKTtcbiAqICAgICAgUi5rZXlzSW4oZik7IC8vPT4gWyd4JywgJ3knXVxuICovXG5cbnZhciBrZXlzSW4gPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiBrZXlzSW4ob2JqKSB7XG4gIHZhciBwcm9wO1xuICB2YXIga3MgPSBbXTtcblxuICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAga3Nba3MubGVuZ3RoXSA9IHByb3A7XG4gIH1cblxuICByZXR1cm4ga3M7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQga2V5c0luOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbmltcG9ydCBfaXNBcnJheSBmcm9tIFwiLi9pbnRlcm5hbC9faXNBcnJheS5qc1wiO1xuaW1wb3J0IGVxdWFscyBmcm9tIFwiLi9lcXVhbHMuanNcIjtcbi8qKlxuICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LCBvciAtMSBpZlxuICogdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS4gW2BSLmVxdWFsc2BdKCNlcXVhbHMpIGlzIHVzZWQgdG9cbiAqIGRldGVybWluZSBlcXVhbGl0eS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIGEgLT4gW2FdIC0+IE51bWJlclxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIGl0ZW0gdG8gZmluZC5cbiAqIEBwYXJhbSB7QXJyYXl9IHhzIFRoZSBhcnJheSB0byBzZWFyY2ggaW4uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgdGFyZ2V0LCBvciAtMSBpZiB0aGUgdGFyZ2V0IGlzIG5vdCBmb3VuZC5cbiAqIEBzZWUgUi5pbmRleE9mXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5sYXN0SW5kZXhPZigzLCBbLTEsMywzLDAsMSwyLDMsNF0pOyAvLz0+IDZcbiAqICAgICAgUi5sYXN0SW5kZXhPZigxMCwgWzEsMiwzLDRdKTsgLy89PiAtMVxuICovXG5cbnZhciBsYXN0SW5kZXhPZiA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIGxhc3RJbmRleE9mKHRhcmdldCwgeHMpIHtcbiAgaWYgKHR5cGVvZiB4cy5sYXN0SW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJyAmJiAhX2lzQXJyYXkoeHMpKSB7XG4gICAgcmV0dXJuIHhzLmxhc3RJbmRleE9mKHRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlkeCA9IHhzLmxlbmd0aCAtIDE7XG5cbiAgICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICAgIGlmIChlcXVhbHMoeHNbaWR4XSwgdGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gaWR4O1xuICAgICAgfVxuXG4gICAgICBpZHggLT0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBsYXN0SW5kZXhPZjsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXNOdW1iZXIoeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBOdW1iZXJdJztcbn0iLCJpbXBvcnQgX2N1cnJ5MSBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkxLmpzXCI7XG5pbXBvcnQgX2lzTnVtYmVyIGZyb20gXCIuL2ludGVybmFsL19pc051bWJlci5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5IGJ5IHJldHVybmluZyBgbGlzdC5sZW5ndGhgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjMuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IE51bWJlclxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5sZW5ndGgoW10pOyAvLz0+IDBcbiAqICAgICAgUi5sZW5ndGgoWzEsIDIsIDNdKTsgLy89PiAzXG4gKi9cblxudmFyIGxlbmd0aCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKGZ1bmN0aW9uIGxlbmd0aChsaXN0KSB7XG4gIHJldHVybiBsaXN0ICE9IG51bGwgJiYgX2lzTnVtYmVyKGxpc3QubGVuZ3RoKSA/IGxpc3QubGVuZ3RoIDogTmFOO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGxlbmd0aDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgbWFwIGZyb20gXCIuL21hcC5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGEgbGVucyBmb3IgdGhlIGdpdmVuIGdldHRlciBhbmQgc2V0dGVyIGZ1bmN0aW9ucy4gVGhlIGdldHRlciBcImdldHNcIlxuICogdGhlIHZhbHVlIG9mIHRoZSBmb2N1czsgdGhlIHNldHRlciBcInNldHNcIiB0aGUgdmFsdWUgb2YgdGhlIGZvY3VzLiBUaGUgc2V0dGVyXG4gKiBzaG91bGQgbm90IG11dGF0ZSB0aGUgZGF0YSBzdHJ1Y3R1cmUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gTGVucyBzIGEgPSBGdW5jdG9yIGYgPT4gKGEgLT4gZiBhKSAtPiBzIC0+IGYgc1xuICogQHNpZyAocyAtPiBhKSAtPiAoKGEsIHMpIC0+IHMpIC0+IExlbnMgcyBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXR0ZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlclxuICogQHJldHVybiB7TGVuc31cbiAqIEBzZWUgUi52aWV3LCBSLnNldCwgUi5vdmVyLCBSLmxlbnNJbmRleCwgUi5sZW5zUHJvcFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IHhMZW5zID0gUi5sZW5zKFIucHJvcCgneCcpLCBSLmFzc29jKCd4JykpO1xuICpcbiAqICAgICAgUi52aWV3KHhMZW5zLCB7eDogMSwgeTogMn0pOyAgICAgICAgICAgIC8vPT4gMVxuICogICAgICBSLnNldCh4TGVucywgNCwge3g6IDEsIHk6IDJ9KTsgICAgICAgICAgLy89PiB7eDogNCwgeTogMn1cbiAqICAgICAgUi5vdmVyKHhMZW5zLCBSLm5lZ2F0ZSwge3g6IDEsIHk6IDJ9KTsgIC8vPT4ge3g6IC0xLCB5OiAyfVxuICovXG5cbnZhciBsZW5zID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gbGVucyhnZXR0ZXIsIHNldHRlcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHRvRnVuY3RvckZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBtYXAoZnVuY3Rpb24gKGZvY3VzKSB7XG4gICAgICAgIHJldHVybiBzZXR0ZXIoZm9jdXMsIHRhcmdldCk7XG4gICAgICB9LCB0b0Z1bmN0b3JGbihnZXR0ZXIodGFyZ2V0KSkpO1xuICAgIH07XG4gIH07XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbGVuczsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkxLmpzXCI7XG5pbXBvcnQgbGVucyBmcm9tIFwiLi9sZW5zLmpzXCI7XG5pbXBvcnQgbnRoIGZyb20gXCIuL250aC5qc1wiO1xuaW1wb3J0IHVwZGF0ZSBmcm9tIFwiLi91cGRhdGUuanNcIjtcbi8qKlxuICogUmV0dXJucyBhIGxlbnMgd2hvc2UgZm9jdXMgaXMgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gTGVucyBzIGEgPSBGdW5jdG9yIGYgPT4gKGEgLT4gZiBhKSAtPiBzIC0+IGYgc1xuICogQHNpZyBOdW1iZXIgLT4gTGVucyBzIGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcmV0dXJuIHtMZW5zfVxuICogQHNlZSBSLnZpZXcsIFIuc2V0LCBSLm92ZXIsIFIubnRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgaGVhZExlbnMgPSBSLmxlbnNJbmRleCgwKTtcbiAqXG4gKiAgICAgIFIudmlldyhoZWFkTGVucywgWydhJywgJ2InLCAnYyddKTsgICAgICAgICAgICAvLz0+ICdhJ1xuICogICAgICBSLnNldChoZWFkTGVucywgJ3gnLCBbJ2EnLCAnYicsICdjJ10pOyAgICAgICAgLy89PiBbJ3gnLCAnYicsICdjJ11cbiAqICAgICAgUi5vdmVyKGhlYWRMZW5zLCBSLnRvVXBwZXIsIFsnYScsICdiJywgJ2MnXSk7IC8vPT4gWydBJywgJ2InLCAnYyddXG4gKi9cblxudmFyIGxlbnNJbmRleCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKGZ1bmN0aW9uIGxlbnNJbmRleChuKSB7XG4gIHJldHVybiBsZW5zKG50aChuKSwgdXBkYXRlKG4pKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBsZW5zSW5kZXg7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5MS5qc1wiO1xuaW1wb3J0IGFzc29jUGF0aCBmcm9tIFwiLi9hc3NvY1BhdGguanNcIjtcbmltcG9ydCBsZW5zIGZyb20gXCIuL2xlbnMuanNcIjtcbmltcG9ydCBwYXRoIGZyb20gXCIuL3BhdGguanNcIjtcbi8qKlxuICogUmV0dXJucyBhIGxlbnMgd2hvc2UgZm9jdXMgaXMgdGhlIHNwZWNpZmllZCBwYXRoLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEB0eXBlZGVmbiBJZHggPSBTdHJpbmcgfCBJbnRcbiAqIEB0eXBlZGVmbiBMZW5zIHMgYSA9IEZ1bmN0b3IgZiA9PiAoYSAtPiBmIGEpIC0+IHMgLT4gZiBzXG4gKiBAc2lnIFtJZHhdIC0+IExlbnMgcyBhXG4gKiBAcGFyYW0ge0FycmF5fSBwYXRoIFRoZSBwYXRoIHRvIHVzZS5cbiAqIEByZXR1cm4ge0xlbnN9XG4gKiBAc2VlIFIudmlldywgUi5zZXQsIFIub3ZlclxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IHhIZWFkWUxlbnMgPSBSLmxlbnNQYXRoKFsneCcsIDAsICd5J10pO1xuICpcbiAqICAgICAgUi52aWV3KHhIZWFkWUxlbnMsIHt4OiBbe3k6IDIsIHo6IDN9LCB7eTogNCwgejogNX1dfSk7XG4gKiAgICAgIC8vPT4gMlxuICogICAgICBSLnNldCh4SGVhZFlMZW5zLCAxLCB7eDogW3t5OiAyLCB6OiAzfSwge3k6IDQsIHo6IDV9XX0pO1xuICogICAgICAvLz0+IHt4OiBbe3k6IDEsIHo6IDN9LCB7eTogNCwgejogNX1dfVxuICogICAgICBSLm92ZXIoeEhlYWRZTGVucywgUi5uZWdhdGUsIHt4OiBbe3k6IDIsIHo6IDN9LCB7eTogNCwgejogNX1dfSk7XG4gKiAgICAgIC8vPT4ge3g6IFt7eTogLTIsIHo6IDN9LCB7eTogNCwgejogNX1dfVxuICovXG5cbnZhciBsZW5zUGF0aCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKGZ1bmN0aW9uIGxlbnNQYXRoKHApIHtcbiAgcmV0dXJuIGxlbnMocGF0aChwKSwgYXNzb2NQYXRoKHApKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBsZW5zUGF0aDsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkxLmpzXCI7XG5pbXBvcnQgYXNzb2MgZnJvbSBcIi4vYXNzb2MuanNcIjtcbmltcG9ydCBsZW5zIGZyb20gXCIuL2xlbnMuanNcIjtcbmltcG9ydCBwcm9wIGZyb20gXCIuL3Byb3AuanNcIjtcbi8qKlxuICogUmV0dXJucyBhIGxlbnMgd2hvc2UgZm9jdXMgaXMgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAdHlwZWRlZm4gTGVucyBzIGEgPSBGdW5jdG9yIGYgPT4gKGEgLT4gZiBhKSAtPiBzIC0+IGYgc1xuICogQHNpZyBTdHJpbmcgLT4gTGVucyBzIGFcbiAqIEBwYXJhbSB7U3RyaW5nfSBrXG4gKiBAcmV0dXJuIHtMZW5zfVxuICogQHNlZSBSLnZpZXcsIFIuc2V0LCBSLm92ZXJcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCB4TGVucyA9IFIubGVuc1Byb3AoJ3gnKTtcbiAqXG4gKiAgICAgIFIudmlldyh4TGVucywge3g6IDEsIHk6IDJ9KTsgICAgICAgICAgICAvLz0+IDFcbiAqICAgICAgUi5zZXQoeExlbnMsIDQsIHt4OiAxLCB5OiAyfSk7ICAgICAgICAgIC8vPT4ge3g6IDQsIHk6IDJ9XG4gKiAgICAgIFIub3Zlcih4TGVucywgUi5uZWdhdGUsIHt4OiAxLCB5OiAyfSk7ICAvLz0+IHt4OiAtMSwgeTogMn1cbiAqL1xuXG52YXIgbGVuc1Byb3AgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiBsZW5zUHJvcChrKSB7XG4gIHJldHVybiBsZW5zKHByb3AoayksIGFzc29jKGspKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBsZW5zUHJvcDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBsZXNzIHRoYW4gdGhlIHNlY29uZDsgYGZhbHNlYFxuICogb3RoZXJ3aXNlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnIE9yZCBhID0+IGEgLT4gYSAtPiBCb29sZWFuXG4gKiBAcGFyYW0geyp9IGFcbiAqIEBwYXJhbSB7Kn0gYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5ndFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubHQoMiwgMSk7IC8vPT4gZmFsc2VcbiAqICAgICAgUi5sdCgyLCAyKTsgLy89PiBmYWxzZVxuICogICAgICBSLmx0KDIsIDMpOyAvLz0+IHRydWVcbiAqICAgICAgUi5sdCgnYScsICd6Jyk7IC8vPT4gdHJ1ZVxuICogICAgICBSLmx0KCd6JywgJ2EnKTsgLy89PiBmYWxzZVxuICovXG5cbnZhciBsdCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIGx0KGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGx0OyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgc2Vjb25kO1xuICogYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgT3JkIGEgPT4gYSAtPiBhIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7TnVtYmVyfSBhXG4gKiBAcGFyYW0ge051bWJlcn0gYlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5ndGVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLmx0ZSgyLCAxKTsgLy89PiBmYWxzZVxuICogICAgICBSLmx0ZSgyLCAyKTsgLy89PiB0cnVlXG4gKiAgICAgIFIubHRlKDIsIDMpOyAvLz0+IHRydWVcbiAqICAgICAgUi5sdGUoJ2EnLCAneicpOyAvLz0+IHRydWVcbiAqICAgICAgUi5sdGUoJ3onLCAnYScpOyAvLz0+IGZhbHNlXG4gKi9cblxudmFyIGx0ZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIGx0ZShhLCBiKSB7XG4gIHJldHVybiBhIDw9IGI7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbHRlOyIsImltcG9ydCBfY3VycnkzIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTMuanNcIjtcbi8qKlxuICogVGhlIGBtYXBBY2N1bWAgZnVuY3Rpb24gYmVoYXZlcyBsaWtlIGEgY29tYmluYXRpb24gb2YgbWFwIGFuZCByZWR1Y2U7IGl0XG4gKiBhcHBsaWVzIGEgZnVuY3Rpb24gdG8gZWFjaCBlbGVtZW50IG9mIGEgbGlzdCwgcGFzc2luZyBhbiBhY2N1bXVsYXRpbmdcbiAqIHBhcmFtZXRlciBmcm9tIGxlZnQgdG8gcmlnaHQsIGFuZCByZXR1cm5pbmcgYSBmaW5hbCB2YWx1ZSBvZiB0aGlzXG4gKiBhY2N1bXVsYXRvciB0b2dldGhlciB3aXRoIHRoZSBuZXcgbGlzdC5cbiAqXG4gKiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIGFyZ3VtZW50cywgKmFjYyogYW5kICp2YWx1ZSosIGFuZCBzaG91bGRcbiAqIHJldHVybiBhIHR1cGxlICpbYWNjLCB2YWx1ZV0qLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoYWNjLCB4KSAtPiAoYWNjLCB5KSkgLT4gYWNjIC0+IFt4XSAtPiAoYWNjLCBbeV0pXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhlIGlucHV0IGBsaXN0YC5cbiAqIEBwYXJhbSB7Kn0gYWNjIFRoZSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7Kn0gVGhlIGZpbmFsLCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgUi5zY2FuLCBSLmFkZEluZGV4LCBSLm1hcEFjY3VtUmlnaHRcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBkaWdpdHMgPSBbJzEnLCAnMicsICczJywgJzQnXTtcbiAqICAgICAgY29uc3QgYXBwZW5kZXIgPSAoYSwgYikgPT4gW2EgKyBiLCBhICsgYl07XG4gKlxuICogICAgICBSLm1hcEFjY3VtKGFwcGVuZGVyLCAwLCBkaWdpdHMpOyAvLz0+IFsnMDEyMzQnLCBbJzAxJywgJzAxMicsICcwMTIzJywgJzAxMjM0J11dXG4gKiBAc3ltYiBSLm1hcEFjY3VtKGYsIGEsIFtiLCBjLCBkXSkgPSBbXG4gKiAgIGYoZihmKGEsIGIpWzBdLCBjKVswXSwgZClbMF0sXG4gKiAgIFtcbiAqICAgICBmKGEsIGIpWzFdLFxuICogICAgIGYoZihhLCBiKVswXSwgYylbMV0sXG4gKiAgICAgZihmKGYoYSwgYilbMF0sIGMpWzBdLCBkKVsxXVxuICogICBdXG4gKiBdXG4gKi9cblxudmFyIG1hcEFjY3VtID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTMoZnVuY3Rpb24gbWFwQWNjdW0oZm4sIGFjYywgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciB0dXBsZSA9IFthY2NdO1xuXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICB0dXBsZSA9IGZuKHR1cGxlWzBdLCBsaXN0W2lkeF0pO1xuICAgIHJlc3VsdFtpZHhdID0gdHVwbGVbMV07XG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gW3R1cGxlWzBdLCByZXN1bHRdO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IG1hcEFjY3VtOyIsImltcG9ydCBfY3VycnkzIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTMuanNcIjtcbi8qKlxuICogVGhlIGBtYXBBY2N1bVJpZ2h0YCBmdW5jdGlvbiBiZWhhdmVzIGxpa2UgYSBjb21iaW5hdGlvbiBvZiBtYXAgYW5kIHJlZHVjZTsgaXRcbiAqIGFwcGxpZXMgYSBmdW5jdGlvbiB0byBlYWNoIGVsZW1lbnQgb2YgYSBsaXN0LCBwYXNzaW5nIGFuIGFjY3VtdWxhdGluZ1xuICogcGFyYW1ldGVyIGZyb20gcmlnaHQgdG8gbGVmdCwgYW5kIHJldHVybmluZyBhIGZpbmFsIHZhbHVlIG9mIHRoaXNcbiAqIGFjY3VtdWxhdG9yIHRvZ2V0aGVyIHdpdGggdGhlIG5ldyBsaXN0LlxuICpcbiAqIFNpbWlsYXIgdG8gW2BtYXBBY2N1bWBdKCNtYXBBY2N1bSksIGV4Y2VwdCBtb3ZlcyB0aHJvdWdoIHRoZSBpbnB1dCBsaXN0IGZyb21cbiAqIHRoZSByaWdodCB0byB0aGUgbGVmdC5cbiAqXG4gKiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIGFyZ3VtZW50cywgKmFjYyogYW5kICp2YWx1ZSosIGFuZCBzaG91bGRcbiAqIHJldHVybiBhIHR1cGxlICpbYWNjLCB2YWx1ZV0qLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoYWNjLCB4KSAtPiAoYWNjLCB5KSkgLT4gYWNjIC0+IFt4XSAtPiAoYWNjLCBbeV0pXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhlIGlucHV0IGBsaXN0YC5cbiAqIEBwYXJhbSB7Kn0gYWNjIFRoZSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7Kn0gVGhlIGZpbmFsLCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgUi5hZGRJbmRleCwgUi5tYXBBY2N1bVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGRpZ2l0cyA9IFsnMScsICcyJywgJzMnLCAnNCddO1xuICogICAgICBjb25zdCBhcHBlbmRlciA9IChhLCBiKSA9PiBbYiArIGEsIGIgKyBhXTtcbiAqXG4gKiAgICAgIFIubWFwQWNjdW1SaWdodChhcHBlbmRlciwgNSwgZGlnaXRzKTsgLy89PiBbJzEyMzQ1JywgWycxMjM0NScsICcyMzQ1JywgJzM0NScsICc0NSddXVxuICogQHN5bWIgUi5tYXBBY2N1bVJpZ2h0KGYsIGEsIFtiLCBjLCBkXSkgPSBbXG4gKiAgIGYoZihmKGEsIGQpWzBdLCBjKVswXSwgYilbMF0sXG4gKiAgIFtcbiAqICAgICBmKGEsIGQpWzFdLFxuICogICAgIGYoZihhLCBkKVswXSwgYylbMV0sXG4gKiAgICAgZihmKGYoYSwgZClbMF0sIGMpWzBdLCBiKVsxXVxuICogICBdXG4gKiBdXG4gKi9cblxudmFyIG1hcEFjY3VtUmlnaHQgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MyhmdW5jdGlvbiBtYXBBY2N1bVJpZ2h0KGZuLCBhY2MsIGxpc3QpIHtcbiAgdmFyIGlkeCA9IGxpc3QubGVuZ3RoIC0gMTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgdHVwbGUgPSBbYWNjXTtcblxuICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICB0dXBsZSA9IGZuKHR1cGxlWzBdLCBsaXN0W2lkeF0pO1xuICAgIHJlc3VsdFtpZHhdID0gdHVwbGVbMV07XG4gICAgaWR4IC09IDE7XG4gIH1cblxuICByZXR1cm4gW3R1cGxlWzBdLCByZXN1bHRdO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IG1hcEFjY3VtUmlnaHQ7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9yZWR1Y2UgZnJvbSBcIi4vaW50ZXJuYWwvX3JlZHVjZS5qc1wiO1xuaW1wb3J0IGtleXMgZnJvbSBcIi4va2V5cy5qc1wiO1xuLyoqXG4gKiBBbiBPYmplY3Qtc3BlY2lmaWMgdmVyc2lvbiBvZiBbYG1hcGBdKCNtYXApLiBUaGUgZnVuY3Rpb24gaXMgYXBwbGllZCB0byB0aHJlZVxuICogYXJndW1lbnRzOiAqKHZhbHVlLCBrZXksIG9iaikqLiBJZiBvbmx5IHRoZSB2YWx1ZSBpcyBzaWduaWZpY2FudCwgdXNlXG4gKiBbYG1hcGBdKCNtYXApIGluc3RlYWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnICgoKiwgU3RyaW5nLCBPYmplY3QpIC0+ICopIC0+IE9iamVjdCAtPiBPYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAc2VlIFIubWFwXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgeHl6ID0geyB4OiAxLCB5OiAyLCB6OiAzIH07XG4gKiAgICAgIGNvbnN0IHByZXBlbmRLZXlBbmREb3VibGUgPSAobnVtLCBrZXksIG9iaikgPT4ga2V5ICsgKG51bSAqIDIpO1xuICpcbiAqICAgICAgUi5tYXBPYmpJbmRleGVkKHByZXBlbmRLZXlBbmREb3VibGUsIHh5eik7IC8vPT4geyB4OiAneDInLCB5OiAneTQnLCB6OiAnejYnIH1cbiAqL1xuXG52YXIgbWFwT2JqSW5kZXhlZCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIG1hcE9iakluZGV4ZWQoZm4sIG9iaikge1xuICByZXR1cm4gX3JlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICBhY2Nba2V5XSA9IGZuKG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30sIGtleXMob2JqKSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbWFwT2JqSW5kZXhlZDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG4vKipcbiAqIFRlc3RzIGEgcmVndWxhciBleHByZXNzaW9uIGFnYWluc3QgYSBTdHJpbmcuIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGxcbiAqIHJldHVybiBhbiBlbXB0eSBhcnJheSB3aGVuIHRoZXJlIGFyZSBubyBtYXRjaGVzLiBUaGlzIGRpZmZlcnMgZnJvbVxuICogW2BTdHJpbmcucHJvdG90eXBlLm1hdGNoYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL21hdGNoKVxuICogd2hpY2ggcmV0dXJucyBgbnVsbGAgd2hlbiB0aGVyZSBhcmUgbm8gbWF0Y2hlcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBzaWcgUmVnRXhwIC0+IFN0cmluZyAtPiBbU3RyaW5nIHwgVW5kZWZpbmVkXVxuICogQHBhcmFtIHtSZWdFeHB9IHJ4IEEgcmVndWxhciBleHByZXNzaW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRvIG1hdGNoIGFnYWluc3RcbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiBtYXRjaGVzIG9yIGVtcHR5IGFycmF5LlxuICogQHNlZSBSLnRlc3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1hdGNoKC8oW2Etel1hKS9nLCAnYmFuYW5hcycpOyAvLz0+IFsnYmEnLCAnbmEnLCAnbmEnXVxuICogICAgICBSLm1hdGNoKC9hLywgJ2InKTsgLy89PiBbXVxuICogICAgICBSLm1hdGNoKC9hLywgbnVsbCk7IC8vPT4gVHlwZUVycm9yOiBudWxsIGRvZXMgbm90IGhhdmUgYSBtZXRob2QgbmFtZWQgXCJtYXRjaFwiXG4gKi9cblxudmFyIG1hdGNoID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gbWF0Y2gocngsIHN0cikge1xuICByZXR1cm4gc3RyLm1hdGNoKHJ4KSB8fCBbXTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtYXRjaDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgX2lzSW50ZWdlciBmcm9tIFwiLi9pbnRlcm5hbC9faXNJbnRlZ2VyLmpzXCI7XG4vKipcbiAqIGBtYXRoTW9kYCBiZWhhdmVzIGxpa2UgdGhlIG1vZHVsbyBvcGVyYXRvciBzaG91bGQgbWF0aGVtYXRpY2FsbHksIHVubGlrZSB0aGVcbiAqIGAlYCBvcGVyYXRvciAoYW5kIGJ5IGV4dGVuc2lvbiwgW2BSLm1vZHVsb2BdKCNtb2R1bG8pKS4gU28gd2hpbGVcbiAqIGAtMTcgJSA1YCBpcyBgLTJgLCBgbWF0aE1vZCgtMTcsIDUpYCBpcyBgM2AuIGBtYXRoTW9kYCByZXF1aXJlcyBJbnRlZ2VyXG4gKiBhcmd1bWVudHMsIGFuZCByZXR1cm5zIE5hTiB3aGVuIHRoZSBtb2R1bHVzIGlzIHplcm8gb3IgbmVnYXRpdmUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMy4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IE51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IG0gVGhlIGRpdmlkZW5kLlxuICogQHBhcmFtIHtOdW1iZXJ9IHAgdGhlIG1vZHVsdXMuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXN1bHQgb2YgYGIgbW9kIGFgLlxuICogQHNlZSBSLm1vZHVsb1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWF0aE1vZCgtMTcsIDUpOyAgLy89PiAzXG4gKiAgICAgIFIubWF0aE1vZCgxNywgNSk7ICAgLy89PiAyXG4gKiAgICAgIFIubWF0aE1vZCgxNywgLTUpOyAgLy89PiBOYU5cbiAqICAgICAgUi5tYXRoTW9kKDE3LCAwKTsgICAvLz0+IE5hTlxuICogICAgICBSLm1hdGhNb2QoMTcuMiwgNSk7IC8vPT4gTmFOXG4gKiAgICAgIFIubWF0aE1vZCgxNywgNS4zKTsgLy89PiBOYU5cbiAqXG4gKiAgICAgIGNvbnN0IGNsb2NrID0gUi5tYXRoTW9kKFIuX18sIDEyKTtcbiAqICAgICAgY2xvY2soMTUpOyAvLz0+IDNcbiAqICAgICAgY2xvY2soMjQpOyAvLz0+IDBcbiAqXG4gKiAgICAgIGNvbnN0IHNldmVudGVlbk1vZCA9IFIubWF0aE1vZCgxNyk7XG4gKiAgICAgIHNldmVudGVlbk1vZCgzKTsgIC8vPT4gMlxuICogICAgICBzZXZlbnRlZW5Nb2QoNCk7ICAvLz0+IDFcbiAqICAgICAgc2V2ZW50ZWVuTW9kKDEwKTsgLy89PiA3XG4gKi9cblxudmFyIG1hdGhNb2QgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBtYXRoTW9kKG0sIHApIHtcbiAgaWYgKCFfaXNJbnRlZ2VyKG0pKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIGlmICghX2lzSW50ZWdlcihwKSB8fCBwIDwgMSkge1xuICAgIHJldHVybiBOYU47XG4gIH1cblxuICByZXR1cm4gKG0gJSBwICsgcCkgJSBwO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IG1hdGhNb2Q7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5My5qc1wiO1xuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGFuZCB0d28gdmFsdWVzLCBhbmQgcmV0dXJucyB3aGljaGV2ZXIgdmFsdWUgcHJvZHVjZXMgdGhlXG4gKiBsYXJnZXIgcmVzdWx0IHdoZW4gcGFzc2VkIHRvIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYiA9PiAoYSAtPiBiKSAtPiBhIC0+IGEgLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIubWF4LCBSLm1pbkJ5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgLy8gIHNxdWFyZSA6OiBOdW1iZXIgLT4gTnVtYmVyXG4gKiAgICAgIGNvbnN0IHNxdWFyZSA9IG4gPT4gbiAqIG47XG4gKlxuICogICAgICBSLm1heEJ5KHNxdWFyZSwgLTMsIDIpOyAvLz0+IC0zXG4gKlxuICogICAgICBSLnJlZHVjZShSLm1heEJ5KHNxdWFyZSksIDAsIFszLCAtNSwgNCwgMSwgLTJdKTsgLy89PiAtNVxuICogICAgICBSLnJlZHVjZShSLm1heEJ5KHNxdWFyZSksIDAsIFtdKTsgLy89PiAwXG4gKi9cblxudmFyIG1heEJ5ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTMoZnVuY3Rpb24gbWF4QnkoZiwgYSwgYikge1xuICByZXR1cm4gZihiKSA+IGYoYSkgPyBiIDogYTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtYXhCeTsiLCJpbXBvcnQgYWRkIGZyb20gXCIuL2FkZC5qc1wiO1xuaW1wb3J0IHJlZHVjZSBmcm9tIFwiLi9yZWR1Y2UuanNcIjtcbi8qKlxuICogQWRkcyB0b2dldGhlciBhbGwgdGhlIGVsZW1lbnRzIG9mIGEgbGlzdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAc2lnIFtOdW1iZXJdIC0+IE51bWJlclxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBBbiBhcnJheSBvZiBudW1iZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBzdW0gb2YgYWxsIHRoZSBudW1iZXJzIGluIHRoZSBsaXN0LlxuICogQHNlZSBSLnJlZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuc3VtKFsyLDQsNiw4LDEwMCwxXSk7IC8vPT4gMTIxXG4gKi9cblxudmFyIHN1bSA9XG4vKiNfX1BVUkVfXyovXG5yZWR1Y2UoYWRkLCAwKTtcbmV4cG9ydCBkZWZhdWx0IHN1bTsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkxLmpzXCI7XG5pbXBvcnQgc3VtIGZyb20gXCIuL3N1bS5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBtZWFuIG9mIHRoZSBnaXZlbiBsaXN0IG9mIG51bWJlcnMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTQuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgW051bWJlcl0gLT4gTnVtYmVyXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAc2VlIFIubWVkaWFuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5tZWFuKFsyLCA3LCA5XSk7IC8vPT4gNlxuICogICAgICBSLm1lYW4oW10pOyAvLz0+IE5hTlxuICovXG5cbnZhciBtZWFuID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoZnVuY3Rpb24gbWVhbihsaXN0KSB7XG4gIHJldHVybiBzdW0obGlzdCkgLyBsaXN0Lmxlbmd0aDtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtZWFuOyIsImltcG9ydCBfY3VycnkxIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTEuanNcIjtcbmltcG9ydCBtZWFuIGZyb20gXCIuL21lYW4uanNcIjtcbi8qKlxuICogUmV0dXJucyB0aGUgbWVkaWFuIG9mIHRoZSBnaXZlbiBsaXN0IG9mIG51bWJlcnMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTQuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgW051bWJlcl0gLT4gTnVtYmVyXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAc2VlIFIubWVhblxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWVkaWFuKFsyLCA5LCA3XSk7IC8vPT4gN1xuICogICAgICBSLm1lZGlhbihbNywgMiwgMTAsIDldKTsgLy89PiA4XG4gKiAgICAgIFIubWVkaWFuKFtdKTsgLy89PiBOYU5cbiAqL1xuXG52YXIgbWVkaWFuID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoZnVuY3Rpb24gbWVkaWFuKGxpc3QpIHtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuXG4gIGlmIChsZW4gPT09IDApIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgdmFyIHdpZHRoID0gMiAtIGxlbiAlIDI7XG4gIHZhciBpZHggPSAobGVuIC0gd2lkdGgpIC8gMjtcbiAgcmV0dXJuIG1lYW4oQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbiAgfSkuc2xpY2UoaWR4LCBpZHggKyB3aWR0aCkpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IG1lZGlhbjsiLCJpbXBvcnQgX2FyaXR5IGZyb20gXCIuL2ludGVybmFsL19hcml0eS5qc1wiO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9oYXMgZnJvbSBcIi4vaW50ZXJuYWwvX2hhcy5qc1wiO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZ1bmN0aW9uIHRoYXQsIHdoZW4gaW52b2tlZCwgY2FjaGVzIHRoZSByZXN1bHQgb2YgY2FsbGluZyBgZm5gXG4gKiBmb3IgYSBnaXZlbiBhcmd1bWVudCBzZXQgYW5kIHJldHVybnMgdGhlIHJlc3VsdC4gU3Vic2VxdWVudCBjYWxscyB0byB0aGVcbiAqIG1lbW9pemVkIGBmbmAgd2l0aCB0aGUgc2FtZSBhcmd1bWVudCBzZXQgd2lsbCBub3QgcmVzdWx0IGluIGFuIGFkZGl0aW9uYWxcbiAqIGNhbGwgdG8gYGZuYDsgaW5zdGVhZCwgdGhlIGNhY2hlZCByZXN1bHQgZm9yIHRoYXQgc2V0IG9mIGFyZ3VtZW50cyB3aWxsIGJlXG4gKiByZXR1cm5lZC5cbiAqXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjQuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgqLi4uIC0+IFN0cmluZykgLT4gKCouLi4gLT4gYSkgLT4gKCouLi4gLT4gYSlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBnZW5lcmF0ZSB0aGUgY2FjaGUga2V5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1lbW9pemUuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gTWVtb2l6ZWQgdmVyc2lvbiBvZiBgZm5gLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGxldCBjb3VudCA9IDA7XG4gKiAgICAgIGNvbnN0IGZhY3RvcmlhbCA9IFIubWVtb2l6ZVdpdGgoUi5pZGVudGl0eSwgbiA9PiB7XG4gKiAgICAgICAgY291bnQgKz0gMTtcbiAqICAgICAgICByZXR1cm4gUi5wcm9kdWN0KFIucmFuZ2UoMSwgbiArIDEpKTtcbiAqICAgICAgfSk7XG4gKiAgICAgIGZhY3RvcmlhbCg1KTsgLy89PiAxMjBcbiAqICAgICAgZmFjdG9yaWFsKDUpOyAvLz0+IDEyMFxuICogICAgICBmYWN0b3JpYWwoNSk7IC8vPT4gMTIwXG4gKiAgICAgIGNvdW50OyAvLz0+IDFcbiAqL1xuXG52YXIgbWVtb2l6ZVdpdGggPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBtZW1vaXplV2l0aChtRm4sIGZuKSB7XG4gIHZhciBjYWNoZSA9IHt9O1xuICByZXR1cm4gX2FyaXR5KGZuLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBrZXkgPSBtRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIGlmICghX2hhcyhrZXksIGNhY2hlKSkge1xuICAgICAgY2FjaGVba2V5XSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhY2hlW2tleV07XG4gIH0pO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IG1lbW9pemVXaXRoOyIsImltcG9ydCBfb2JqZWN0QXNzaWduIGZyb20gXCIuL2ludGVybmFsL19vYmplY3RBc3NpZ24uanNcIjtcbmltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogQ3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgZmlyc3Qgb2JqZWN0IG1lcmdlZCB3aXRoXG4gKiB0aGUgb3duIHByb3BlcnRpZXMgb2YgdGhlIHNlY29uZCBvYmplY3QuIElmIGEga2V5IGV4aXN0cyBpbiBib3RoIG9iamVjdHMsXG4gKiB0aGUgdmFsdWUgZnJvbSB0aGUgc2Vjb25kIG9iamVjdCB3aWxsIGJlIHVzZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtrOiB2fSAtPiB7azogdn0gLT4ge2s6IHZ9XG4gKiBAcGFyYW0ge09iamVjdH0gbFxuICogQHBhcmFtIHtPYmplY3R9IHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBzZWUgUi5tZXJnZVJpZ2h0LCBSLm1lcmdlRGVlcFJpZ2h0LCBSLm1lcmdlV2l0aCwgUi5tZXJnZVdpdGhLZXlcbiAqIEBkZXByZWNhdGVkIHNpbmNlIHYwLjI2LjBcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1lcmdlKHsgJ25hbWUnOiAnZnJlZCcsICdhZ2UnOiAxMCB9LCB7ICdhZ2UnOiA0MCB9KTtcbiAqICAgICAgLy89PiB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogNDAgfVxuICpcbiAqICAgICAgY29uc3Qgd2l0aERlZmF1bHRzID0gUi5tZXJnZSh7eDogMCwgeTogMH0pO1xuICogICAgICB3aXRoRGVmYXVsdHMoe3k6IDJ9KTsgLy89PiB7eDogMCwgeTogMn1cbiAqIEBzeW1iIFIubWVyZ2UoYSwgYikgPSB7Li4uYSwgLi4uYn1cbiAqL1xuXG52YXIgbWVyZ2UgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBtZXJnZShsLCByKSB7XG4gIHJldHVybiBfb2JqZWN0QXNzaWduKHt9LCBsLCByKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtZXJnZTsiLCJpbXBvcnQgX29iamVjdEFzc2lnbiBmcm9tIFwiLi9pbnRlcm5hbC9fb2JqZWN0QXNzaWduLmpzXCI7XG5pbXBvcnQgX2N1cnJ5MSBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkxLmpzXCI7XG4vKipcbiAqIE1lcmdlcyBhIGxpc3Qgb2Ygb2JqZWN0cyB0b2dldGhlciBpbnRvIG9uZSBvYmplY3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTAuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW3trOiB2fV0gLT4ge2s6IHZ9XG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IEFuIGFycmF5IG9mIG9iamVjdHNcbiAqIEByZXR1cm4ge09iamVjdH0gQSBtZXJnZWQgb2JqZWN0LlxuICogQHNlZSBSLnJlZHVjZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWVyZ2VBbGwoW3tmb286MX0se2JhcjoyfSx7YmF6OjN9XSk7IC8vPT4ge2ZvbzoxLGJhcjoyLGJhejozfVxuICogICAgICBSLm1lcmdlQWxsKFt7Zm9vOjF9LHtmb286Mn0se2JhcjoyfV0pOyAvLz0+IHtmb286MixiYXI6Mn1cbiAqIEBzeW1iIFIubWVyZ2VBbGwoW3sgeDogMSB9LCB7IHk6IDIgfSwgeyB6OiAzIH1dKSA9IHsgeDogMSwgeTogMiwgejogMyB9XG4gKi9cblxudmFyIG1lcmdlQWxsID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoZnVuY3Rpb24gbWVyZ2VBbGwobGlzdCkge1xuICByZXR1cm4gX29iamVjdEFzc2lnbi5hcHBseShudWxsLCBbe31dLmNvbmNhdChsaXN0KSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbWVyZ2VBbGw7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5My5qc1wiO1xuaW1wb3J0IF9oYXMgZnJvbSBcIi4vaW50ZXJuYWwvX2hhcy5qc1wiO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgdHdvIHByb3ZpZGVkIG9iamVjdHMuIElmXG4gKiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzLCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gaXMgYXBwbGllZCB0byB0aGUga2V5XG4gKiBhbmQgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGtleSBpbiBlYWNoIG9iamVjdCwgd2l0aCB0aGUgcmVzdWx0IGJlaW5nXG4gKiB1c2VkIGFzIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleSBpbiB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgKChTdHJpbmcsIGEsIGEpIC0+IGEpIC0+IHthfSAtPiB7YX0gLT4ge2F9XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGxcbiAqIEBwYXJhbSB7T2JqZWN0fSByXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAc2VlIFIubWVyZ2VEZWVwV2l0aEtleSwgUi5tZXJnZSwgUi5tZXJnZVdpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBsZXQgY29uY2F0VmFsdWVzID0gKGssIGwsIHIpID0+IGsgPT0gJ3ZhbHVlcycgPyBSLmNvbmNhdChsLCByKSA6IHJcbiAqICAgICAgUi5tZXJnZVdpdGhLZXkoY29uY2F0VmFsdWVzLFxuICogICAgICAgICAgICAgICAgICAgICB7IGE6IHRydWUsIHRoaW5nOiAnZm9vJywgdmFsdWVzOiBbMTAsIDIwXSB9LFxuICogICAgICAgICAgICAgICAgICAgICB7IGI6IHRydWUsIHRoaW5nOiAnYmFyJywgdmFsdWVzOiBbMTUsIDM1XSB9KTtcbiAqICAgICAgLy89PiB7IGE6IHRydWUsIGI6IHRydWUsIHRoaW5nOiAnYmFyJywgdmFsdWVzOiBbMTAsIDIwLCAxNSwgMzVdIH1cbiAqIEBzeW1iIFIubWVyZ2VXaXRoS2V5KGYsIHsgeDogMSwgeTogMiB9LCB7IHk6IDUsIHo6IDMgfSkgPSB7IHg6IDEsIHk6IGYoJ3knLCAyLCA1KSwgejogMyB9XG4gKi9cblxudmFyIG1lcmdlV2l0aEtleSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKGZ1bmN0aW9uIG1lcmdlV2l0aEtleShmbiwgbCwgcikge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIHZhciBrO1xuXG4gIGZvciAoayBpbiBsKSB7XG4gICAgaWYgKF9oYXMoaywgbCkpIHtcbiAgICAgIHJlc3VsdFtrXSA9IF9oYXMoaywgcikgPyBmbihrLCBsW2tdLCByW2tdKSA6IGxba107XG4gICAgfVxuICB9XG5cbiAgZm9yIChrIGluIHIpIHtcbiAgICBpZiAoX2hhcyhrLCByKSAmJiAhX2hhcyhrLCByZXN1bHQpKSB7XG4gICAgICByZXN1bHRba10gPSByW2tdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbWVyZ2VXaXRoS2V5OyIsImltcG9ydCBfY3VycnkzIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTMuanNcIjtcbmltcG9ydCBfaXNPYmplY3QgZnJvbSBcIi4vaW50ZXJuYWwvX2lzT2JqZWN0LmpzXCI7XG5pbXBvcnQgbWVyZ2VXaXRoS2V5IGZyb20gXCIuL21lcmdlV2l0aEtleS5qc1wiO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgdHdvIHByb3ZpZGVkIG9iamVjdHMuXG4gKiBJZiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzOlxuICogLSBhbmQgYm90aCBhc3NvY2lhdGVkIHZhbHVlcyBhcmUgYWxzbyBvYmplY3RzIHRoZW4gdGhlIHZhbHVlcyB3aWxsIGJlXG4gKiAgIHJlY3Vyc2l2ZWx5IG1lcmdlZC5cbiAqIC0gb3RoZXJ3aXNlIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIHRoZSBrZXkgYW5kIGFzc29jaWF0ZWQgdmFsdWVzXG4gKiAgIHVzaW5nIHRoZSByZXN1bHRpbmcgdmFsdWUgYXMgdGhlIG5ldyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGtleS5cbiAqIElmIGEga2V5IG9ubHkgZXhpc3RzIGluIG9uZSBvYmplY3QsIHRoZSB2YWx1ZSB3aWxsIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5XG4gKiBvZiB0aGUgcmVzdWx0aW5nIG9iamVjdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnICgoU3RyaW5nLCBhLCBhKSAtPiBhKSAtPiB7YX0gLT4ge2F9IC0+IHthfVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsT2JqXG4gKiBAcGFyYW0ge09iamVjdH0gck9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHNlZSBSLm1lcmdlV2l0aEtleSwgUi5tZXJnZURlZXBXaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgbGV0IGNvbmNhdFZhbHVlcyA9IChrLCBsLCByKSA9PiBrID09ICd2YWx1ZXMnID8gUi5jb25jYXQobCwgcikgOiByXG4gKiAgICAgIFIubWVyZ2VEZWVwV2l0aEtleShjb25jYXRWYWx1ZXMsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICB7IGE6IHRydWUsIGM6IHsgdGhpbmc6ICdmb28nLCB2YWx1ZXM6IFsxMCwgMjBdIH19LFxuICogICAgICAgICAgICAgICAgICAgICAgICAgeyBiOiB0cnVlLCBjOiB7IHRoaW5nOiAnYmFyJywgdmFsdWVzOiBbMTUsIDM1XSB9fSk7XG4gKiAgICAgIC8vPT4geyBhOiB0cnVlLCBiOiB0cnVlLCBjOiB7IHRoaW5nOiAnYmFyJywgdmFsdWVzOiBbMTAsIDIwLCAxNSwgMzVdIH19XG4gKi9cblxudmFyIG1lcmdlRGVlcFdpdGhLZXkgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MyhmdW5jdGlvbiBtZXJnZURlZXBXaXRoS2V5KGZuLCBsT2JqLCByT2JqKSB7XG4gIHJldHVybiBtZXJnZVdpdGhLZXkoZnVuY3Rpb24gKGssIGxWYWwsIHJWYWwpIHtcbiAgICBpZiAoX2lzT2JqZWN0KGxWYWwpICYmIF9pc09iamVjdChyVmFsKSkge1xuICAgICAgcmV0dXJuIG1lcmdlRGVlcFdpdGhLZXkoZm4sIGxWYWwsIHJWYWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZm4oaywgbFZhbCwgclZhbCk7XG4gICAgfVxuICB9LCBsT2JqLCByT2JqKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtZXJnZURlZXBXaXRoS2V5OyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbmltcG9ydCBtZXJnZURlZXBXaXRoS2V5IGZyb20gXCIuL21lcmdlRGVlcFdpdGhLZXkuanNcIjtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3duIHByb3BlcnRpZXMgb2YgdGhlIGZpcnN0IG9iamVjdCBtZXJnZWQgd2l0aFxuICogdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBzZWNvbmQgb2JqZWN0LiBJZiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzOlxuICogLSBhbmQgYm90aCB2YWx1ZXMgYXJlIG9iamVjdHMsIHRoZSB0d28gdmFsdWVzIHdpbGwgYmUgcmVjdXJzaXZlbHkgbWVyZ2VkXG4gKiAtIG90aGVyd2lzZSB0aGUgdmFsdWUgZnJvbSB0aGUgZmlyc3Qgb2JqZWN0IHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHthfSAtPiB7YX0gLT4ge2F9XG4gKiBAcGFyYW0ge09iamVjdH0gbE9ialxuICogQHBhcmFtIHtPYmplY3R9IHJPYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBzZWUgUi5tZXJnZSwgUi5tZXJnZURlZXBSaWdodCwgUi5tZXJnZURlZXBXaXRoLCBSLm1lcmdlRGVlcFdpdGhLZXlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1lcmdlRGVlcExlZnQoeyBuYW1lOiAnZnJlZCcsIGFnZTogMTAsIGNvbnRhY3Q6IHsgZW1haWw6ICdtb29AZXhhbXBsZS5jb20nIH19LFxuICogICAgICAgICAgICAgICAgICAgICAgeyBhZ2U6IDQwLCBjb250YWN0OiB7IGVtYWlsOiAnYmFhQGV4YW1wbGUuY29tJyB9fSk7XG4gKiAgICAgIC8vPT4geyBuYW1lOiAnZnJlZCcsIGFnZTogMTAsIGNvbnRhY3Q6IHsgZW1haWw6ICdtb29AZXhhbXBsZS5jb20nIH19XG4gKi9cblxudmFyIG1lcmdlRGVlcExlZnQgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBtZXJnZURlZXBMZWZ0KGxPYmosIHJPYmopIHtcbiAgcmV0dXJuIG1lcmdlRGVlcFdpdGhLZXkoZnVuY3Rpb24gKGssIGxWYWwsIHJWYWwpIHtcbiAgICByZXR1cm4gbFZhbDtcbiAgfSwgbE9iaiwgck9iaik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbWVyZ2VEZWVwTGVmdDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgbWVyZ2VEZWVwV2l0aEtleSBmcm9tIFwiLi9tZXJnZURlZXBXaXRoS2V5LmpzXCI7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBmaXJzdCBvYmplY3QgbWVyZ2VkIHdpdGhcbiAqIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgc2Vjb25kIG9iamVjdC4gSWYgYSBrZXkgZXhpc3RzIGluIGJvdGggb2JqZWN0czpcbiAqIC0gYW5kIGJvdGggdmFsdWVzIGFyZSBvYmplY3RzLCB0aGUgdHdvIHZhbHVlcyB3aWxsIGJlIHJlY3Vyc2l2ZWx5IG1lcmdlZFxuICogLSBvdGhlcndpc2UgdGhlIHZhbHVlIGZyb20gdGhlIHNlY29uZCBvYmplY3Qgd2lsbCBiZSB1c2VkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjI0LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcge2F9IC0+IHthfSAtPiB7YX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBsT2JqXG4gKiBAcGFyYW0ge09iamVjdH0gck9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHNlZSBSLm1lcmdlLCBSLm1lcmdlRGVlcExlZnQsIFIubWVyZ2VEZWVwV2l0aCwgUi5tZXJnZURlZXBXaXRoS2V5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5tZXJnZURlZXBSaWdodCh7IG5hbWU6ICdmcmVkJywgYWdlOiAxMCwgY29udGFjdDogeyBlbWFpbDogJ21vb0BleGFtcGxlLmNvbScgfX0sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgeyBhZ2U6IDQwLCBjb250YWN0OiB7IGVtYWlsOiAnYmFhQGV4YW1wbGUuY29tJyB9fSk7XG4gKiAgICAgIC8vPT4geyBuYW1lOiAnZnJlZCcsIGFnZTogNDAsIGNvbnRhY3Q6IHsgZW1haWw6ICdiYWFAZXhhbXBsZS5jb20nIH19XG4gKi9cblxudmFyIG1lcmdlRGVlcFJpZ2h0ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gbWVyZ2VEZWVwUmlnaHQobE9iaiwgck9iaikge1xuICByZXR1cm4gbWVyZ2VEZWVwV2l0aEtleShmdW5jdGlvbiAoaywgbFZhbCwgclZhbCkge1xuICAgIHJldHVybiByVmFsO1xuICB9LCBsT2JqLCByT2JqKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtZXJnZURlZXBSaWdodDsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkzLmpzXCI7XG5pbXBvcnQgbWVyZ2VEZWVwV2l0aEtleSBmcm9tIFwiLi9tZXJnZURlZXBXaXRoS2V5LmpzXCI7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSB0d28gcHJvdmlkZWQgb2JqZWN0cy5cbiAqIElmIGEga2V5IGV4aXN0cyBpbiBib3RoIG9iamVjdHM6XG4gKiAtIGFuZCBib3RoIGFzc29jaWF0ZWQgdmFsdWVzIGFyZSBhbHNvIG9iamVjdHMgdGhlbiB0aGUgdmFsdWVzIHdpbGwgYmVcbiAqICAgcmVjdXJzaXZlbHkgbWVyZ2VkLlxuICogLSBvdGhlcndpc2UgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uIGlzIGFwcGxpZWQgdG8gYXNzb2NpYXRlZCB2YWx1ZXMgdXNpbmcgdGhlXG4gKiAgIHJlc3VsdGluZyB2YWx1ZSBhcyB0aGUgbmV3IHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5LlxuICogSWYgYSBrZXkgb25seSBleGlzdHMgaW4gb25lIG9iamVjdCwgdGhlIHZhbHVlIHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBrZXlcbiAqIG9mIHRoZSByZXN1bHRpbmcgb2JqZWN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjI0LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgKChhLCBhKSAtPiBhKSAtPiB7YX0gLT4ge2F9IC0+IHthfVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsT2JqXG4gKiBAcGFyYW0ge09iamVjdH0gck9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQHNlZSBSLm1lcmdlV2l0aCwgUi5tZXJnZURlZXBXaXRoS2V5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5tZXJnZURlZXBXaXRoKFIuY29uY2F0LFxuICogICAgICAgICAgICAgICAgICAgICAgeyBhOiB0cnVlLCBjOiB7IHZhbHVlczogWzEwLCAyMF0gfX0sXG4gKiAgICAgICAgICAgICAgICAgICAgICB7IGI6IHRydWUsIGM6IHsgdmFsdWVzOiBbMTUsIDM1XSB9fSk7XG4gKiAgICAgIC8vPT4geyBhOiB0cnVlLCBiOiB0cnVlLCBjOiB7IHZhbHVlczogWzEwLCAyMCwgMTUsIDM1XSB9fVxuICovXG5cbnZhciBtZXJnZURlZXBXaXRoID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTMoZnVuY3Rpb24gbWVyZ2VEZWVwV2l0aChmbiwgbE9iaiwgck9iaikge1xuICByZXR1cm4gbWVyZ2VEZWVwV2l0aEtleShmdW5jdGlvbiAoaywgbFZhbCwgclZhbCkge1xuICAgIHJldHVybiBmbihsVmFsLCByVmFsKTtcbiAgfSwgbE9iaiwgck9iaik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbWVyZ2VEZWVwV2l0aDsiLCJpbXBvcnQgX29iamVjdEFzc2lnbiBmcm9tIFwiLi9pbnRlcm5hbC9fb2JqZWN0QXNzaWduLmpzXCI7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3duIHByb3BlcnRpZXMgb2YgdGhlIGZpcnN0IG9iamVjdCBtZXJnZWQgd2l0aFxuICogdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBzZWNvbmQgb2JqZWN0LiBJZiBhIGtleSBleGlzdHMgaW4gYm90aCBvYmplY3RzLFxuICogdGhlIHZhbHVlIGZyb20gdGhlIGZpcnN0IG9iamVjdCB3aWxsIGJlIHVzZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjYuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7azogdn0gLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICogQHBhcmFtIHtPYmplY3R9IGxcbiAqIEBwYXJhbSB7T2JqZWN0fSByXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAc2VlIFIubWVyZ2VSaWdodCwgUi5tZXJnZURlZXBMZWZ0LCBSLm1lcmdlV2l0aCwgUi5tZXJnZVdpdGhLZXlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1lcmdlTGVmdCh7ICdhZ2UnOiA0MCB9LCB7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogMTAgfSk7XG4gKiAgICAgIC8vPT4geyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH1cbiAqXG4gKiAgICAgIGNvbnN0IHJlc2V0VG9EZWZhdWx0ID0gUi5tZXJnZUxlZnQoe3g6IDB9KTtcbiAqICAgICAgcmVzZXRUb0RlZmF1bHQoe3g6IDUsIHk6IDJ9KTsgLy89PiB7eDogMCwgeTogMn1cbiAqIEBzeW1iIFIubWVyZ2VMZWZ0KGEsIGIpID0gey4uLmIsIC4uLmF9XG4gKi9cblxudmFyIG1lcmdlTGVmdCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIG1lcmdlTGVmdChsLCByKSB7XG4gIHJldHVybiBfb2JqZWN0QXNzaWduKHt9LCByLCBsKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtZXJnZUxlZnQ7IiwiaW1wb3J0IF9vYmplY3RBc3NpZ24gZnJvbSBcIi4vaW50ZXJuYWwvX29iamVjdEFzc2lnbi5qc1wiO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSBmaXJzdCBvYmplY3QgbWVyZ2VkIHdpdGhcbiAqIHRoZSBvd24gcHJvcGVydGllcyBvZiB0aGUgc2Vjb25kIG9iamVjdC4gSWYgYSBrZXkgZXhpc3RzIGluIGJvdGggb2JqZWN0cyxcbiAqIHRoZSB2YWx1ZSBmcm9tIHRoZSBzZWNvbmQgb2JqZWN0IHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yNi4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtrOiB2fSAtPiB7azogdn0gLT4ge2s6IHZ9XG4gKiBAcGFyYW0ge09iamVjdH0gbFxuICogQHBhcmFtIHtPYmplY3R9IHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBzZWUgUi5tZXJnZUxlZnQsIFIubWVyZ2VEZWVwUmlnaHQsIFIubWVyZ2VXaXRoLCBSLm1lcmdlV2l0aEtleVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubWVyZ2VSaWdodCh7ICduYW1lJzogJ2ZyZWQnLCAnYWdlJzogMTAgfSwgeyAnYWdlJzogNDAgfSk7XG4gKiAgICAgIC8vPT4geyAnbmFtZSc6ICdmcmVkJywgJ2FnZSc6IDQwIH1cbiAqXG4gKiAgICAgIGNvbnN0IHdpdGhEZWZhdWx0cyA9IFIubWVyZ2VSaWdodCh7eDogMCwgeTogMH0pO1xuICogICAgICB3aXRoRGVmYXVsdHMoe3k6IDJ9KTsgLy89PiB7eDogMCwgeTogMn1cbiAqIEBzeW1iIFIubWVyZ2VSaWdodChhLCBiKSA9IHsuLi5hLCAuLi5ifVxuICovXG5cbnZhciBtZXJnZVJpZ2h0ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gbWVyZ2VSaWdodChsLCByKSB7XG4gIHJldHVybiBfb2JqZWN0QXNzaWduKHt9LCBsLCByKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtZXJnZVJpZ2h0OyIsImltcG9ydCBfY3VycnkzIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTMuanNcIjtcbmltcG9ydCBtZXJnZVdpdGhLZXkgZnJvbSBcIi4vbWVyZ2VXaXRoS2V5LmpzXCI7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG93biBwcm9wZXJ0aWVzIG9mIHRoZSB0d28gcHJvdmlkZWQgb2JqZWN0cy4gSWZcbiAqIGEga2V5IGV4aXN0cyBpbiBib3RoIG9iamVjdHMsIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpcyBhcHBsaWVkIHRvIHRoZSB2YWx1ZXNcbiAqIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5IGluIGVhY2ggb2JqZWN0LCB3aXRoIHRoZSByZXN1bHQgYmVpbmcgdXNlZCBhcyB0aGVcbiAqIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5IGluIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyAoKGEsIGEpIC0+IGEpIC0+IHthfSAtPiB7YX0gLT4ge2F9XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGxcbiAqIEBwYXJhbSB7T2JqZWN0fSByXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAc2VlIFIubWVyZ2VEZWVwV2l0aCwgUi5tZXJnZSwgUi5tZXJnZVdpdGhLZXlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm1lcmdlV2l0aChSLmNvbmNhdCxcbiAqICAgICAgICAgICAgICAgICAgeyBhOiB0cnVlLCB2YWx1ZXM6IFsxMCwgMjBdIH0sXG4gKiAgICAgICAgICAgICAgICAgIHsgYjogdHJ1ZSwgdmFsdWVzOiBbMTUsIDM1XSB9KTtcbiAqICAgICAgLy89PiB7IGE6IHRydWUsIGI6IHRydWUsIHZhbHVlczogWzEwLCAyMCwgMTUsIDM1XSB9XG4gKi9cblxudmFyIG1lcmdlV2l0aCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKGZ1bmN0aW9uIG1lcmdlV2l0aChmbiwgbCwgcikge1xuICByZXR1cm4gbWVyZ2VXaXRoS2V5KGZ1bmN0aW9uIChfLCBfbCwgX3IpIHtcbiAgICByZXR1cm4gZm4oX2wsIF9yKTtcbiAgfSwgbCwgcik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbWVyZ2VXaXRoOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogUmV0dXJucyB0aGUgc21hbGxlciBvZiBpdHMgdHdvIGFyZ3VtZW50cy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYSA9PiBhIC0+IGEgLT4gYVxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIubWluQnksIFIubWF4XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5taW4oNzg5LCAxMjMpOyAvLz0+IDEyM1xuICogICAgICBSLm1pbignYScsICdiJyk7IC8vPT4gJ2EnXG4gKi9cblxudmFyIG1pbiA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIG1pbihhLCBiKSB7XG4gIHJldHVybiBiIDwgYSA/IGIgOiBhO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IG1pbjsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkzLmpzXCI7XG4vKipcbiAqIFRha2VzIGEgZnVuY3Rpb24gYW5kIHR3byB2YWx1ZXMsIGFuZCByZXR1cm5zIHdoaWNoZXZlciB2YWx1ZSBwcm9kdWNlcyB0aGVcbiAqIHNtYWxsZXIgcmVzdWx0IHdoZW4gcGFzc2VkIHRvIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYiA9PiAoYSAtPiBiKSAtPiBhIC0+IGEgLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHBhcmFtIHsqfSBhXG4gKiBAcGFyYW0geyp9IGJcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIubWluLCBSLm1heEJ5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgLy8gIHNxdWFyZSA6OiBOdW1iZXIgLT4gTnVtYmVyXG4gKiAgICAgIGNvbnN0IHNxdWFyZSA9IG4gPT4gbiAqIG47XG4gKlxuICogICAgICBSLm1pbkJ5KHNxdWFyZSwgLTMsIDIpOyAvLz0+IDJcbiAqXG4gKiAgICAgIFIucmVkdWNlKFIubWluQnkoc3F1YXJlKSwgSW5maW5pdHksIFszLCAtNSwgNCwgMSwgLTJdKTsgLy89PiAxXG4gKiAgICAgIFIucmVkdWNlKFIubWluQnkoc3F1YXJlKSwgSW5maW5pdHksIFtdKTsgLy89PiBJbmZpbml0eVxuICovXG5cbnZhciBtaW5CeSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKGZ1bmN0aW9uIG1pbkJ5KGYsIGEsIGIpIHtcbiAgcmV0dXJuIGYoYikgPCBmKGEpID8gYiA6IGE7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbWluQnk7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuLyoqXG4gKiBEaXZpZGVzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgYnkgdGhlIHNlY29uZCBhbmQgcmV0dXJucyB0aGUgcmVtYWluZGVyLiBOb3RlXG4gKiB0aGF0IHRoaXMgZnVuY3Rpb24gcHJlc2VydmVzIHRoZSBKYXZhU2NyaXB0LXN0eWxlIGJlaGF2aW9yIGZvciBtb2R1bG8uIEZvclxuICogbWF0aGVtYXRpY2FsIG1vZHVsbyBzZWUgW2BtYXRoTW9kYF0oI21hdGhNb2QpLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMVxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlciAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSB2YWx1ZSB0byB0aGUgZGl2aWRlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHBzZXVkby1tb2R1bHVzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSByZXN1bHQgb2YgYGIgJSBhYC5cbiAqIEBzZWUgUi5tYXRoTW9kXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5tb2R1bG8oMTcsIDMpOyAvLz0+IDJcbiAqICAgICAgLy8gSlMgYmVoYXZpb3I6XG4gKiAgICAgIFIubW9kdWxvKC0xNywgMyk7IC8vPT4gLTJcbiAqICAgICAgUi5tb2R1bG8oMTcsIC0zKTsgLy89PiAyXG4gKlxuICogICAgICBjb25zdCBpc09kZCA9IFIubW9kdWxvKFIuX18sIDIpO1xuICogICAgICBpc09kZCg0Mik7IC8vPT4gMFxuICogICAgICBpc09kZCgyMSk7IC8vPT4gMVxuICovXG5cbnZhciBtb2R1bG8gPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBtb2R1bG8oYSwgYikge1xuICByZXR1cm4gYSAlIGI7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbW9kdWxvOyIsImltcG9ydCBfY3VycnkzIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTMuanNcIjtcbi8qKlxuICogTW92ZSBhbiBpdGVtLCBhdCBpbmRleCBgZnJvbWAsIHRvIGluZGV4IGB0b2AsIGluIGEgbGlzdCBvZiBlbGVtZW50cy5cbiAqIEEgbmV3IGxpc3Qgd2lsbCBiZSBjcmVhdGVkIGNvbnRhaW5pbmcgdGhlIG5ldyBlbGVtZW50cyBvcmRlci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yNy4xXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tIFRoZSBzb3VyY2UgaW5kZXhcbiAqIEBwYXJhbSB7TnVtYmVyfSB0byBUaGUgZGVzdGluYXRpb24gaW5kZXhcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3Qgd2hpY2ggd2lsbCBzZXJ2ZSB0byByZWFsaXNlIHRoZSBtb3ZlXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIG5ldyBsaXN0IHJlb3JkZXJlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIubW92ZSgwLCAyLCBbJ2EnLCAnYicsICdjJywgJ2QnLCAnZScsICdmJ10pOyAvLz0+IFsnYicsICdjJywgJ2EnLCAnZCcsICdlJywgJ2YnXVxuICogICAgICBSLm1vdmUoLTEsIDAsIFsnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnXSk7IC8vPT4gWydmJywgJ2EnLCAnYicsICdjJywgJ2QnLCAnZSddIGxpc3Qgcm90YXRpb25cbiAqL1xuXG52YXIgbW92ZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKGZ1bmN0aW9uIChmcm9tLCB0bywgbGlzdCkge1xuICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBsaXN0LnNsaWNlKCk7XG4gIHZhciBwb3NpdGl2ZUZyb20gPSBmcm9tIDwgMCA/IGxlbmd0aCArIGZyb20gOiBmcm9tO1xuICB2YXIgcG9zaXRpdmVUbyA9IHRvIDwgMCA/IGxlbmd0aCArIHRvIDogdG87XG4gIHZhciBpdGVtID0gcmVzdWx0LnNwbGljZShwb3NpdGl2ZUZyb20sIDEpO1xuICByZXR1cm4gcG9zaXRpdmVGcm9tIDwgMCB8fCBwb3NpdGl2ZUZyb20gPj0gbGlzdC5sZW5ndGggfHwgcG9zaXRpdmVUbyA8IDAgfHwgcG9zaXRpdmVUbyA+PSBsaXN0Lmxlbmd0aCA/IGxpc3QgOiBbXS5jb25jYXQocmVzdWx0LnNsaWNlKDAsIHBvc2l0aXZlVG8pKS5jb25jYXQoaXRlbSkuY29uY2F0KHJlc3VsdC5zbGljZShwb3NpdGl2ZVRvLCBsaXN0Lmxlbmd0aCkpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IG1vdmU7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBudW1iZXJzLiBFcXVpdmFsZW50IHRvIGBhICogYmAgYnV0IGN1cnJpZWQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IE51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGZpcnN0IHZhbHVlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCB2YWx1ZS5cbiAqIEByZXR1cm4ge051bWJlcn0gVGhlIHJlc3VsdCBvZiBgYSAqIGJgLlxuICogQHNlZSBSLmRpdmlkZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGRvdWJsZSA9IFIubXVsdGlwbHkoMik7XG4gKiAgICAgIGNvbnN0IHRyaXBsZSA9IFIubXVsdGlwbHkoMyk7XG4gKiAgICAgIGRvdWJsZSgzKTsgICAgICAgLy89PiAgNlxuICogICAgICB0cmlwbGUoNCk7ICAgICAgIC8vPT4gMTJcbiAqICAgICAgUi5tdWx0aXBseSgyLCA1KTsgIC8vPT4gMTBcbiAqL1xuXG52YXIgbXVsdGlwbHkgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBtdWx0aXBseShhLCBiKSB7XG4gIHJldHVybiBhICogYjtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBtdWx0aXBseTsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkxLmpzXCI7XG4vKipcbiAqIE5lZ2F0ZXMgaXRzIGFyZ3VtZW50LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjkuMFxuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBzaWcgTnVtYmVyIC0+IE51bWJlclxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm5lZ2F0ZSg0Mik7IC8vPT4gLTQyXG4gKi9cblxudmFyIG5lZ2F0ZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKGZ1bmN0aW9uIG5lZ2F0ZShuKSB7XG4gIHJldHVybiAtbjtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBuZWdhdGU7IiwiaW1wb3J0IF9jb21wbGVtZW50IGZyb20gXCIuL2ludGVybmFsL19jb21wbGVtZW50LmpzXCI7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgYWxsIGZyb20gXCIuL2FsbC5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiBubyBlbGVtZW50cyBvZiB0aGUgbGlzdCBtYXRjaCB0aGUgcHJlZGljYXRlLCBgZmFsc2VgXG4gKiBvdGhlcndpc2UuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYGFsbGAgbWV0aG9kIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQWN0cyBhcyBhIHRyYW5zZHVjZXIgaWYgYSB0cmFuc2Zvcm1lciBpcyBnaXZlbiBpbiBsaXN0IHBvc2l0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEyLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByZWRpY2F0ZSBpcyBub3Qgc2F0aXNmaWVkIGJ5IGV2ZXJ5IGVsZW1lbnQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogQHNlZSBSLmFsbCwgUi5hbnlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBpc0V2ZW4gPSBuID0+IG4gJSAyID09PSAwO1xuICogICAgICBjb25zdCBpc09kZCA9IG4gPT4gbiAlIDIgPT09IDE7XG4gKlxuICogICAgICBSLm5vbmUoaXNFdmVuLCBbMSwgMywgNSwgNywgOSwgMTFdKTsgLy89PiB0cnVlXG4gKiAgICAgIFIubm9uZShpc09kZCwgWzEsIDMsIDUsIDcsIDgsIDExXSk7IC8vPT4gZmFsc2VcbiAqL1xuXG52YXIgbm9uZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIG5vbmUoZm4sIGlucHV0KSB7XG4gIHJldHVybiBhbGwoX2NvbXBsZW1lbnQoZm4pLCBpbnB1dCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgbm9uZTsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkxLmpzXCI7XG5pbXBvcnQgY3VycnlOIGZyb20gXCIuL2N1cnJ5Ti5qc1wiO1xuaW1wb3J0IG50aCBmcm9tIFwiLi9udGguanNcIjtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgaXRzIG50aCBhcmd1bWVudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC45LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBOdW1iZXIgLT4gKi4uLiAtPiAqXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5udGhBcmcoMSkoJ2EnLCAnYicsICdjJyk7IC8vPT4gJ2InXG4gKiAgICAgIFIubnRoQXJnKC0xKSgnYScsICdiJywgJ2MnKTsgLy89PiAnYydcbiAqIEBzeW1iIFIubnRoQXJnKC0xKShhLCBiLCBjKSA9IGNcbiAqIEBzeW1iIFIubnRoQXJnKDApKGEsIGIsIGMpID0gYVxuICogQHN5bWIgUi5udGhBcmcoMSkoYSwgYiwgYykgPSBiXG4gKi9cblxudmFyIG50aEFyZyA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKGZ1bmN0aW9uIG50aEFyZyhuKSB7XG4gIHZhciBhcml0eSA9IG4gPCAwID8gMSA6IG4gKyAxO1xuICByZXR1cm4gY3VycnlOKGFyaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG50aChuLCBhcmd1bWVudHMpO1xuICB9KTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBudGhBcmc7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5My5qc1wiO1xuLyoqXG4gKiBgb2AgaXMgYSBjdXJyaWVkIGNvbXBvc2l0aW9uIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHVuYXJ5IGZ1bmN0aW9uLlxuICogTGlrZSBbYGNvbXBvc2VgXSgjY29tcG9zZSksIGBvYCBwZXJmb3JtcyByaWdodC10by1sZWZ0IGZ1bmN0aW9uIGNvbXBvc2l0aW9uLlxuICogVW5saWtlIFtgY29tcG9zZWBdKCNjb21wb3NlKSwgdGhlIHJpZ2h0bW9zdCBmdW5jdGlvbiBwYXNzZWQgdG8gYG9gIHdpbGwgYmVcbiAqIGludm9rZWQgd2l0aCBvbmx5IG9uZSBhcmd1bWVudC4gQWxzbywgdW5saWtlIFtgY29tcG9zZWBdKCNjb21wb3NlKSwgYG9gIGlzXG4gKiBsaW1pdGVkIHRvIGFjY2VwdGluZyBvbmx5IDIgdW5hcnkgZnVuY3Rpb25zLiBUaGUgbmFtZSBvIHdhcyBjaG9zZW4gYmVjYXVzZVxuICogb2YgaXRzIHNpbWlsYXJpdHkgdG8gdGhlIG1hdGhlbWF0aWNhbCBjb21wb3NpdGlvbiBvcGVyYXRvciDiiJguXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjQuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIChiIC0+IGMpIC0+IChhIC0+IGIpIC0+IGEgLT4gY1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIuY29tcG9zZSwgUi5waXBlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgY2xhc3N5R3JlZXRpbmcgPSBuYW1lID0+IFwiVGhlIG5hbWUncyBcIiArIG5hbWUubGFzdCArIFwiLCBcIiArIG5hbWUuZmlyc3QgKyBcIiBcIiArIG5hbWUubGFzdFxuICogICAgICBjb25zdCB5ZWxsR3JlZXRpbmcgPSBSLm8oUi50b1VwcGVyLCBjbGFzc3lHcmVldGluZyk7XG4gKiAgICAgIHllbGxHcmVldGluZyh7Zmlyc3Q6ICdKYW1lcycsIGxhc3Q6ICdCb25kJ30pOyAvLz0+IFwiVEhFIE5BTUUnUyBCT05ELCBKQU1FUyBCT05EXCJcbiAqXG4gKiAgICAgIFIubyhSLm11bHRpcGx5KDEwKSwgUi5hZGQoMTApKSgtNCkgLy89PiA2MFxuICpcbiAqIEBzeW1iIFIubyhmLCBnLCB4KSA9IGYoZyh4KSlcbiAqL1xuXG52YXIgbyA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKGZ1bmN0aW9uIG8oZiwgZywgeCkge1xuICByZXR1cm4gZihnKHgpKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBvOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vZih4KSB7XG4gIHJldHVybiBbeF07XG59IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5MS5qc1wiO1xuaW1wb3J0IF9vZiBmcm9tIFwiLi9pbnRlcm5hbC9fb2YuanNcIjtcbi8qKlxuICogUmV0dXJucyBhIHNpbmdsZXRvbiBhcnJheSBjb250YWluaW5nIHRoZSB2YWx1ZSBwcm92aWRlZC5cbiAqXG4gKiBOb3RlIHRoaXMgYG9mYCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgRVM2IGBvZmA7IFNlZVxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvb2ZcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4zLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBhIC0+IFthXVxuICogQHBhcmFtIHsqfSB4IGFueSB2YWx1ZVxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IHdyYXBwaW5nIGB4YC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLm9mKG51bGwpOyAvLz0+IFtudWxsXVxuICogICAgICBSLm9mKFs0Ml0pOyAvLz0+IFtbNDJdXVxuICovXG5cbnZhciBvZiA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKF9vZik7XG5cbmV4cG9ydCBkZWZhdWx0IG9mOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogUmV0dXJucyBhIHBhcnRpYWwgY29weSBvZiBhbiBvYmplY3Qgb21pdHRpbmcgdGhlIGtleXMgc3BlY2lmaWVkLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyBbU3RyaW5nXSAtPiB7U3RyaW5nOiAqfSAtPiB7U3RyaW5nOiAqfVxuICogQHBhcmFtIHtBcnJheX0gbmFtZXMgYW4gYXJyYXkgb2YgU3RyaW5nIHByb3BlcnR5IG5hbWVzIHRvIG9taXQgZnJvbSB0aGUgbmV3IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbVxuICogQHJldHVybiB7T2JqZWN0fSBBIG5ldyBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGZyb20gYG5hbWVzYCBub3Qgb24gaXQuXG4gKiBAc2VlIFIucGlja1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIub21pdChbJ2EnLCAnZCddLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHtiOiAyLCBjOiAzfVxuICovXG5cbnZhciBvbWl0ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gb21pdChuYW1lcywgb2JqKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIGluZGV4ID0ge307XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbmFtZXMubGVuZ3RoO1xuXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBpbmRleFtuYW1lc1tpZHhdXSA9IDE7XG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgIGlmICghaW5kZXguaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgIHJlc3VsdFtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IG9taXQ7IiwiaW1wb3J0IF9hcml0eSBmcm9tIFwiLi9pbnRlcm5hbC9fYXJpdHkuanNcIjtcbmltcG9ydCBfY3VycnkxIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTEuanNcIjtcbi8qKlxuICogQWNjZXB0cyBhIGZ1bmN0aW9uIGBmbmAgYW5kIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGd1YXJkcyBpbnZvY2F0aW9uIG9mXG4gKiBgZm5gIHN1Y2ggdGhhdCBgZm5gIGNhbiBvbmx5IGV2ZXIgYmUgY2FsbGVkIG9uY2UsIG5vIG1hdHRlciBob3cgbWFueSB0aW1lc1xuICogdGhlIHJldHVybmVkIGZ1bmN0aW9uIGlzIGludm9rZWQuIFRoZSBmaXJzdCB2YWx1ZSBjYWxjdWxhdGVkIGlzIHJldHVybmVkIGluXG4gKiBzdWJzZXF1ZW50IGludm9jYXRpb25zLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnIChhLi4uIC0+IGIpIC0+IChhLi4uIC0+IGIpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcCBpbiBhIGNhbGwtb25seS1vbmNlIHdyYXBwZXIuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHdyYXBwZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgYWRkT25lT25jZSA9IFIub25jZSh4ID0+IHggKyAxKTtcbiAqICAgICAgYWRkT25lT25jZSgxMCk7IC8vPT4gMTFcbiAqICAgICAgYWRkT25lT25jZShhZGRPbmVPbmNlKDUwKSk7IC8vPT4gMTFcbiAqL1xuXG52YXIgb25jZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKGZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICB2YXIgcmVzdWx0O1xuICByZXR1cm4gX2FyaXR5KGZuLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICByZXN1bHQgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IG9uY2U7IiwiaW1wb3J0IF9pc0Z1bmN0aW9uIGZyb20gXCIuL19pc0Z1bmN0aW9uLmpzXCI7XG5pbXBvcnQgX3RvU3RyaW5nIGZyb20gXCIuL190b1N0cmluZy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2Fzc2VydFByb21pc2UobmFtZSwgcCkge1xuICBpZiAocCA9PSBudWxsIHx8ICFfaXNGdW5jdGlvbihwLnRoZW4pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYCcgKyBuYW1lICsgJ2AgZXhwZWN0ZWQgYSBQcm9taXNlLCByZWNlaXZlZCAnICsgX3RvU3RyaW5nKHAsIFtdKSk7XG4gIH1cbn0iLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgX2Fzc2VydFByb21pc2UgZnJvbSBcIi4vaW50ZXJuYWwvX2Fzc2VydFByb21pc2UuanNcIjtcbi8qKlxuICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBvbkZhaWx1cmUgZnVuY3Rpb24gdG8gdGhlIHZhbHVlIGluc2lkZVxuICogYSBmYWlsZWQgcHJvbWlzZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGhhbmRsaW5nIHJlamVjdGVkIHByb21pc2VzXG4gKiBpbnNpZGUgZnVuY3Rpb24gY29tcG9zaXRpb25zLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjI2LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoZSAtPiBiKSAtPiAoUHJvbWlzZSBlIGEpIC0+IChQcm9taXNlIGUgYilcbiAqIEBzaWcgKGUgLT4gKFByb21pc2UgZiBiKSkgLT4gKFByb21pc2UgZSBhKSAtPiAoUHJvbWlzZSBmIGIpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZhaWx1cmUgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5LiBDYW4gcmV0dXJuIGEgdmFsdWUgb3IgYSBwcm9taXNlIG9mIGEgdmFsdWUuXG4gKiBAcGFyYW0ge1Byb21pc2V9IHBcbiAqIEByZXR1cm4ge1Byb21pc2V9IFRoZSByZXN1bHQgb2YgY2FsbGluZyBgcC50aGVuKG51bGwsIG9uRmFpbHVyZSlgXG4gKiBAc2VlIFIudGhlblxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBmYWlsZWRGZXRjaCA9IChpZCkgPT4gUHJvbWlzZS5yZWplY3QoJ2JhZCBJRCcpO1xuICogICAgICB2YXIgdXNlRGVmYXVsdCA9ICgpID0+ICh7IGZpcnN0TmFtZTogJ0JvYicsIGxhc3ROYW1lOiAnTG9ibGF3JyB9KVxuICpcbiAqICAgICAgLy9yZWNvdmVyRnJvbUZhaWx1cmUgOjogU3RyaW5nIC0+IFByb21pc2UgKHtmaXJzdE5hbWUsIGxhc3ROYW1lfSlcbiAqICAgICAgdmFyIHJlY292ZXJGcm9tRmFpbHVyZSA9IFIucGlwZShcbiAqICAgICAgICBmYWlsZWRGZXRjaCxcbiAqICAgICAgICBSLm90aGVyd2lzZSh1c2VEZWZhdWx0KSxcbiAqICAgICAgICBSLnRoZW4oUi5waWNrKFsnZmlyc3ROYW1lJywgJ2xhc3ROYW1lJ10pKSxcbiAqICAgICAgKTtcbiAqICAgICAgcmVjb3ZlckZyb21GYWlsdXJlKDEyMzQ1KS50aGVuKGNvbnNvbGUubG9nKVxuICovXG5cbnZhciBvdGhlcndpc2UgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBvdGhlcndpc2UoZiwgcCkge1xuICBfYXNzZXJ0UHJvbWlzZSgnb3RoZXJ3aXNlJywgcCk7XG5cbiAgcmV0dXJuIHAudGhlbihudWxsLCBmKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBvdGhlcndpc2U7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5My5qc1wiOyAvLyBgSWRlbnRpdHlgIGlzIGEgZnVuY3RvciB0aGF0IGhvbGRzIGEgc2luZ2xlIHZhbHVlLCB3aGVyZSBgbWFwYCBzaW1wbHlcbi8vIHRyYW5zZm9ybXMgdGhlIGhlbGQgdmFsdWUgd2l0aCB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG5cbnZhciBJZGVudGl0eSA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHgsXG4gICAgbWFwOiBmdW5jdGlvbiAoZikge1xuICAgICAgcmV0dXJuIElkZW50aXR5KGYoeCkpO1xuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBcInNldHRpbmdcIiB0aGUgcG9ydGlvbiBvZiB0aGUgZ2l2ZW4gZGF0YSBzdHJ1Y3R1cmVcbiAqIGZvY3VzZWQgYnkgdGhlIGdpdmVuIGxlbnMgdG8gdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgZ2l2ZW4gZnVuY3Rpb24gdG9cbiAqIHRoZSBmb2N1c2VkIHZhbHVlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE2LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEB0eXBlZGVmbiBMZW5zIHMgYSA9IEZ1bmN0b3IgZiA9PiAoYSAtPiBmIGEpIC0+IHMgLT4gZiBzXG4gKiBAc2lnIExlbnMgcyBhIC0+IChhIC0+IGEpIC0+IHMgLT4gc1xuICogQHBhcmFtIHtMZW5zfSBsZW5zXG4gKiBAcGFyYW0geyp9IHZcbiAqIEBwYXJhbSB7Kn0geFxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5wcm9wLCBSLmxlbnNJbmRleCwgUi5sZW5zUHJvcFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGhlYWRMZW5zID0gUi5sZW5zSW5kZXgoMCk7XG4gKlxuICogICAgICBSLm92ZXIoaGVhZExlbnMsIFIudG9VcHBlciwgWydmb28nLCAnYmFyJywgJ2JheiddKTsgLy89PiBbJ0ZPTycsICdiYXInLCAnYmF6J11cbiAqL1xuXG5cbnZhciBvdmVyID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTMoZnVuY3Rpb24gb3ZlcihsZW5zLCBmLCB4KSB7XG4gIC8vIFRoZSB2YWx1ZSByZXR1cm5lZCBieSB0aGUgZ2V0dGVyIGZ1bmN0aW9uIGlzIGZpcnN0IHRyYW5zZm9ybWVkIHdpdGggYGZgLFxuICAvLyB0aGVuIHNldCBhcyB0aGUgdmFsdWUgb2YgYW4gYElkZW50aXR5YC4gVGhpcyBpcyB0aGVuIG1hcHBlZCBvdmVyIHdpdGggdGhlXG4gIC8vIHNldHRlciBmdW5jdGlvbiBvZiB0aGUgbGVucy5cbiAgcmV0dXJuIGxlbnMoZnVuY3Rpb24gKHkpIHtcbiAgICByZXR1cm4gSWRlbnRpdHkoZih5KSk7XG4gIH0pKHgpLnZhbHVlO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IG92ZXI7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuLyoqXG4gKiBUYWtlcyB0d28gYXJndW1lbnRzLCBgZnN0YCBhbmQgYHNuZGAsIGFuZCByZXR1cm5zIGBbZnN0LCBzbmRdYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOC4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBhIC0+IGIgLT4gKGEsYilcbiAqIEBwYXJhbSB7Kn0gZnN0XG4gKiBAcGFyYW0geyp9IHNuZFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAc2VlIFIub2JqT2YsIFIub2ZcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnBhaXIoJ2ZvbycsICdiYXInKTsgLy89PiBbJ2ZvbycsICdiYXInXVxuICovXG5cbnZhciBwYWlyID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gcGFpcihmc3QsIHNuZCkge1xuICByZXR1cm4gW2ZzdCwgc25kXTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBwYWlyOyIsImltcG9ydCBfYXJpdHkgZnJvbSBcIi4vX2FyaXR5LmpzXCI7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9fY3VycnkyLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY3JlYXRlUGFydGlhbEFwcGxpY2F0b3IoY29uY2F0KSB7XG4gIHJldHVybiBfY3VycnkyKGZ1bmN0aW9uIChmbiwgYXJncykge1xuICAgIHJldHVybiBfYXJpdHkoTWF0aC5tYXgoMCwgZm4ubGVuZ3RoIC0gYXJncy5sZW5ndGgpLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgY29uY2F0KGFyZ3MsIGFyZ3VtZW50cykpO1xuICAgIH0pO1xuICB9KTtcbn0iLCJpbXBvcnQgX2NvbmNhdCBmcm9tIFwiLi9pbnRlcm5hbC9fY29uY2F0LmpzXCI7XG5pbXBvcnQgX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yIGZyb20gXCIuL2ludGVybmFsL19jcmVhdGVQYXJ0aWFsQXBwbGljYXRvci5qc1wiO1xuLyoqXG4gKiBUYWtlcyBhIGZ1bmN0aW9uIGBmYCBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cywgYW5kIHJldHVybnMgYSBmdW5jdGlvbiBgZ2AuXG4gKiBXaGVuIGFwcGxpZWQsIGBnYCByZXR1cm5zIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYGZgIHRvIHRoZSBhcmd1bWVudHNcbiAqIHByb3ZpZGVkIGluaXRpYWxseSBmb2xsb3dlZCBieSB0aGUgYXJndW1lbnRzIHByb3ZpZGVkIHRvIGBnYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKChhLCBiLCBjLCAuLi4sIG4pIC0+IHgpIC0+IFthLCBiLCBjLCAuLi5dIC0+ICgoZCwgZSwgZiwgLi4uLCBuKSAtPiB4KVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZlxuICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIucGFydGlhbFJpZ2h0LCBSLmN1cnJ5XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgbXVsdGlwbHkyID0gKGEsIGIpID0+IGEgKiBiO1xuICogICAgICBjb25zdCBkb3VibGUgPSBSLnBhcnRpYWwobXVsdGlwbHkyLCBbMl0pO1xuICogICAgICBkb3VibGUoMik7IC8vPT4gNFxuICpcbiAqICAgICAgY29uc3QgZ3JlZXQgPSAoc2FsdXRhdGlvbiwgdGl0bGUsIGZpcnN0TmFtZSwgbGFzdE5hbWUpID0+XG4gKiAgICAgICAgc2FsdXRhdGlvbiArICcsICcgKyB0aXRsZSArICcgJyArIGZpcnN0TmFtZSArICcgJyArIGxhc3ROYW1lICsgJyEnO1xuICpcbiAqICAgICAgY29uc3Qgc2F5SGVsbG8gPSBSLnBhcnRpYWwoZ3JlZXQsIFsnSGVsbG8nXSk7XG4gKiAgICAgIGNvbnN0IHNheUhlbGxvVG9NcyA9IFIucGFydGlhbChzYXlIZWxsbywgWydNcy4nXSk7XG4gKiAgICAgIHNheUhlbGxvVG9NcygnSmFuZScsICdKb25lcycpOyAvLz0+ICdIZWxsbywgTXMuIEphbmUgSm9uZXMhJ1xuICogQHN5bWIgUi5wYXJ0aWFsKGYsIFthLCBiXSkoYywgZCkgPSBmKGEsIGIsIGMsIGQpXG4gKi9cblxudmFyIHBhcnRpYWwgPVxuLyojX19QVVJFX18qL1xuX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yKF9jb25jYXQpO1xuXG5leHBvcnQgZGVmYXVsdCBwYXJ0aWFsOyIsImltcG9ydCBfY29uY2F0IGZyb20gXCIuL2ludGVybmFsL19jb25jYXQuanNcIjtcbmltcG9ydCBfY3JlYXRlUGFydGlhbEFwcGxpY2F0b3IgZnJvbSBcIi4vaW50ZXJuYWwvX2NyZWF0ZVBhcnRpYWxBcHBsaWNhdG9yLmpzXCI7XG5pbXBvcnQgZmxpcCBmcm9tIFwiLi9mbGlwLmpzXCI7XG4vKipcbiAqIFRha2VzIGEgZnVuY3Rpb24gYGZgIGFuZCBhIGxpc3Qgb2YgYXJndW1lbnRzLCBhbmQgcmV0dXJucyBhIGZ1bmN0aW9uIGBnYC5cbiAqIFdoZW4gYXBwbGllZCwgYGdgIHJldHVybnMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBgZmAgdG8gdGhlIGFyZ3VtZW50c1xuICogcHJvdmlkZWQgdG8gYGdgIGZvbGxvd2VkIGJ5IHRoZSBhcmd1bWVudHMgcHJvdmlkZWQgaW5pdGlhbGx5LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKGEsIGIsIGMsIC4uLiwgbikgLT4geCkgLT4gW2QsIGUsIGYsIC4uLiwgbl0gLT4gKChhLCBiLCBjLCAuLi4pIC0+IHgpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzZWUgUi5wYXJ0aWFsXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgZ3JlZXQgPSAoc2FsdXRhdGlvbiwgdGl0bGUsIGZpcnN0TmFtZSwgbGFzdE5hbWUpID0+XG4gKiAgICAgICAgc2FsdXRhdGlvbiArICcsICcgKyB0aXRsZSArICcgJyArIGZpcnN0TmFtZSArICcgJyArIGxhc3ROYW1lICsgJyEnO1xuICpcbiAqICAgICAgY29uc3QgZ3JlZXRNc0phbmVKb25lcyA9IFIucGFydGlhbFJpZ2h0KGdyZWV0LCBbJ01zLicsICdKYW5lJywgJ0pvbmVzJ10pO1xuICpcbiAqICAgICAgZ3JlZXRNc0phbmVKb25lcygnSGVsbG8nKTsgLy89PiAnSGVsbG8sIE1zLiBKYW5lIEpvbmVzISdcbiAqIEBzeW1iIFIucGFydGlhbFJpZ2h0KGYsIFthLCBiXSkoYywgZCkgPSBmKGMsIGQsIGEsIGIpXG4gKi9cblxudmFyIHBhcnRpYWxSaWdodCA9XG4vKiNfX1BVUkVfXyovXG5fY3JlYXRlUGFydGlhbEFwcGxpY2F0b3IoXG4vKiNfX1BVUkVfXyovXG5mbGlwKF9jb25jYXQpKTtcblxuZXhwb3J0IGRlZmF1bHQgcGFydGlhbFJpZ2h0OyIsImltcG9ydCBmaWx0ZXIgZnJvbSBcIi4vZmlsdGVyLmpzXCI7XG5pbXBvcnQganV4dCBmcm9tIFwiLi9qdXh0LmpzXCI7XG5pbXBvcnQgcmVqZWN0IGZyb20gXCIuL3JlamVjdC5qc1wiO1xuLyoqXG4gKiBUYWtlcyBhIHByZWRpY2F0ZSBhbmQgYSBsaXN0IG9yIG90aGVyIGBGaWx0ZXJhYmxlYCBvYmplY3QgYW5kIHJldHVybnMgdGhlXG4gKiBwYWlyIG9mIGZpbHRlcmFibGUgb2JqZWN0cyBvZiB0aGUgc2FtZSB0eXBlIG9mIGVsZW1lbnRzIHdoaWNoIGRvIGFuZCBkbyBub3RcbiAqIHNhdGlzZnksIHRoZSBwcmVkaWNhdGUsIHJlc3BlY3RpdmVseS4gRmlsdGVyYWJsZSBvYmplY3RzIGluY2x1ZGUgcGxhaW4gb2JqZWN0cyBvciBhbnkgb2JqZWN0XG4gKiB0aGF0IGhhcyBhIGZpbHRlciBtZXRob2Qgc3VjaCBhcyBgQXJyYXlgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuNFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgRmlsdGVyYWJsZSBmID0+IChhIC0+IEJvb2xlYW4pIC0+IGYgYSAtPiBbZiBhLCBmIGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHRvIGRldGVybWluZSB3aGljaCBzaWRlIHRoZSBlbGVtZW50IGJlbG9uZ3MgdG8uXG4gKiBAcGFyYW0ge0FycmF5fSBmaWx0ZXJhYmxlIHRoZSBsaXN0IChvciBvdGhlciBmaWx0ZXJhYmxlKSB0byBwYXJ0aXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXksIGNvbnRhaW5pbmcgZmlyc3QgdGhlIHN1YnNldCBvZiBlbGVtZW50cyB0aGF0IHNhdGlzZnkgdGhlXG4gKiAgICAgICAgIHByZWRpY2F0ZSwgYW5kIHNlY29uZCB0aGUgc3Vic2V0IG9mIGVsZW1lbnRzIHRoYXQgZG8gbm90IHNhdGlzZnkuXG4gKiBAc2VlIFIuZmlsdGVyLCBSLnJlamVjdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucGFydGl0aW9uKFIuaW5jbHVkZXMoJ3MnKSwgWydzc3MnLCAndHR0JywgJ2ZvbycsICdiYXJzJ10pO1xuICogICAgICAvLyA9PiBbIFsgJ3NzcycsICdiYXJzJyBdLCAgWyAndHR0JywgJ2ZvbycgXSBdXG4gKlxuICogICAgICBSLnBhcnRpdGlvbihSLmluY2x1ZGVzKCdzJyksIHsgYTogJ3NzcycsIGI6ICd0dHQnLCBmb286ICdiYXJzJyB9KTtcbiAqICAgICAgLy8gPT4gWyB7IGE6ICdzc3MnLCBmb286ICdiYXJzJyB9LCB7IGI6ICd0dHQnIH0gIF1cbiAqL1xuXG52YXIgcGFydGl0aW9uID1cbi8qI19fUFVSRV9fKi9cbmp1eHQoW2ZpbHRlciwgcmVqZWN0XSk7XG5leHBvcnQgZGVmYXVsdCBwYXJ0aXRpb247IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5My5qc1wiO1xuaW1wb3J0IGVxdWFscyBmcm9tIFwiLi9lcXVhbHMuanNcIjtcbmltcG9ydCBwYXRoIGZyb20gXCIuL3BhdGguanNcIjtcbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgbmVzdGVkIHBhdGggb24gYW4gb2JqZWN0IGhhcyBhIHNwZWNpZmljIHZhbHVlLCBpblxuICogW2BSLmVxdWFsc2BdKCNlcXVhbHMpIHRlcm1zLiBNb3N0IGxpa2VseSB1c2VkIHRvIGZpbHRlciBhIGxpc3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNy4wXG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEB0eXBlZGVmbiBJZHggPSBTdHJpbmcgfCBJbnRcbiAqIEBzaWcgW0lkeF0gLT4gYSAtPiB7YX0gLT4gQm9vbGVhblxuICogQHBhcmFtIHtBcnJheX0gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbmVzdGVkIHByb3BlcnR5IHRvIHVzZVxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHZhbHVlIHRvIGNvbXBhcmUgdGhlIG5lc3RlZCBwcm9wZXJ0eSB3aXRoXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY2hlY2sgdGhlIG5lc3RlZCBwcm9wZXJ0eSBpblxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBlcXVhbHMgdGhlIG5lc3RlZCBvYmplY3QgcHJvcGVydHksXG4gKiAgICAgICAgIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IHVzZXIxID0geyBhZGRyZXNzOiB7IHppcENvZGU6IDkwMjEwIH0gfTtcbiAqICAgICAgY29uc3QgdXNlcjIgPSB7IGFkZHJlc3M6IHsgemlwQ29kZTogNTU1NTUgfSB9O1xuICogICAgICBjb25zdCB1c2VyMyA9IHsgbmFtZTogJ0JvYicgfTtcbiAqICAgICAgY29uc3QgdXNlcnMgPSBbIHVzZXIxLCB1c2VyMiwgdXNlcjMgXTtcbiAqICAgICAgY29uc3QgaXNGYW1vdXMgPSBSLnBhdGhFcShbJ2FkZHJlc3MnLCAnemlwQ29kZSddLCA5MDIxMCk7XG4gKiAgICAgIFIuZmlsdGVyKGlzRmFtb3VzLCB1c2Vycyk7IC8vPT4gWyB1c2VyMSBdXG4gKi9cblxudmFyIHBhdGhFcSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKGZ1bmN0aW9uIHBhdGhFcShfcGF0aCwgdmFsLCBvYmopIHtcbiAgcmV0dXJuIGVxdWFscyhwYXRoKF9wYXRoLCBvYmopLCB2YWwpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHBhdGhFcTsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkzLmpzXCI7XG5pbXBvcnQgZGVmYXVsdFRvIGZyb20gXCIuL2RlZmF1bHRUby5qc1wiO1xuaW1wb3J0IHBhdGggZnJvbSBcIi4vcGF0aC5qc1wiO1xuLyoqXG4gKiBJZiB0aGUgZ2l2ZW4sIG5vbi1udWxsIG9iamVjdCBoYXMgYSB2YWx1ZSBhdCB0aGUgZ2l2ZW4gcGF0aCwgcmV0dXJucyB0aGVcbiAqIHZhbHVlIGF0IHRoYXQgcGF0aC4gT3RoZXJ3aXNlIHJldHVybnMgdGhlIHByb3ZpZGVkIGRlZmF1bHQgdmFsdWUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTguMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHR5cGVkZWZuIElkeCA9IFN0cmluZyB8IEludFxuICogQHNpZyBhIC0+IFtJZHhdIC0+IHthfSAtPiBhXG4gKiBAcGFyYW0geyp9IGQgVGhlIGRlZmF1bHQgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBwIFRoZSBwYXRoIHRvIHVzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byByZXRyaWV2ZSB0aGUgbmVzdGVkIHByb3BlcnR5IGZyb20uXG4gKiBAcmV0dXJuIHsqfSBUaGUgZGF0YSBhdCBgcGF0aGAgb2YgdGhlIHN1cHBsaWVkIG9iamVjdCBvciB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnBhdGhPcignTi9BJywgWydhJywgJ2InXSwge2E6IHtiOiAyfX0pOyAvLz0+IDJcbiAqICAgICAgUi5wYXRoT3IoJ04vQScsIFsnYScsICdiJ10sIHtjOiB7YjogMn19KTsgLy89PiBcIk4vQVwiXG4gKi9cblxudmFyIHBhdGhPciA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKGZ1bmN0aW9uIHBhdGhPcihkLCBwLCBvYmopIHtcbiAgcmV0dXJuIGRlZmF1bHRUbyhkLCBwYXRoKHAsIG9iaikpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHBhdGhPcjsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkzLmpzXCI7XG5pbXBvcnQgcGF0aCBmcm9tIFwiLi9wYXRoLmpzXCI7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IHByb3BlcnR5IGF0IGdpdmVuIHBhdGggc2F0aXNmaWVzIHRoZVxuICogZ2l2ZW4gcHJlZGljYXRlOyBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEB0eXBlZGVmbiBJZHggPSBTdHJpbmcgfCBJbnRcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gW0lkeF0gLT4ge2F9IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BQYXRoXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5wcm9wU2F0aXNmaWVzLCBSLnBhdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnBhdGhTYXRpc2ZpZXMoeSA9PiB5ID4gMCwgWyd4JywgJ3knXSwge3g6IHt5OiAyfX0pOyAvLz0+IHRydWVcbiAqICAgICAgUi5wYXRoU2F0aXNmaWVzKFIuaXMoT2JqZWN0KSwgW10sIHt4OiB7eTogMn19KTsgLy89PiB0cnVlXG4gKi9cblxudmFyIHBhdGhTYXRpc2ZpZXMgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MyhmdW5jdGlvbiBwYXRoU2F0aXNmaWVzKHByZWQsIHByb3BQYXRoLCBvYmopIHtcbiAgcmV0dXJuIHByZWQocGF0aChwcm9wUGF0aCwgb2JqKSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcGF0aFNhdGlzZmllczsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG4vKipcbiAqIFJldHVybnMgYSBwYXJ0aWFsIGNvcHkgb2YgYW4gb2JqZWN0IGNvbnRhaW5pbmcgb25seSB0aGUga2V5cyBzcGVjaWZpZWQuIElmXG4gKiB0aGUga2V5IGRvZXMgbm90IGV4aXN0LCB0aGUgcHJvcGVydHkgaXMgaWdub3JlZC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBzaWcgW2tdIC0+IHtrOiB2fSAtPiB7azogdn1cbiAqIEBwYXJhbSB7QXJyYXl9IG5hbWVzIGFuIGFycmF5IG9mIFN0cmluZyBwcm9wZXJ0eSBuYW1lcyB0byBjb3B5IG9udG8gYSBuZXcgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY29weSBmcm9tXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCB3aXRoIG9ubHkgcHJvcGVydGllcyBmcm9tIGBuYW1lc2Agb24gaXQuXG4gKiBAc2VlIFIub21pdCwgUi5wcm9wc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucGljayhbJ2EnLCAnZCddLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHthOiAxLCBkOiA0fVxuICogICAgICBSLnBpY2soWydhJywgJ2UnLCAnZiddLCB7YTogMSwgYjogMiwgYzogMywgZDogNH0pOyAvLz0+IHthOiAxfVxuICovXG5cbnZhciBwaWNrID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gcGljayhuYW1lcywgb2JqKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIGlkeCA9IDA7XG5cbiAgd2hpbGUgKGlkeCA8IG5hbWVzLmxlbmd0aCkge1xuICAgIGlmIChuYW1lc1tpZHhdIGluIG9iaikge1xuICAgICAgcmVzdWx0W25hbWVzW2lkeF1dID0gb2JqW25hbWVzW2lkeF1dO1xuICAgIH1cblxuICAgIGlkeCArPSAxO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBwaWNrOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogU2ltaWxhciB0byBgcGlja2AgZXhjZXB0IHRoYXQgdGhpcyBvbmUgaW5jbHVkZXMgYSBga2V5OiB1bmRlZmluZWRgIHBhaXIgZm9yXG4gKiBwcm9wZXJ0aWVzIHRoYXQgZG9uJ3QgZXhpc3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIFtrXSAtPiB7azogdn0gLT4ge2s6IHZ9XG4gKiBAcGFyYW0ge0FycmF5fSBuYW1lcyBhbiBhcnJheSBvZiBTdHJpbmcgcHJvcGVydHkgbmFtZXMgdG8gY29weSBvbnRvIGEgbmV3IG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgZnJvbVxuICogQHJldHVybiB7T2JqZWN0fSBBIG5ldyBvYmplY3Qgd2l0aCBvbmx5IHByb3BlcnRpZXMgZnJvbSBgbmFtZXNgIG9uIGl0LlxuICogQHNlZSBSLnBpY2tcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnBpY2tBbGwoWydhJywgJ2QnXSwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YTogMSwgZDogNH1cbiAqICAgICAgUi5waWNrQWxsKFsnYScsICdlJywgJ2YnXSwge2E6IDEsIGI6IDIsIGM6IDMsIGQ6IDR9KTsgLy89PiB7YTogMSwgZTogdW5kZWZpbmVkLCBmOiB1bmRlZmluZWR9XG4gKi9cblxudmFyIHBpY2tBbGwgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBwaWNrQWxsKG5hbWVzLCBvYmopIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IG5hbWVzLmxlbmd0aDtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgdmFyIG5hbWUgPSBuYW1lc1tpZHhdO1xuICAgIHJlc3VsdFtuYW1lXSA9IG9ialtuYW1lXTtcbiAgICBpZHggKz0gMTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcGlja0FsbDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG4vKipcbiAqIFJldHVybnMgYSBwYXJ0aWFsIGNvcHkgb2YgYW4gb2JqZWN0IGNvbnRhaW5pbmcgb25seSB0aGUga2V5cyB0aGF0IHNhdGlzZnlcbiAqIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnICgodiwgaykgLT4gQm9vbGVhbikgLT4ge2s6IHZ9IC0+IHtrOiB2fVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBBIHByZWRpY2F0ZSB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgYSBrZXlcbiAqICAgICAgICBzaG91bGQgYmUgaW5jbHVkZWQgb24gdGhlIG91dHB1dCBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gY29weSBmcm9tXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgbmV3IG9iamVjdCB3aXRoIG9ubHkgcHJvcGVydGllcyB0aGF0IHNhdGlzZnkgYHByZWRgXG4gKiAgICAgICAgIG9uIGl0LlxuICogQHNlZSBSLnBpY2ssIFIuZmlsdGVyXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgaXNVcHBlckNhc2UgPSAodmFsLCBrZXkpID0+IGtleS50b1VwcGVyQ2FzZSgpID09PSBrZXk7XG4gKiAgICAgIFIucGlja0J5KGlzVXBwZXJDYXNlLCB7YTogMSwgYjogMiwgQTogMywgQjogNH0pOyAvLz0+IHtBOiAzLCBCOiA0fVxuICovXG5cbnZhciBwaWNrQnkgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBwaWNrQnkodGVzdCwgb2JqKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgIGlmICh0ZXN0KG9ialtwcm9wXSwgcHJvcCwgb2JqKSkge1xuICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcGlja0J5OyIsImltcG9ydCBjb21wb3NlSyBmcm9tIFwiLi9jb21wb3NlSy5qc1wiO1xuaW1wb3J0IHJldmVyc2UgZnJvbSBcIi4vcmV2ZXJzZS5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBsZWZ0LXRvLXJpZ2h0IEtsZWlzbGkgY29tcG9zaXRpb24gb2YgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyxcbiAqIGVhY2ggb2Ygd2hpY2ggbXVzdCByZXR1cm4gYSB2YWx1ZSBvZiBhIHR5cGUgc3VwcG9ydGVkIGJ5IFtgY2hhaW5gXSgjY2hhaW4pLlxuICpcbiAqIGBSLnBpcGVLKGYsIGcsIGgpYCBpcyBlcXVpdmFsZW50IHRvIGBSLnBpcGUoZiwgUi5jaGFpbihnKSwgUi5jaGFpbihoKSlgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE2LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyBDaGFpbiBtID0+ICgoYSAtPiBtIGIpLCAoYiAtPiBtIGMpLCAuLi4sICh5IC0+IG0geikpIC0+IChhIC0+IG0geilcbiAqIEBwYXJhbSB7Li4uRnVuY3Rpb259XG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBzZWUgUi5jb21wb3NlS1xuICogQGRlcHJlY2F0ZWQgc2luY2UgdjAuMjYuMFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIC8vICBwYXJzZUpzb24gOjogU3RyaW5nIC0+IE1heWJlICpcbiAqICAgICAgLy8gIGdldCA6OiBTdHJpbmcgLT4gT2JqZWN0IC0+IE1heWJlICpcbiAqXG4gKiAgICAgIC8vICBnZXRTdGF0ZUNvZGUgOjogTWF5YmUgU3RyaW5nIC0+IE1heWJlIFN0cmluZ1xuICogICAgICBjb25zdCBnZXRTdGF0ZUNvZGUgPSBSLnBpcGVLKFxuICogICAgICAgIHBhcnNlSnNvbixcbiAqICAgICAgICBnZXQoJ3VzZXInKSxcbiAqICAgICAgICBnZXQoJ2FkZHJlc3MnKSxcbiAqICAgICAgICBnZXQoJ3N0YXRlJyksXG4gKiAgICAgICAgUi5jb21wb3NlKE1heWJlLm9mLCBSLnRvVXBwZXIpXG4gKiAgICAgICk7XG4gKlxuICogICAgICBnZXRTdGF0ZUNvZGUoJ3tcInVzZXJcIjp7XCJhZGRyZXNzXCI6e1wic3RhdGVcIjpcIm55XCJ9fX0nKTtcbiAqICAgICAgLy89PiBKdXN0KCdOWScpXG4gKiAgICAgIGdldFN0YXRlQ29kZSgnW0ludmFsaWQgSlNPTl0nKTtcbiAqICAgICAgLy89PiBOb3RoaW5nKClcbiAqIEBzeW1iIFIucGlwZUsoZiwgZywgaCkoYSkgPSBSLmNoYWluKGgsIFIuY2hhaW4oZywgZihhKSkpXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGlwZUsoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwaXBlSyByZXF1aXJlcyBhdCBsZWFzdCBvbmUgYXJndW1lbnQnKTtcbiAgfVxuXG4gIHJldHVybiBjb21wb3NlSy5hcHBseSh0aGlzLCByZXZlcnNlKGFyZ3VtZW50cykpO1xufSIsImltcG9ydCBfY29uY2F0IGZyb20gXCIuL2ludGVybmFsL19jb25jYXQuanNcIjtcbmltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IHdpdGggdGhlIGdpdmVuIGVsZW1lbnQgYXQgdGhlIGZyb250LCBmb2xsb3dlZCBieSB0aGVcbiAqIGNvbnRlbnRzIG9mIHRoZSBsaXN0LlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgYSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0geyp9IGVsIFRoZSBpdGVtIHRvIGFkZCB0byB0aGUgaGVhZCBvZiB0aGUgb3V0cHV0IGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBhZGQgdG8gdGhlIHRhaWwgb2YgdGhlIG91dHB1dCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5LlxuICogQHNlZSBSLmFwcGVuZFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucHJlcGVuZCgnZmVlJywgWydmaScsICdmbycsICdmdW0nXSk7IC8vPT4gWydmZWUnLCAnZmknLCAnZm8nLCAnZnVtJ11cbiAqL1xuXG52YXIgcHJlcGVuZCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIHByZXBlbmQoZWwsIGxpc3QpIHtcbiAgcmV0dXJuIF9jb25jYXQoW2VsXSwgbGlzdCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcHJlcGVuZDsiLCJpbXBvcnQgbXVsdGlwbHkgZnJvbSBcIi4vbXVsdGlwbHkuanNcIjtcbmltcG9ydCByZWR1Y2UgZnJvbSBcIi4vcmVkdWNlLmpzXCI7XG4vKipcbiAqIE11bHRpcGxpZXMgdG9nZXRoZXIgYWxsIHRoZSBlbGVtZW50cyBvZiBhIGxpc3QuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHNpZyBbTnVtYmVyXSAtPiBOdW1iZXJcbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgQW4gYXJyYXkgb2YgbnVtYmVyc1xuICogQHJldHVybiB7TnVtYmVyfSBUaGUgcHJvZHVjdCBvZiBhbGwgdGhlIG51bWJlcnMgaW4gdGhlIGxpc3QuXG4gKiBAc2VlIFIucmVkdWNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5wcm9kdWN0KFsyLDQsNiw4LDEwMCwxXSk7IC8vPT4gMzg0MDBcbiAqL1xuXG52YXIgcHJvZHVjdCA9XG4vKiNfX1BVUkVfXyovXG5yZWR1Y2UobXVsdGlwbHksIDEpO1xuZXhwb3J0IGRlZmF1bHQgcHJvZHVjdDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgY3VycnlOIGZyb20gXCIuL2N1cnJ5Ti5qc1wiO1xuLyoqXG4gKiBBY2NlcHRzIGEgZnVuY3Rpb24gYGZuYCBhbmQgYSBsaXN0IG9mIHRyYW5zZm9ybWVyIGZ1bmN0aW9ucyBhbmQgcmV0dXJucyBhXG4gKiBuZXcgY3VycmllZCBmdW5jdGlvbi4gV2hlbiB0aGUgbmV3IGZ1bmN0aW9uIGlzIGludm9rZWQsIGl0IGNhbGxzIHRoZVxuICogZnVuY3Rpb24gYGZuYCB3aXRoIHBhcmFtZXRlcnMgY29uc2lzdGluZyBvZiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgZWFjaFxuICogc3VwcGxpZWQgaGFuZGxlciBvbiBzdWNjZXNzaXZlIGFyZ3VtZW50cyB0byB0aGUgbmV3IGZ1bmN0aW9uLlxuICpcbiAqIElmIG1vcmUgYXJndW1lbnRzIGFyZSBwYXNzZWQgdG8gdGhlIHJldHVybmVkIGZ1bmN0aW9uIHRoYW4gdHJhbnNmb3JtZXJcbiAqIGZ1bmN0aW9ucywgdGhvc2UgYXJndW1lbnRzIGFyZSBwYXNzZWQgZGlyZWN0bHkgdG8gYGZuYCBhcyBhZGRpdGlvbmFsXG4gKiBwYXJhbWV0ZXJzLiBJZiB5b3UgZXhwZWN0IGFkZGl0aW9uYWwgYXJndW1lbnRzIHRoYXQgZG9uJ3QgbmVlZCB0byBiZVxuICogdHJhbnNmb3JtZWQsIGFsdGhvdWdoIHlvdSBjYW4gaWdub3JlIHRoZW0sIGl0J3MgYmVzdCB0byBwYXNzIGFuIGlkZW50aXR5XG4gKiBmdW5jdGlvbiBzbyB0aGF0IHRoZSBuZXcgZnVuY3Rpb24gcmVwb3J0cyB0aGUgY29ycmVjdCBhcml0eS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoKHgxLCB4MiwgLi4uKSAtPiB6KSAtPiBbKGEgLT4geDEpLCAoYiAtPiB4MiksIC4uLl0gLT4gKGEgLT4gYiAtPiAuLi4gLT4geilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtZXJzIEEgbGlzdCBvZiB0cmFuc2Zvcm1lciBmdW5jdGlvbnNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgd3JhcHBlZCBmdW5jdGlvbi5cbiAqIEBzZWUgUi5jb252ZXJnZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudXNlV2l0aChNYXRoLnBvdywgW1IuaWRlbnRpdHksIFIuaWRlbnRpdHldKSgzLCA0KTsgLy89PiA4MVxuICogICAgICBSLnVzZVdpdGgoTWF0aC5wb3csIFtSLmlkZW50aXR5LCBSLmlkZW50aXR5XSkoMykoNCk7IC8vPT4gODFcbiAqICAgICAgUi51c2VXaXRoKE1hdGgucG93LCBbUi5kZWMsIFIuaW5jXSkoMywgNCk7IC8vPT4gMzJcbiAqICAgICAgUi51c2VXaXRoKE1hdGgucG93LCBbUi5kZWMsIFIuaW5jXSkoMykoNCk7IC8vPT4gMzJcbiAqIEBzeW1iIFIudXNlV2l0aChmLCBbZywgaF0pKGEsIGIpID0gZihnKGEpLCBoKGIpKVxuICovXG5cbnZhciB1c2VXaXRoID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gdXNlV2l0aChmbiwgdHJhbnNmb3JtZXJzKSB7XG4gIHJldHVybiBjdXJyeU4odHJhbnNmb3JtZXJzLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGlkeCA9IDA7XG5cbiAgICB3aGlsZSAoaWR4IDwgdHJhbnNmb3JtZXJzLmxlbmd0aCkge1xuICAgICAgYXJncy5wdXNoKHRyYW5zZm9ybWVyc1tpZHhdLmNhbGwodGhpcywgYXJndW1lbnRzW2lkeF0pKTtcbiAgICAgIGlkeCArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIHRyYW5zZm9ybWVycy5sZW5ndGgpKSk7XG4gIH0pO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHVzZVdpdGg7IiwiaW1wb3J0IF9tYXAgZnJvbSBcIi4vaW50ZXJuYWwvX21hcC5qc1wiO1xuaW1wb3J0IGlkZW50aXR5IGZyb20gXCIuL2lkZW50aXR5LmpzXCI7XG5pbXBvcnQgcGlja0FsbCBmcm9tIFwiLi9waWNrQWxsLmpzXCI7XG5pbXBvcnQgdXNlV2l0aCBmcm9tIFwiLi91c2VXaXRoLmpzXCI7XG4vKipcbiAqIFJlYXNvbmFibGUgYW5hbG9nIHRvIFNRTCBgc2VsZWN0YCBzdGF0ZW1lbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAY2F0ZWdvcnkgUmVsYXRpb25cbiAqIEBzaWcgW2tdIC0+IFt7azogdn1dIC0+IFt7azogdn1dXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gcHJvamVjdFxuICogQHBhcmFtIHtBcnJheX0gb2JqcyBUaGUgb2JqZWN0cyB0byBxdWVyeVxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBqdXN0IHRoZSBgcHJvcHNgIHByb3BlcnRpZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgYWJieSA9IHtuYW1lOiAnQWJieScsIGFnZTogNywgaGFpcjogJ2Jsb25kJywgZ3JhZGU6IDJ9O1xuICogICAgICBjb25zdCBmcmVkID0ge25hbWU6ICdGcmVkJywgYWdlOiAxMiwgaGFpcjogJ2Jyb3duJywgZ3JhZGU6IDd9O1xuICogICAgICBjb25zdCBraWRzID0gW2FiYnksIGZyZWRdO1xuICogICAgICBSLnByb2plY3QoWyduYW1lJywgJ2dyYWRlJ10sIGtpZHMpOyAvLz0+IFt7bmFtZTogJ0FiYnknLCBncmFkZTogMn0sIHtuYW1lOiAnRnJlZCcsIGdyYWRlOiA3fV1cbiAqL1xuXG52YXIgcHJvamVjdCA9XG4vKiNfX1BVUkVfXyovXG51c2VXaXRoKF9tYXAsIFtwaWNrQWxsLCBpZGVudGl0eV0pOyAvLyBwYXNzaW5nIGBpZGVudGl0eWAgZ2l2ZXMgY29ycmVjdCBhcml0eVxuXG5leHBvcnQgZGVmYXVsdCBwcm9qZWN0OyIsImltcG9ydCBfY3VycnkzIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTMuanNcIjtcbmltcG9ydCBlcXVhbHMgZnJvbSBcIi4vZXF1YWxzLmpzXCI7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IHByb3BlcnR5IGlzIGVxdWFsLCBpblxuICogW2BSLmVxdWFsc2BdKCNlcXVhbHMpIHRlcm1zLCB0byB0aGUgZ2l2ZW4gdmFsdWU7IGBmYWxzZWAgb3RoZXJ3aXNlLlxuICogWW91IGNhbiB0ZXN0IG11bHRpcGxlIHByb3BlcnRpZXMgd2l0aCBbYFIud2hlcmVFcWBdKCN3aGVyZUVxKS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBTdHJpbmcgLT4gYSAtPiBPYmplY3QgLT4gQm9vbGVhblxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsXG4gKiBAcGFyYW0geyp9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi53aGVyZUVxLCBSLnByb3BTYXRpc2ZpZXMsIFIuZXF1YWxzXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgYWJieSA9IHtuYW1lOiAnQWJieScsIGFnZTogNywgaGFpcjogJ2Jsb25kJ307XG4gKiAgICAgIGNvbnN0IGZyZWQgPSB7bmFtZTogJ0ZyZWQnLCBhZ2U6IDEyLCBoYWlyOiAnYnJvd24nfTtcbiAqICAgICAgY29uc3QgcnVzdHkgPSB7bmFtZTogJ1J1c3R5JywgYWdlOiAxMCwgaGFpcjogJ2Jyb3duJ307XG4gKiAgICAgIGNvbnN0IGFsb2lzID0ge25hbWU6ICdBbG9pcycsIGFnZTogMTUsIGRpc3Bvc2l0aW9uOiAnc3VybHknfTtcbiAqICAgICAgY29uc3Qga2lkcyA9IFthYmJ5LCBmcmVkLCBydXN0eSwgYWxvaXNdO1xuICogICAgICBjb25zdCBoYXNCcm93bkhhaXIgPSBSLnByb3BFcSgnaGFpcicsICdicm93bicpO1xuICogICAgICBSLmZpbHRlcihoYXNCcm93bkhhaXIsIGtpZHMpOyAvLz0+IFtmcmVkLCBydXN0eV1cbiAqL1xuXG52YXIgcHJvcEVxID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTMoZnVuY3Rpb24gcHJvcEVxKG5hbWUsIHZhbCwgb2JqKSB7XG4gIHJldHVybiBlcXVhbHModmFsLCBvYmpbbmFtZV0pO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHByb3BFcTsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkzLmpzXCI7XG5pbXBvcnQgaXMgZnJvbSBcIi4vaXMuanNcIjtcbi8qKlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgcHJvcGVydHkgaXMgb2YgdGhlIGdpdmVuIHR5cGU7XG4gKiBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgVHlwZVxuICogQHNpZyBUeXBlIC0+IFN0cmluZyAtPiBPYmplY3QgLT4gQm9vbGVhblxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQHNlZSBSLmlzLCBSLnByb3BTYXRpc2ZpZXNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnByb3BJcyhOdW1iZXIsICd4Jywge3g6IDEsIHk6IDJ9KTsgIC8vPT4gdHJ1ZVxuICogICAgICBSLnByb3BJcyhOdW1iZXIsICd4Jywge3g6ICdmb28nfSk7ICAgIC8vPT4gZmFsc2VcbiAqICAgICAgUi5wcm9wSXMoTnVtYmVyLCAneCcsIHt9KTsgICAgICAgICAgICAvLz0+IGZhbHNlXG4gKi9cblxudmFyIHByb3BJcyA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKGZ1bmN0aW9uIHByb3BJcyh0eXBlLCBuYW1lLCBvYmopIHtcbiAgcmV0dXJuIGlzKHR5cGUsIG9ialtuYW1lXSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcHJvcElzOyIsImltcG9ydCBfY3VycnkzIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTMuanNcIjtcbmltcG9ydCBwYXRoT3IgZnJvbSBcIi4vcGF0aE9yLmpzXCI7XG4vKipcbiAqIElmIHRoZSBnaXZlbiwgbm9uLW51bGwgb2JqZWN0IGhhcyBhbiBvd24gcHJvcGVydHkgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUsXG4gKiByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGF0IHByb3BlcnR5LiBPdGhlcndpc2UgcmV0dXJucyB0aGUgcHJvdmlkZWQgZGVmYXVsdFxuICogdmFsdWUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNi4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIGEgLT4gU3RyaW5nIC0+IE9iamVjdCAtPiBhXG4gKiBAcGFyYW0geyp9IHZhbCBUaGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byByZXR1cm4uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWUgb2YgZ2l2ZW4gcHJvcGVydHkgb2YgdGhlIHN1cHBsaWVkIG9iamVjdCBvciB0aGUgZGVmYXVsdCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBhbGljZSA9IHtcbiAqICAgICAgICBuYW1lOiAnQUxJQ0UnLFxuICogICAgICAgIGFnZTogMTAxXG4gKiAgICAgIH07XG4gKiAgICAgIGNvbnN0IGZhdm9yaXRlID0gUi5wcm9wKCdmYXZvcml0ZUxpYnJhcnknKTtcbiAqICAgICAgY29uc3QgZmF2b3JpdGVXaXRoRGVmYXVsdCA9IFIucHJvcE9yKCdSYW1kYScsICdmYXZvcml0ZUxpYnJhcnknKTtcbiAqXG4gKiAgICAgIGZhdm9yaXRlKGFsaWNlKTsgIC8vPT4gdW5kZWZpbmVkXG4gKiAgICAgIGZhdm9yaXRlV2l0aERlZmF1bHQoYWxpY2UpOyAgLy89PiAnUmFtZGEnXG4gKi9cblxudmFyIHByb3BPciA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKGZ1bmN0aW9uIHByb3BPcih2YWwsIHAsIG9iaikge1xuICByZXR1cm4gcGF0aE9yKHZhbCwgW3BdLCBvYmopO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHByb3BPcjsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkzLmpzXCI7XG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IHByb3BlcnR5IHNhdGlzZmllcyB0aGUgZ2l2ZW5cbiAqIHByZWRpY2F0ZTsgYGZhbHNlYCBvdGhlcndpc2UuIFlvdSBjYW4gdGVzdCBtdWx0aXBsZSBwcm9wZXJ0aWVzIHdpdGhcbiAqIFtgUi53aGVyZWBdKCN3aGVyZSkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFN0cmluZyAtPiB7U3RyaW5nOiBhfSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIud2hlcmUsIFIucHJvcEVxLCBSLnByb3BJc1xuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIucHJvcFNhdGlzZmllcyh4ID0+IHggPiAwLCAneCcsIHt4OiAxLCB5OiAyfSk7IC8vPT4gdHJ1ZVxuICovXG5cbnZhciBwcm9wU2F0aXNmaWVzID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTMoZnVuY3Rpb24gcHJvcFNhdGlzZmllcyhwcmVkLCBuYW1lLCBvYmopIHtcbiAgcmV0dXJuIHByZWQob2JqW25hbWVdKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBwcm9wU2F0aXNmaWVzOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbmltcG9ydCBwYXRoIGZyb20gXCIuL3BhdGguanNcIjtcbi8qKlxuICogQWN0cyBhcyBtdWx0aXBsZSBgcHJvcGA6IGFycmF5IG9mIGtleXMgaW4sIGFycmF5IG9mIHZhbHVlcyBvdXQuIFByZXNlcnZlc1xuICogb3JkZXIuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIFtrXSAtPiB7azogdn0gLT4gW3ZdXG4gKiBAcGFyYW0ge0FycmF5fSBwcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZmV0Y2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBxdWVyeVxuICogQHJldHVybiB7QXJyYXl9IFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcyBvciBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnByb3BzKFsneCcsICd5J10sIHt4OiAxLCB5OiAyfSk7IC8vPT4gWzEsIDJdXG4gKiAgICAgIFIucHJvcHMoWydjJywgJ2EnLCAnYiddLCB7YjogMiwgYTogMX0pOyAvLz0+IFt1bmRlZmluZWQsIDEsIDJdXG4gKlxuICogICAgICBjb25zdCBmdWxsTmFtZSA9IFIuY29tcG9zZShSLmpvaW4oJyAnKSwgUi5wcm9wcyhbJ2ZpcnN0JywgJ2xhc3QnXSkpO1xuICogICAgICBmdWxsTmFtZSh7bGFzdDogJ0J1bGxldC1Ub290aCcsIGFnZTogMzMsIGZpcnN0OiAnVG9ueSd9KTsgLy89PiAnVG9ueSBCdWxsZXQtVG9vdGgnXG4gKi9cblxudmFyIHByb3BzID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gcHJvcHMocHMsIG9iaikge1xuICByZXR1cm4gcHMubWFwKGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHBhdGgoW3BdLCBvYmopO1xuICB9KTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBwcm9wczsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgX2lzTnVtYmVyIGZyb20gXCIuL2ludGVybmFsL19pc051bWJlci5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBudW1iZXJzIGZyb20gYGZyb21gIChpbmNsdXNpdmUpIHRvIGB0b2AgKGV4Y2x1c2l2ZSkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gTnVtYmVyIC0+IFtOdW1iZXJdXG4gKiBAcGFyYW0ge051bWJlcn0gZnJvbSBUaGUgZmlyc3QgbnVtYmVyIGluIHRoZSBsaXN0LlxuICogQHBhcmFtIHtOdW1iZXJ9IHRvIE9uZSBtb3JlIHRoYW4gdGhlIGxhc3QgbnVtYmVyIGluIHRoZSBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIG51bWJlcnMgaW4gdGhlIHNldCBgW2EsIGIpYC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnJhbmdlKDEsIDUpOyAgICAvLz0+IFsxLCAyLCAzLCA0XVxuICogICAgICBSLnJhbmdlKDUwLCA1Myk7ICAvLz0+IFs1MCwgNTEsIDUyXVxuICovXG5cbnZhciByYW5nZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIHJhbmdlKGZyb20sIHRvKSB7XG4gIGlmICghKF9pc051bWJlcihmcm9tKSAmJiBfaXNOdW1iZXIodG8pKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvdGggYXJndW1lbnRzIHRvIHJhbmdlIG11c3QgYmUgbnVtYmVycycpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgbiA9IGZyb207XG5cbiAgd2hpbGUgKG4gPCB0bykge1xuICAgIHJlc3VsdC5wdXNoKG4pO1xuICAgIG4gKz0gMTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmFuZ2U7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5My5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGEgc2luZ2xlIGl0ZW0gYnkgaXRlcmF0aW5nIHRocm91Z2ggdGhlIGxpc3QsIHN1Y2Nlc3NpdmVseSBjYWxsaW5nXG4gKiB0aGUgaXRlcmF0b3IgZnVuY3Rpb24gYW5kIHBhc3NpbmcgaXQgYW4gYWNjdW11bGF0b3IgdmFsdWUgYW5kIHRoZSBjdXJyZW50XG4gKiB2YWx1ZSBmcm9tIHRoZSBhcnJheSwgYW5kIHRoZW4gcGFzc2luZyB0aGUgcmVzdWx0IHRvIHRoZSBuZXh0IGNhbGwuXG4gKlxuICogU2ltaWxhciB0byBbYHJlZHVjZWBdKCNyZWR1Y2UpLCBleGNlcHQgbW92ZXMgdGhyb3VnaCB0aGUgaW5wdXQgbGlzdCBmcm9tIHRoZVxuICogcmlnaHQgdG8gdGhlIGxlZnQuXG4gKlxuICogVGhlIGl0ZXJhdG9yIGZ1bmN0aW9uIHJlY2VpdmVzIHR3byB2YWx1ZXM6ICoodmFsdWUsIGFjYykqLCB3aGlsZSB0aGUgYXJndW1lbnRzJ1xuICogb3JkZXIgb2YgYHJlZHVjZWAncyBpdGVyYXRvciBmdW5jdGlvbiBpcyAqKGFjYywgdmFsdWUpKi5cbiAqXG4gKiBOb3RlOiBgUi5yZWR1Y2VSaWdodGAgZG9lcyBub3Qgc2tpcCBkZWxldGVkIG9yIHVuYXNzaWduZWQgaW5kaWNlcyAoc3BhcnNlXG4gKiBhcnJheXMpLCB1bmxpa2UgdGhlIG5hdGl2ZSBgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0YCBtZXRob2QuIEZvciBtb3JlIGRldGFpbHNcbiAqIG9uIHRoaXMgYmVoYXZpb3IsIHNlZTpcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3JlZHVjZVJpZ2h0I0Rlc2NyaXB0aW9uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoKGEsIGIpIC0+IGIpIC0+IGIgLT4gW2FdIC0+IGJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgdGhlIGN1cnJlbnQgZWxlbWVudCBmcm9tIHRoZSBhcnJheVxuICogICAgICAgIGFuZCB0aGUgYWNjdW11bGF0b3IuXG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgYWNjdW11bGF0b3IgdmFsdWUuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4geyp9IFRoZSBmaW5hbCwgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKiBAc2VlIFIucmVkdWNlLCBSLmFkZEluZGV4XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5yZWR1Y2VSaWdodChSLnN1YnRyYWN0LCAwLCBbMSwgMiwgMywgNF0pIC8vID0+ICgxIC0gKDIgLSAoMyAtICg0IC0gMCkpKSkgPSAtMlxuICogICAgICAvLyAgICAtICAgICAgICAgICAgICAgLTJcbiAqICAgICAgLy8gICAvIFxcICAgICAgICAgICAgICAvIFxcXG4gKiAgICAgIC8vICAxICAgLSAgICAgICAgICAgIDEgICAzXG4gKiAgICAgIC8vICAgICAvIFxcICAgICAgICAgICAgICAvIFxcXG4gKiAgICAgIC8vICAgIDIgICAtICAgICA9PT4gICAgMiAgLTFcbiAqICAgICAgLy8gICAgICAgLyBcXCAgICAgICAgICAgICAgLyBcXFxuICogICAgICAvLyAgICAgIDMgICAtICAgICAgICAgICAgMyAgIDRcbiAqICAgICAgLy8gICAgICAgICAvIFxcICAgICAgICAgICAgICAvIFxcXG4gKiAgICAgIC8vICAgICAgICA0ICAgMCAgICAgICAgICAgIDQgICAwXG4gKlxuICogQHN5bWIgUi5yZWR1Y2VSaWdodChmLCBhLCBbYiwgYywgZF0pID0gZihiLCBmKGMsIGYoZCwgYSkpKVxuICovXG5cbnZhciByZWR1Y2VSaWdodCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGZuLCBhY2MsIGxpc3QpIHtcbiAgdmFyIGlkeCA9IGxpc3QubGVuZ3RoIC0gMTtcblxuICB3aGlsZSAoaWR4ID49IDApIHtcbiAgICBhY2MgPSBmbihsaXN0W2lkeF0sIGFjYyk7XG4gICAgaWR4IC09IDE7XG4gIH1cblxuICByZXR1cm4gYWNjO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZVJpZ2h0OyIsImltcG9ydCBfY3VycnlOIGZyb20gXCIuL2ludGVybmFsL19jdXJyeU4uanNcIjtcbmltcG9ydCBfcmVkdWNlIGZyb20gXCIuL2ludGVybmFsL19yZWR1Y2UuanNcIjtcbmltcG9ydCBfcmVkdWNlZCBmcm9tIFwiLi9pbnRlcm5hbC9fcmVkdWNlZC5qc1wiO1xuLyoqXG4gKiBMaWtlIFtgcmVkdWNlYF0oI3JlZHVjZSksIGByZWR1Y2VXaGlsZWAgcmV0dXJucyBhIHNpbmdsZSBpdGVtIGJ5IGl0ZXJhdGluZ1xuICogdGhyb3VnaCB0aGUgbGlzdCwgc3VjY2Vzc2l2ZWx5IGNhbGxpbmcgdGhlIGl0ZXJhdG9yIGZ1bmN0aW9uLiBgcmVkdWNlV2hpbGVgXG4gKiBhbHNvIHRha2VzIGEgcHJlZGljYXRlIHRoYXQgaXMgZXZhbHVhdGVkIGJlZm9yZSBlYWNoIHN0ZXAuIElmIHRoZSBwcmVkaWNhdGVcbiAqIHJldHVybnMgYGZhbHNlYCwgaXQgXCJzaG9ydC1jaXJjdWl0c1wiIHRoZSBpdGVyYXRpb24gYW5kIHJldHVybnMgdGhlIGN1cnJlbnRcbiAqIHZhbHVlIG9mIHRoZSBhY2N1bXVsYXRvci5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yMi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoKGEsIGIpIC0+IEJvb2xlYW4pIC0+ICgoYSwgYikgLT4gYSkgLT4gYSAtPiBbYl0gLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBUaGUgcHJlZGljYXRlLiBJdCBpcyBwYXNzZWQgdGhlIGFjY3VtdWxhdG9yIGFuZCB0aGVcbiAqICAgICAgICBjdXJyZW50IGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24uIFJlY2VpdmVzIHR3byB2YWx1ZXMsIHRoZVxuICogICAgICAgIGFjY3VtdWxhdG9yIGFuZCB0aGUgY3VycmVudCBlbGVtZW50LlxuICogQHBhcmFtIHsqfSBhIFRoZSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7Kn0gVGhlIGZpbmFsLCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgUi5yZWR1Y2UsIFIucmVkdWNlZFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IGlzT2RkID0gKGFjYywgeCkgPT4geCAlIDIgPT09IDE7XG4gKiAgICAgIGNvbnN0IHhzID0gWzEsIDMsIDUsIDYwLCA3NzcsIDgwMF07XG4gKiAgICAgIFIucmVkdWNlV2hpbGUoaXNPZGQsIFIuYWRkLCAwLCB4cyk7IC8vPT4gOVxuICpcbiAqICAgICAgY29uc3QgeXMgPSBbMiwgNCwgNl1cbiAqICAgICAgUi5yZWR1Y2VXaGlsZShpc09kZCwgUi5hZGQsIDExMSwgeXMpOyAvLz0+IDExMVxuICovXG5cbnZhciByZWR1Y2VXaGlsZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnlOKDQsIFtdLCBmdW5jdGlvbiBfcmVkdWNlV2hpbGUocHJlZCwgZm4sIGEsIGxpc3QpIHtcbiAgcmV0dXJuIF9yZWR1Y2UoZnVuY3Rpb24gKGFjYywgeCkge1xuICAgIHJldHVybiBwcmVkKGFjYywgeCkgPyBmbihhY2MsIHgpIDogX3JlZHVjZWQoYWNjKTtcbiAgfSwgYSwgbGlzdCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlV2hpbGU7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5MS5qc1wiO1xuaW1wb3J0IF9yZWR1Y2VkIGZyb20gXCIuL2ludGVybmFsL19yZWR1Y2VkLmpzXCI7XG4vKipcbiAqIFJldHVybnMgYSB2YWx1ZSB3cmFwcGVkIHRvIGluZGljYXRlIHRoYXQgaXQgaXMgdGhlIGZpbmFsIHZhbHVlIG9mIHRoZSByZWR1Y2VcbiAqIGFuZCB0cmFuc2R1Y2UgZnVuY3Rpb25zLiBUaGUgcmV0dXJuZWQgdmFsdWUgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBibGFja1xuICogYm94OiB0aGUgaW50ZXJuYWwgc3RydWN0dXJlIGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIHN0YWJsZS5cbiAqXG4gKiBOb3RlOiB0aGlzIG9wdGltaXphdGlvbiBpcyBvbmx5IGF2YWlsYWJsZSB0byB0aGUgYmVsb3cgZnVuY3Rpb25zOlxuICogLSBbYHJlZHVjZWBdKCNyZWR1Y2UpXG4gKiAtIFtgcmVkdWNlV2hpbGVgXSgjcmVkdWNlV2hpbGUpXG4gKiAtIFtgdHJhbnNkdWNlYF0oI3RyYW5zZHVjZSlcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBhIC0+ICpcbiAqIEBwYXJhbSB7Kn0geCBUaGUgZmluYWwgdmFsdWUgb2YgdGhlIHJlZHVjZS5cbiAqIEByZXR1cm4geyp9IFRoZSB3cmFwcGVkIHZhbHVlLlxuICogQHNlZSBSLnJlZHVjZSwgUi5yZWR1Y2VXaGlsZSwgUi50cmFuc2R1Y2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIFIucmVkdWNlKFxuICogICAgICAgKGFjYywgaXRlbSkgPT4gaXRlbSA+IDMgPyBSLnJlZHVjZWQoYWNjKSA6IGFjYy5jb25jYXQoaXRlbSksXG4gKiAgICAgICBbXSxcbiAqICAgICAgIFsxLCAyLCAzLCA0LCA1XSkgLy8gWzEsIDIsIDNdXG4gKi9cblxudmFyIHJlZHVjZWQgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShfcmVkdWNlZCk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlZHVjZWQ7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuLyoqXG4gKiBDYWxscyBhbiBpbnB1dCBmdW5jdGlvbiBgbmAgdGltZXMsIHJldHVybmluZyBhbiBhcnJheSBjb250YWluaW5nIHRoZSByZXN1bHRzXG4gKiBvZiB0aG9zZSBmdW5jdGlvbiBjYWxscy5cbiAqXG4gKiBgZm5gIGlzIHBhc3NlZCBvbmUgYXJndW1lbnQ6IFRoZSBjdXJyZW50IHZhbHVlIG9mIGBuYCwgd2hpY2ggYmVnaW5zIGF0IGAwYFxuICogYW5kIGlzIGdyYWR1YWxseSBpbmNyZW1lbnRlZCB0byBgbiAtIDFgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIuM1xuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKE51bWJlciAtPiBhKSAtPiBOdW1iZXIgLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLiBQYXNzZWQgb25lIGFyZ3VtZW50LCB0aGUgY3VycmVudCB2YWx1ZSBvZiBgbmAuXG4gKiBAcGFyYW0ge051bWJlcn0gbiBBIHZhbHVlIGJldHdlZW4gYDBgIGFuZCBgbiAtIDFgLiBJbmNyZW1lbnRzIGFmdGVyIGVhY2ggZnVuY3Rpb24gY2FsbC5cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBjb250YWluaW5nIHRoZSByZXR1cm4gdmFsdWVzIG9mIGFsbCBjYWxscyB0byBgZm5gLlxuICogQHNlZSBSLnJlcGVhdFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudGltZXMoUi5pZGVudGl0eSwgNSk7IC8vPT4gWzAsIDEsIDIsIDMsIDRdXG4gKiBAc3ltYiBSLnRpbWVzKGYsIDApID0gW11cbiAqIEBzeW1iIFIudGltZXMoZiwgMSkgPSBbZigwKV1cbiAqIEBzeW1iIFIudGltZXMoZiwgMikgPSBbZigwKSwgZigxKV1cbiAqL1xuXG52YXIgdGltZXMgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiB0aW1lcyhmbiwgbikge1xuICB2YXIgbGVuID0gTnVtYmVyKG4pO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxpc3Q7XG5cbiAgaWYgKGxlbiA8IDAgfHwgaXNOYU4obGVuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCduIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJyk7XG4gIH1cblxuICBsaXN0ID0gbmV3IEFycmF5KGxlbik7XG5cbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIGxpc3RbaWR4XSA9IGZuKGlkeCk7XG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB0aW1lczsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgYWx3YXlzIGZyb20gXCIuL2Fsd2F5cy5qc1wiO1xuaW1wb3J0IHRpbWVzIGZyb20gXCIuL3RpbWVzLmpzXCI7XG4vKipcbiAqIFJldHVybnMgYSBmaXhlZCBsaXN0IG9mIHNpemUgYG5gIGNvbnRhaW5pbmcgYSBzcGVjaWZpZWQgaWRlbnRpY2FsIHZhbHVlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMVxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgYSAtPiBuIC0+IFthXVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVwZWF0LlxuICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIGRlc2lyZWQgc2l6ZSBvZiB0aGUgb3V0cHV0IGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBuZXcgYXJyYXkgY29udGFpbmluZyBgbmAgYHZhbHVlYHMuXG4gKiBAc2VlIFIudGltZXNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnJlcGVhdCgnaGknLCA1KTsgLy89PiBbJ2hpJywgJ2hpJywgJ2hpJywgJ2hpJywgJ2hpJ11cbiAqXG4gKiAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICogICAgICBjb25zdCByZXBlYXRlZE9ianMgPSBSLnJlcGVhdChvYmosIDUpOyAvLz0+IFt7fSwge30sIHt9LCB7fSwge31dXG4gKiAgICAgIHJlcGVhdGVkT2Jqc1swXSA9PT0gcmVwZWF0ZWRPYmpzWzFdOyAvLz0+IHRydWVcbiAqIEBzeW1iIFIucmVwZWF0KGEsIDApID0gW11cbiAqIEBzeW1iIFIucmVwZWF0KGEsIDEpID0gW2FdXG4gKiBAc3ltYiBSLnJlcGVhdChhLCAyKSA9IFthLCBhXVxuICovXG5cbnZhciByZXBlYXQgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiByZXBlYXQodmFsdWUsIG4pIHtcbiAgcmV0dXJuIHRpbWVzKGFsd2F5cyh2YWx1ZSksIG4pO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHJlcGVhdDsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkzLmpzXCI7XG4vKipcbiAqIFJlcGxhY2UgYSBzdWJzdHJpbmcgb3IgcmVnZXggbWF0Y2ggaW4gYSBzdHJpbmcgd2l0aCBhIHJlcGxhY2VtZW50LlxuICpcbiAqIFRoZSBmaXJzdCB0d28gcGFyYW1ldGVycyBjb3JyZXNwb25kIHRvIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZVxuICogYFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSgpYCBmdW5jdGlvbiwgc28gdGhlIHNlY29uZCBwYXJhbWV0ZXIgY2FuIGFsc28gYmUgYVxuICogZnVuY3Rpb24uXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNy4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAc2lnIFJlZ0V4cHxTdHJpbmcgLT4gU3RyaW5nIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7UmVnRXhwfFN0cmluZ30gcGF0dGVybiBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBhIHN1YnN0cmluZyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7U3RyaW5nfSByZXBsYWNlbWVudCBUaGUgc3RyaW5nIHRvIHJlcGxhY2UgdGhlIG1hdGNoZXMgd2l0aC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byBkbyB0aGUgc2VhcmNoIGFuZCByZXBsYWNlbWVudCBpbi5cbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlc3VsdC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnJlcGxhY2UoJ2ZvbycsICdiYXInLCAnZm9vIGZvbyBmb28nKTsgLy89PiAnYmFyIGZvbyBmb28nXG4gKiAgICAgIFIucmVwbGFjZSgvZm9vLywgJ2JhcicsICdmb28gZm9vIGZvbycpOyAvLz0+ICdiYXIgZm9vIGZvbydcbiAqXG4gKiAgICAgIC8vIFVzZSB0aGUgXCJnXCIgKGdsb2JhbCkgZmxhZyB0byByZXBsYWNlIGFsbCBvY2N1cnJlbmNlczpcbiAqICAgICAgUi5yZXBsYWNlKC9mb28vZywgJ2JhcicsICdmb28gZm9vIGZvbycpOyAvLz0+ICdiYXIgYmFyIGJhcidcbiAqL1xuXG52YXIgcmVwbGFjZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKGZ1bmN0aW9uIHJlcGxhY2UocmVnZXgsIHJlcGxhY2VtZW50LCBzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKHJlZ2V4LCByZXBsYWNlbWVudCk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgcmVwbGFjZTsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkzLmpzXCI7XG4vKipcbiAqIFNjYW4gaXMgc2ltaWxhciB0byBbYHJlZHVjZWBdKCNyZWR1Y2UpLCBidXQgcmV0dXJucyBhIGxpc3Qgb2Ygc3VjY2Vzc2l2ZWx5XG4gKiByZWR1Y2VkIHZhbHVlcyBmcm9tIHRoZSBsZWZ0XG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTAuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKChhLCBiKSAtPiBhKSAtPiBhIC0+IFtiXSAtPiBbYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgdGhlIGFjY3VtdWxhdG9yIGFuZCB0aGVcbiAqICAgICAgICBjdXJyZW50IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7Kn0gYWNjIFRoZSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7QXJyYXl9IEEgbGlzdCBvZiBhbGwgaW50ZXJtZWRpYXRlbHkgcmVkdWNlZCB2YWx1ZXMuXG4gKiBAc2VlIFIucmVkdWNlLCBSLm1hcEFjY3VtXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgbnVtYmVycyA9IFsxLCAyLCAzLCA0XTtcbiAqICAgICAgY29uc3QgZmFjdG9yaWFscyA9IFIuc2NhbihSLm11bHRpcGx5LCAxLCBudW1iZXJzKTsgLy89PiBbMSwgMSwgMiwgNiwgMjRdXG4gKiBAc3ltYiBSLnNjYW4oZiwgYSwgW2IsIGNdKSA9IFthLCBmKGEsIGIpLCBmKGYoYSwgYiksIGMpXVxuICovXG5cbnZhciBzY2FuID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTMoZnVuY3Rpb24gc2NhbihmbiwgYWNjLCBsaXN0KSB7XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gbGlzdC5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBbYWNjXTtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgYWNjID0gZm4oYWNjLCBsaXN0W2lkeF0pO1xuICAgIHJlc3VsdFtpZHggKyAxXSA9IGFjYztcbiAgICBpZHggKz0gMTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc2NhbjsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgYXAgZnJvbSBcIi4vYXAuanNcIjtcbmltcG9ydCBtYXAgZnJvbSBcIi4vbWFwLmpzXCI7XG5pbXBvcnQgcHJlcGVuZCBmcm9tIFwiLi9wcmVwZW5kLmpzXCI7XG5pbXBvcnQgcmVkdWNlUmlnaHQgZnJvbSBcIi4vcmVkdWNlUmlnaHQuanNcIjtcbi8qKlxuICogVHJhbnNmb3JtcyBhIFtUcmF2ZXJzYWJsZV0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCN0cmF2ZXJzYWJsZSlcbiAqIG9mIFtBcHBsaWNhdGl2ZV0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhcHBsaWNhdGl2ZSkgaW50byBhblxuICogQXBwbGljYXRpdmUgb2YgVHJhdmVyc2FibGUuXG4gKlxuICogRGlzcGF0Y2hlcyB0byB0aGUgYHNlcXVlbmNlYCBtZXRob2Qgb2YgdGhlIHNlY29uZCBhcmd1bWVudCwgaWYgcHJlc2VudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoQXBwbGljYXRpdmUgZiwgVHJhdmVyc2FibGUgdCkgPT4gKGEgLT4gZiBhKSAtPiB0IChmIGEpIC0+IGYgKHQgYSlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9mXG4gKiBAcGFyYW0geyp9IHRyYXZlcnNhYmxlXG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLnRyYXZlcnNlXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5zZXF1ZW5jZShNYXliZS5vZiwgW0p1c3QoMSksIEp1c3QoMiksIEp1c3QoMyldKTsgICAvLz0+IEp1c3QoWzEsIDIsIDNdKVxuICogICAgICBSLnNlcXVlbmNlKE1heWJlLm9mLCBbSnVzdCgxKSwgSnVzdCgyKSwgTm90aGluZygpXSk7IC8vPT4gTm90aGluZygpXG4gKlxuICogICAgICBSLnNlcXVlbmNlKFIub2YsIEp1c3QoWzEsIDIsIDNdKSk7IC8vPT4gW0p1c3QoMSksIEp1c3QoMiksIEp1c3QoMyldXG4gKiAgICAgIFIuc2VxdWVuY2UoUi5vZiwgTm90aGluZygpKTsgICAgICAgLy89PiBbTm90aGluZygpXVxuICovXG5cbnZhciBzZXF1ZW5jZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIHNlcXVlbmNlKG9mLCB0cmF2ZXJzYWJsZSkge1xuICByZXR1cm4gdHlwZW9mIHRyYXZlcnNhYmxlLnNlcXVlbmNlID09PSAnZnVuY3Rpb24nID8gdHJhdmVyc2FibGUuc2VxdWVuY2Uob2YpIDogcmVkdWNlUmlnaHQoZnVuY3Rpb24gKHgsIGFjYykge1xuICAgIHJldHVybiBhcChtYXAocHJlcGVuZCwgeCksIGFjYyk7XG4gIH0sIG9mKFtdKSwgdHJhdmVyc2FibGUpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHNlcXVlbmNlOyIsImltcG9ydCBfY3VycnkzIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTMuanNcIjtcbmltcG9ydCBhbHdheXMgZnJvbSBcIi4vYWx3YXlzLmpzXCI7XG5pbXBvcnQgb3ZlciBmcm9tIFwiLi9vdmVyLmpzXCI7XG4vKipcbiAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBcInNldHRpbmdcIiB0aGUgcG9ydGlvbiBvZiB0aGUgZ2l2ZW4gZGF0YSBzdHJ1Y3R1cmVcbiAqIGZvY3VzZWQgYnkgdGhlIGdpdmVuIGxlbnMgdG8gdGhlIGdpdmVuIHZhbHVlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE2LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEB0eXBlZGVmbiBMZW5zIHMgYSA9IEZ1bmN0b3IgZiA9PiAoYSAtPiBmIGEpIC0+IHMgLT4gZiBzXG4gKiBAc2lnIExlbnMgcyBhIC0+IGEgLT4gcyAtPiBzXG4gKiBAcGFyYW0ge0xlbnN9IGxlbnNcbiAqIEBwYXJhbSB7Kn0gdlxuICogQHBhcmFtIHsqfSB4XG4gKiBAcmV0dXJuIHsqfVxuICogQHNlZSBSLnByb3AsIFIubGVuc0luZGV4LCBSLmxlbnNQcm9wXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgeExlbnMgPSBSLmxlbnNQcm9wKCd4Jyk7XG4gKlxuICogICAgICBSLnNldCh4TGVucywgNCwge3g6IDEsIHk6IDJ9KTsgIC8vPT4ge3g6IDQsIHk6IDJ9XG4gKiAgICAgIFIuc2V0KHhMZW5zLCA4LCB7eDogMSwgeTogMn0pOyAgLy89PiB7eDogOCwgeTogMn1cbiAqL1xuXG52YXIgc2V0ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTMoZnVuY3Rpb24gc2V0KGxlbnMsIHYsIHgpIHtcbiAgcmV0dXJuIG92ZXIobGVucywgYWx3YXlzKHYpLCB4KTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzZXQ7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgbGlzdCwgc29ydGVkIGFjY29yZGluZyB0byB0aGUgY29tcGFyYXRvciBmdW5jdGlvbixcbiAqIHdoaWNoIHNob3VsZCBhY2NlcHQgdHdvIHZhbHVlcyBhdCBhIHRpbWUgYW5kIHJldHVybiBhIG5lZ2F0aXZlIG51bWJlciBpZiB0aGVcbiAqIGZpcnN0IHZhbHVlIGlzIHNtYWxsZXIsIGEgcG9zaXRpdmUgbnVtYmVyIGlmIGl0J3MgbGFyZ2VyLCBhbmQgemVybyBpZiB0aGV5XG4gKiBhcmUgZXF1YWwuIFBsZWFzZSBub3RlIHRoYXQgdGhpcyBpcyBhICoqY29weSoqIG9mIHRoZSBsaXN0LiBJdCBkb2VzIG5vdFxuICogbW9kaWZ5IHRoZSBvcmlnaW5hbC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoYSwgYSkgLT4gTnVtYmVyKSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIEEgc29ydGluZyBmdW5jdGlvbiA6OiBhIC0+IGIgLT4gSW50XG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBsaXN0IHRvIHNvcnRcbiAqIEByZXR1cm4ge0FycmF5fSBhIG5ldyBhcnJheSB3aXRoIGl0cyBlbGVtZW50cyBzb3J0ZWQgYnkgdGhlIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgZGlmZiA9IGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEgLSBiOyB9O1xuICogICAgICBSLnNvcnQoZGlmZiwgWzQsMiw3LDVdKTsgLy89PiBbMiwgNCwgNSwgN11cbiAqL1xuXG52YXIgc29ydCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIHNvcnQoY29tcGFyYXRvciwgbGlzdCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCkuc29ydChjb21wYXJhdG9yKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzb3J0OyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogU29ydHMgdGhlIGxpc3QgYWNjb3JkaW5nIHRvIHRoZSBzdXBwbGllZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBPcmQgYiA9PiAoYSAtPiBiKSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBUaGUgbGlzdCB0byBzb3J0LlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGxpc3Qgc29ydGVkIGJ5IHRoZSBrZXlzIGdlbmVyYXRlZCBieSBgZm5gLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IHNvcnRCeUZpcnN0SXRlbSA9IFIuc29ydEJ5KFIucHJvcCgwKSk7XG4gKiAgICAgIGNvbnN0IHBhaXJzID0gW1stMSwgMV0sIFstMiwgMl0sIFstMywgM11dO1xuICogICAgICBzb3J0QnlGaXJzdEl0ZW0ocGFpcnMpOyAvLz0+IFtbLTMsIDNdLCBbLTIsIDJdLCBbLTEsIDFdXVxuICpcbiAqICAgICAgY29uc3Qgc29ydEJ5TmFtZUNhc2VJbnNlbnNpdGl2ZSA9IFIuc29ydEJ5KFIuY29tcG9zZShSLnRvTG93ZXIsIFIucHJvcCgnbmFtZScpKSk7XG4gKiAgICAgIGNvbnN0IGFsaWNlID0ge1xuICogICAgICAgIG5hbWU6ICdBTElDRScsXG4gKiAgICAgICAgYWdlOiAxMDFcbiAqICAgICAgfTtcbiAqICAgICAgY29uc3QgYm9iID0ge1xuICogICAgICAgIG5hbWU6ICdCb2InLFxuICogICAgICAgIGFnZTogLTEwXG4gKiAgICAgIH07XG4gKiAgICAgIGNvbnN0IGNsYXJhID0ge1xuICogICAgICAgIG5hbWU6ICdjbGFyYScsXG4gKiAgICAgICAgYWdlOiAzMTQuMTU5XG4gKiAgICAgIH07XG4gKiAgICAgIGNvbnN0IHBlb3BsZSA9IFtjbGFyYSwgYm9iLCBhbGljZV07XG4gKiAgICAgIHNvcnRCeU5hbWVDYXNlSW5zZW5zaXRpdmUocGVvcGxlKTsgLy89PiBbYWxpY2UsIGJvYiwgY2xhcmFdXG4gKi9cblxudmFyIHNvcnRCeSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIHNvcnRCeShmbiwgbGlzdCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciBhYSA9IGZuKGEpO1xuICAgIHZhciBiYiA9IGZuKGIpO1xuICAgIHJldHVybiBhYSA8IGJiID8gLTEgOiBhYSA+IGJiID8gMSA6IDA7XG4gIH0pO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHNvcnRCeTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG4vKipcbiAqIFNvcnRzIGEgbGlzdCBhY2NvcmRpbmcgdG8gYSBsaXN0IG9mIGNvbXBhcmF0b3JzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIzLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBbKGEsIGEpIC0+IE51bWJlcl0gLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtBcnJheX0gZnVuY3Rpb25zIEEgbGlzdCBvZiBjb21wYXJhdG9yIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gc29ydC5cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBsaXN0IHNvcnRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvbWFyYXRvciBmdW5jdGlvbnMuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgYWxpY2UgPSB7XG4gKiAgICAgICAgbmFtZTogJ2FsaWNlJyxcbiAqICAgICAgICBhZ2U6IDQwXG4gKiAgICAgIH07XG4gKiAgICAgIGNvbnN0IGJvYiA9IHtcbiAqICAgICAgICBuYW1lOiAnYm9iJyxcbiAqICAgICAgICBhZ2U6IDMwXG4gKiAgICAgIH07XG4gKiAgICAgIGNvbnN0IGNsYXJhID0ge1xuICogICAgICAgIG5hbWU6ICdjbGFyYScsXG4gKiAgICAgICAgYWdlOiA0MFxuICogICAgICB9O1xuICogICAgICBjb25zdCBwZW9wbGUgPSBbY2xhcmEsIGJvYiwgYWxpY2VdO1xuICogICAgICBjb25zdCBhZ2VOYW1lU29ydCA9IFIuc29ydFdpdGgoW1xuICogICAgICAgIFIuZGVzY2VuZChSLnByb3AoJ2FnZScpKSxcbiAqICAgICAgICBSLmFzY2VuZChSLnByb3AoJ25hbWUnKSlcbiAqICAgICAgXSk7XG4gKiAgICAgIGFnZU5hbWVTb3J0KHBlb3BsZSk7IC8vPT4gW2FsaWNlLCBjbGFyYSwgYm9iXVxuICovXG5cbnZhciBzb3J0V2l0aCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIHNvcnRXaXRoKGZucywgbGlzdCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgMCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIHZhciBpID0gMDtcblxuICAgIHdoaWxlIChyZXN1bHQgPT09IDAgJiYgaSA8IGZucy5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdCA9IGZuc1tpXShhLCBiKTtcbiAgICAgIGkgKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9KTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzb3J0V2l0aDsiLCJpbXBvcnQgaW52b2tlciBmcm9tIFwiLi9pbnZva2VyLmpzXCI7XG4vKipcbiAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MgYmFzZWQgb24gdGhlIGdpdmVuXG4gKiBzZXBhcmF0b3IuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAc2lnIChTdHJpbmcgfCBSZWdFeHApIC0+IFN0cmluZyAtPiBbU3RyaW5nXVxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBzZXAgVGhlIHBhdHRlcm4uXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdG8gc2VwYXJhdGUgaW50byBhbiBhcnJheS5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgYXJyYXkgb2Ygc3RyaW5ncyBmcm9tIGBzdHJgIHNlcGFyYXRlZCBieSBgc2VwYC5cbiAqIEBzZWUgUi5qb2luXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgcGF0aENvbXBvbmVudHMgPSBSLnNwbGl0KCcvJyk7XG4gKiAgICAgIFIudGFpbChwYXRoQ29tcG9uZW50cygnL3Vzci9sb2NhbC9iaW4vbm9kZScpKTsgLy89PiBbJ3VzcicsICdsb2NhbCcsICdiaW4nLCAnbm9kZSddXG4gKlxuICogICAgICBSLnNwbGl0KCcuJywgJ2EuYi5jLnh5ei5kJyk7IC8vPT4gWydhJywgJ2InLCAnYycsICd4eXonLCAnZCddXG4gKi9cblxudmFyIHNwbGl0ID1cbi8qI19fUFVSRV9fKi9cbmludm9rZXIoMSwgJ3NwbGl0Jyk7XG5leHBvcnQgZGVmYXVsdCBzcGxpdDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgbGVuZ3RoIGZyb20gXCIuL2xlbmd0aC5qc1wiO1xuaW1wb3J0IHNsaWNlIGZyb20gXCIuL3NsaWNlLmpzXCI7XG4vKipcbiAqIFNwbGl0cyBhIGdpdmVuIGxpc3Qgb3Igc3RyaW5nIGF0IGEgZ2l2ZW4gaW5kZXguXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgTnVtYmVyIC0+IFthXSAtPiBbW2FdLCBbYV1dXG4gKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gW1N0cmluZywgU3RyaW5nXVxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCB3aGVyZSB0aGUgYXJyYXkvc3RyaW5nIGlzIHNwbGl0LlxuICogQHBhcmFtIHtBcnJheXxTdHJpbmd9IGFycmF5IFRoZSBhcnJheS9zdHJpbmcgdG8gYmUgc3BsaXQuXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnNwbGl0QXQoMSwgWzEsIDIsIDNdKTsgICAgICAgICAgLy89PiBbWzFdLCBbMiwgM11dXG4gKiAgICAgIFIuc3BsaXRBdCg1LCAnaGVsbG8gd29ybGQnKTsgICAgICAvLz0+IFsnaGVsbG8nLCAnIHdvcmxkJ11cbiAqICAgICAgUi5zcGxpdEF0KC0xLCAnZm9vYmFyJyk7ICAgICAgICAgIC8vPT4gWydmb29iYScsICdyJ11cbiAqL1xuXG52YXIgc3BsaXRBdCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIHNwbGl0QXQoaW5kZXgsIGFycmF5KSB7XG4gIHJldHVybiBbc2xpY2UoMCwgaW5kZXgsIGFycmF5KSwgc2xpY2UoaW5kZXgsIGxlbmd0aChhcnJheSksIGFycmF5KV07XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc3BsaXRBdDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgc2xpY2UgZnJvbSBcIi4vc2xpY2UuanNcIjtcbi8qKlxuICogU3BsaXRzIGEgY29sbGVjdGlvbiBpbnRvIHNsaWNlcyBvZiB0aGUgc3BlY2lmaWVkIGxlbmd0aC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBOdW1iZXIgLT4gW2FdIC0+IFtbYV1dXG4gKiBAc2lnIE51bWJlciAtPiBTdHJpbmcgLT4gW1N0cmluZ11cbiAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnNwbGl0RXZlcnkoMywgWzEsIDIsIDMsIDQsIDUsIDYsIDddKTsgLy89PiBbWzEsIDIsIDNdLCBbNCwgNSwgNl0sIFs3XV1cbiAqICAgICAgUi5zcGxpdEV2ZXJ5KDMsICdmb29iYXJiYXonKTsgLy89PiBbJ2ZvbycsICdiYXInLCAnYmF6J11cbiAqL1xuXG52YXIgc3BsaXRFdmVyeSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIHNwbGl0RXZlcnkobiwgbGlzdCkge1xuICBpZiAobiA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCB0byBzcGxpdEV2ZXJ5IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyJyk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpZHggPSAwO1xuXG4gIHdoaWxlIChpZHggPCBsaXN0Lmxlbmd0aCkge1xuICAgIHJlc3VsdC5wdXNoKHNsaWNlKGlkeCwgaWR4ICs9IG4sIGxpc3QpKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgc3BsaXRFdmVyeTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG4vKipcbiAqIFRha2VzIGEgbGlzdCBhbmQgYSBwcmVkaWNhdGUgYW5kIHJldHVybnMgYSBwYWlyIG9mIGxpc3RzIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAtIHRoZSByZXN1bHQgb2YgY29uY2F0ZW5hdGluZyB0aGUgdHdvIG91dHB1dCBsaXN0cyBpcyBlcXVpdmFsZW50IHRvIHRoZSBpbnB1dCBsaXN0O1xuICogIC0gbm9uZSBvZiB0aGUgZWxlbWVudHMgb2YgdGhlIGZpcnN0IG91dHB1dCBsaXN0IHNhdGlzZmllcyB0aGUgcHJlZGljYXRlOyBhbmRcbiAqICAtIGlmIHRoZSBzZWNvbmQgb3V0cHV0IGxpc3QgaXMgbm9uLWVtcHR5LCBpdHMgZmlyc3QgZWxlbWVudCBzYXRpc2ZpZXMgdGhlIHByZWRpY2F0ZS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW1thXSwgW2FdXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCBUaGUgcHJlZGljYXRlIHRoYXQgZGV0ZXJtaW5lcyB3aGVyZSB0aGUgYXJyYXkgaXMgc3BsaXQuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IFRoZSBhcnJheSB0byBiZSBzcGxpdC5cbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIuc3BsaXRXaGVuKFIuZXF1YWxzKDIpLCBbMSwgMiwgMywgMSwgMiwgM10pOyAgIC8vPT4gW1sxXSwgWzIsIDMsIDEsIDIsIDNdXVxuICovXG5cbnZhciBzcGxpdFdoZW4gPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBzcGxpdFdoZW4ocHJlZCwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcHJlZml4ID0gW107XG5cbiAgd2hpbGUgKGlkeCA8IGxlbiAmJiAhcHJlZChsaXN0W2lkeF0pKSB7XG4gICAgcHJlZml4LnB1c2gobGlzdFtpZHhdKTtcbiAgICBpZHggKz0gMTtcbiAgfVxuXG4gIHJldHVybiBbcHJlZml4LCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCBpZHgpXTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzcGxpdFdoZW47IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IGVxdWFscyBmcm9tIFwiLi9lcXVhbHMuanNcIjtcbmltcG9ydCB0YWtlIGZyb20gXCIuL3Rha2UuanNcIjtcbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBzdGFydHMgd2l0aCB0aGUgcHJvdmlkZWQgc3VibGlzdC5cbiAqXG4gKiBTaW1pbGFybHksIGNoZWNrcyBpZiBhIHN0cmluZyBzdGFydHMgd2l0aCB0aGUgcHJvdmlkZWQgc3Vic3RyaW5nLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjI0LjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFthXSAtPiBbYV0gLT4gQm9vbGVhblxuICogQHNpZyBTdHJpbmcgLT4gU3RyaW5nIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7Kn0gcHJlZml4XG4gKiBAcGFyYW0geyp9IGxpc3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIuZW5kc1dpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnN0YXJ0c1dpdGgoJ2EnLCAnYWJjJykgICAgICAgICAgICAgICAgLy89PiB0cnVlXG4gKiAgICAgIFIuc3RhcnRzV2l0aCgnYicsICdhYmMnKSAgICAgICAgICAgICAgICAvLz0+IGZhbHNlXG4gKiAgICAgIFIuc3RhcnRzV2l0aChbJ2EnXSwgWydhJywgJ2InLCAnYyddKSAgICAvLz0+IHRydWVcbiAqICAgICAgUi5zdGFydHNXaXRoKFsnYiddLCBbJ2EnLCAnYicsICdjJ10pICAgIC8vPT4gZmFsc2VcbiAqL1xuXG52YXIgc3RhcnRzV2l0aCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIChwcmVmaXgsIGxpc3QpIHtcbiAgcmV0dXJuIGVxdWFscyh0YWtlKHByZWZpeC5sZW5ndGgsIGxpc3QpLCBwcmVmaXgpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHN0YXJ0c1dpdGg7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuLyoqXG4gKiBTdWJ0cmFjdHMgaXRzIHNlY29uZCBhcmd1bWVudCBmcm9tIGl0cyBmaXJzdCBhcmd1bWVudC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAc2lnIE51bWJlciAtPiBOdW1iZXIgLT4gTnVtYmVyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBUaGUgZmlyc3QgdmFsdWUuXG4gKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgc2Vjb25kIHZhbHVlLlxuICogQHJldHVybiB7TnVtYmVyfSBUaGUgcmVzdWx0IG9mIGBhIC0gYmAuXG4gKiBAc2VlIFIuYWRkXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi5zdWJ0cmFjdCgxMCwgOCk7IC8vPT4gMlxuICpcbiAqICAgICAgY29uc3QgbWludXM1ID0gUi5zdWJ0cmFjdChSLl9fLCA1KTtcbiAqICAgICAgbWludXM1KDE3KTsgLy89PiAxMlxuICpcbiAqICAgICAgY29uc3QgY29tcGxlbWVudGFyeUFuZ2xlID0gUi5zdWJ0cmFjdCg5MCk7XG4gKiAgICAgIGNvbXBsZW1lbnRhcnlBbmdsZSgzMCk7IC8vPT4gNjBcbiAqICAgICAgY29tcGxlbWVudGFyeUFuZ2xlKDcyKTsgLy89PiAxOFxuICovXG5cbnZhciBzdWJ0cmFjdCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIpIHtcbiAgcmV0dXJuIE51bWJlcihhKSAtIE51bWJlcihiKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzdWJ0cmFjdDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgY29uY2F0IGZyb20gXCIuL2NvbmNhdC5qc1wiO1xuaW1wb3J0IGRpZmZlcmVuY2UgZnJvbSBcIi4vZGlmZmVyZW5jZS5qc1wiO1xuLyoqXG4gKiBGaW5kcyB0aGUgc2V0IChpLmUuIG5vIGR1cGxpY2F0ZXMpIG9mIGFsbCBlbGVtZW50cyBjb250YWluZWQgaW4gdGhlIGZpcnN0IG9yXG4gKiBzZWNvbmQgbGlzdCwgYnV0IG5vdCBib3RoLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBbKl0gLT4gWypdIC0+IFsqXVxuICogQHBhcmFtIHtBcnJheX0gbGlzdDEgVGhlIGZpcnN0IGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGVsZW1lbnRzIGluIGBsaXN0MWAgb3IgYGxpc3QyYCwgYnV0IG5vdCBib3RoLlxuICogQHNlZSBSLnN5bW1ldHJpY0RpZmZlcmVuY2VXaXRoLCBSLmRpZmZlcmVuY2UsIFIuZGlmZmVyZW5jZVdpdGhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnN5bW1ldHJpY0RpZmZlcmVuY2UoWzEsMiwzLDRdLCBbNyw2LDUsNCwzXSk7IC8vPT4gWzEsMiw3LDYsNV1cbiAqICAgICAgUi5zeW1tZXRyaWNEaWZmZXJlbmNlKFs3LDYsNSw0LDNdLCBbMSwyLDMsNF0pOyAvLz0+IFs3LDYsNSwxLDJdXG4gKi9cblxudmFyIHN5bW1ldHJpY0RpZmZlcmVuY2UgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBzeW1tZXRyaWNEaWZmZXJlbmNlKGxpc3QxLCBsaXN0Mikge1xuICByZXR1cm4gY29uY2F0KGRpZmZlcmVuY2UobGlzdDEsIGxpc3QyKSwgZGlmZmVyZW5jZShsaXN0MiwgbGlzdDEpKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzeW1tZXRyaWNEaWZmZXJlbmNlOyIsImltcG9ydCBfY3VycnkzIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTMuanNcIjtcbmltcG9ydCBjb25jYXQgZnJvbSBcIi4vY29uY2F0LmpzXCI7XG5pbXBvcnQgZGlmZmVyZW5jZVdpdGggZnJvbSBcIi4vZGlmZmVyZW5jZVdpdGguanNcIjtcbi8qKlxuICogRmluZHMgdGhlIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBvZiBhbGwgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSBmaXJzdCBvclxuICogc2Vjb25kIGxpc3QsIGJ1dCBub3QgYm90aC4gRHVwbGljYXRpb24gaXMgZGV0ZXJtaW5lZCBhY2NvcmRpbmcgdG8gdGhlIHZhbHVlXG4gKiByZXR1cm5lZCBieSBhcHBseWluZyB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIHRvIHR3byBsaXN0IGVsZW1lbnRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjE5LjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyAoKGEsIGEpIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV0gLT4gW2FdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkIEEgcHJlZGljYXRlIHVzZWQgdG8gdGVzdCB3aGV0aGVyIHR3byBpdGVtcyBhcmUgZXF1YWwuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgbGlzdC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBzZWNvbmQgbGlzdC5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgZWxlbWVudHMgaW4gYGxpc3QxYCBvciBgbGlzdDJgLCBidXQgbm90IGJvdGguXG4gKiBAc2VlIFIuc3ltbWV0cmljRGlmZmVyZW5jZSwgUi5kaWZmZXJlbmNlLCBSLmRpZmZlcmVuY2VXaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgZXFBID0gUi5lcUJ5KFIucHJvcCgnYScpKTtcbiAqICAgICAgY29uc3QgbDEgPSBbe2E6IDF9LCB7YTogMn0sIHthOiAzfSwge2E6IDR9XTtcbiAqICAgICAgY29uc3QgbDIgPSBbe2E6IDN9LCB7YTogNH0sIHthOiA1fSwge2E6IDZ9XTtcbiAqICAgICAgUi5zeW1tZXRyaWNEaWZmZXJlbmNlV2l0aChlcUEsIGwxLCBsMik7IC8vPT4gW3thOiAxfSwge2E6IDJ9LCB7YTogNX0sIHthOiA2fV1cbiAqL1xuXG52YXIgc3ltbWV0cmljRGlmZmVyZW5jZVdpdGggPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MyhmdW5jdGlvbiBzeW1tZXRyaWNEaWZmZXJlbmNlV2l0aChwcmVkLCBsaXN0MSwgbGlzdDIpIHtcbiAgcmV0dXJuIGNvbmNhdChkaWZmZXJlbmNlV2l0aChwcmVkLCBsaXN0MSwgbGlzdDIpLCBkaWZmZXJlbmNlV2l0aChwcmVkLCBsaXN0MiwgbGlzdDEpKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBzeW1tZXRyaWNEaWZmZXJlbmNlV2l0aDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgc2xpY2UgZnJvbSBcIi4vc2xpY2UuanNcIjtcbi8qKlxuICogUmV0dXJucyBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIGxhc3QgYG5gIGVsZW1lbnRzIG9mIGEgZ2l2ZW4gbGlzdCwgcGFzc2luZ1xuICogZWFjaCB2YWx1ZSB0byB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIGZ1bmN0aW9uLCBhbmQgdGVybWluYXRpbmcgd2hlbiB0aGVcbiAqIHByZWRpY2F0ZSBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWAuIEV4Y2x1ZGVzIHRoZSBlbGVtZW50IHRoYXQgY2F1c2VkIHRoZVxuICogcHJlZGljYXRlIGZ1bmN0aW9uIHRvIGZhaWwuIFRoZSBwcmVkaWNhdGUgZnVuY3Rpb24gaXMgcGFzc2VkIG9uZSBhcmd1bWVudDpcbiAqICoodmFsdWUpKi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiBbYV0gLT4gW2FdXG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IHhzIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm4ge0FycmF5fSBBIG5ldyBhcnJheS5cbiAqIEBzZWUgUi5kcm9wTGFzdFdoaWxlLCBSLmFkZEluZGV4XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgaXNOb3RPbmUgPSB4ID0+IHggIT09IDE7XG4gKlxuICogICAgICBSLnRha2VMYXN0V2hpbGUoaXNOb3RPbmUsIFsxLCAyLCAzLCA0XSk7IC8vPT4gWzIsIDMsIDRdXG4gKlxuICogICAgICBSLnRha2VMYXN0V2hpbGUoeCA9PiB4ICE9PSAnUicgLCAnUmFtZGEnKTsgLy89PiAnYW1kYSdcbiAqL1xuXG52YXIgdGFrZUxhc3RXaGlsZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIHRha2VMYXN0V2hpbGUoZm4sIHhzKSB7XG4gIHZhciBpZHggPSB4cy5sZW5ndGggLSAxO1xuXG4gIHdoaWxlIChpZHggPj0gMCAmJiBmbih4c1tpZHhdKSkge1xuICAgIGlkeCAtPSAxO1xuICB9XG5cbiAgcmV0dXJuIHNsaWNlKGlkeCArIDEsIEluZmluaXR5LCB4cyk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdGFrZUxhc3RXaGlsZTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9fY3VycnkyLmpzXCI7XG5pbXBvcnQgX3JlZHVjZWQgZnJvbSBcIi4vX3JlZHVjZWQuanNcIjtcbmltcG9ydCBfeGZCYXNlIGZyb20gXCIuL194ZkJhc2UuanNcIjtcblxudmFyIFhUYWtlV2hpbGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYVGFrZVdoaWxlKGYsIHhmKSB7XG4gICAgdGhpcy54ZiA9IHhmO1xuICAgIHRoaXMuZiA9IGY7XG4gIH1cblxuICBYVGFrZVdoaWxlLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL2luaXQnXSA9IF94ZkJhc2UuaW5pdDtcbiAgWFRha2VXaGlsZS5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9yZXN1bHQnXSA9IF94ZkJhc2UucmVzdWx0O1xuXG4gIFhUYWtlV2hpbGUucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvc3RlcCddID0gZnVuY3Rpb24gKHJlc3VsdCwgaW5wdXQpIHtcbiAgICByZXR1cm4gdGhpcy5mKGlucHV0KSA/IHRoaXMueGZbJ0BAdHJhbnNkdWNlci9zdGVwJ10ocmVzdWx0LCBpbnB1dCkgOiBfcmVkdWNlZChyZXN1bHQpO1xuICB9O1xuXG4gIHJldHVybiBYVGFrZVdoaWxlO1xufSgpO1xuXG52YXIgX3h0YWtlV2hpbGUgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiBfeHRha2VXaGlsZShmLCB4Zikge1xuICByZXR1cm4gbmV3IFhUYWtlV2hpbGUoZiwgeGYpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IF94dGFrZVdoaWxlOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbmltcG9ydCBfZGlzcGF0Y2hhYmxlIGZyb20gXCIuL2ludGVybmFsL19kaXNwYXRjaGFibGUuanNcIjtcbmltcG9ydCBfeHRha2VXaGlsZSBmcm9tIFwiLi9pbnRlcm5hbC9feHRha2VXaGlsZS5qc1wiO1xuaW1wb3J0IHNsaWNlIGZyb20gXCIuL3NsaWNlLmpzXCI7XG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBmaXJzdCBgbmAgZWxlbWVudHMgb2YgYSBnaXZlbiBsaXN0LFxuICogcGFzc2luZyBlYWNoIHZhbHVlIHRvIHRoZSBzdXBwbGllZCBwcmVkaWNhdGUgZnVuY3Rpb24sIGFuZCB0ZXJtaW5hdGluZyB3aGVuXG4gKiB0aGUgcHJlZGljYXRlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYC4gRXhjbHVkZXMgdGhlIGVsZW1lbnQgdGhhdCBjYXVzZWQgdGhlXG4gKiBwcmVkaWNhdGUgZnVuY3Rpb24gdG8gZmFpbC4gVGhlIHByZWRpY2F0ZSBmdW5jdGlvbiBpcyBwYXNzZWQgb25lIGFyZ3VtZW50OlxuICogKih2YWx1ZSkqLlxuICpcbiAqIERpc3BhdGNoZXMgdG8gdGhlIGB0YWtlV2hpbGVgIG1ldGhvZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50LCBpZiBwcmVzZW50LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV1cbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gU3RyaW5nIC0+IFN0cmluZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtBcnJheX0geHMgVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7QXJyYXl9IEEgbmV3IGFycmF5LlxuICogQHNlZSBSLmRyb3BXaGlsZSwgUi50cmFuc2R1Y2UsIFIuYWRkSW5kZXhcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBpc05vdEZvdXIgPSB4ID0+IHggIT09IDQ7XG4gKlxuICogICAgICBSLnRha2VXaGlsZShpc05vdEZvdXIsIFsxLCAyLCAzLCA0LCAzLCAyLCAxXSk7IC8vPT4gWzEsIDIsIDNdXG4gKlxuICogICAgICBSLnRha2VXaGlsZSh4ID0+IHggIT09ICdkJyAsICdSYW1kYScpOyAvLz0+ICdSYW0nXG4gKi9cblxudmFyIHRha2VXaGlsZSA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKFxuLyojX19QVVJFX18qL1xuX2Rpc3BhdGNoYWJsZShbJ3Rha2VXaGlsZSddLCBfeHRha2VXaGlsZSwgZnVuY3Rpb24gdGFrZVdoaWxlKGZuLCB4cykge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IHhzLmxlbmd0aDtcblxuICB3aGlsZSAoaWR4IDwgbGVuICYmIGZuKHhzW2lkeF0pKSB7XG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gc2xpY2UoMCwgaWR4LCB4cyk7XG59KSk7XG5cbmV4cG9ydCBkZWZhdWx0IHRha2VXaGlsZTsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9fY3VycnkyLmpzXCI7XG5pbXBvcnQgX3hmQmFzZSBmcm9tIFwiLi9feGZCYXNlLmpzXCI7XG5cbnZhciBYVGFwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gWFRhcChmLCB4Zikge1xuICAgIHRoaXMueGYgPSB4ZjtcbiAgICB0aGlzLmYgPSBmO1xuICB9XG5cbiAgWFRhcC5wcm90b3R5cGVbJ0BAdHJhbnNkdWNlci9pbml0J10gPSBfeGZCYXNlLmluaXQ7XG4gIFhUYXAucHJvdG90eXBlWydAQHRyYW5zZHVjZXIvcmVzdWx0J10gPSBfeGZCYXNlLnJlc3VsdDtcblxuICBYVGFwLnByb3RvdHlwZVsnQEB0cmFuc2R1Y2VyL3N0ZXAnXSA9IGZ1bmN0aW9uIChyZXN1bHQsIGlucHV0KSB7XG4gICAgdGhpcy5mKGlucHV0KTtcbiAgICByZXR1cm4gdGhpcy54ZlsnQEB0cmFuc2R1Y2VyL3N0ZXAnXShyZXN1bHQsIGlucHV0KTtcbiAgfTtcblxuICByZXR1cm4gWFRhcDtcbn0oKTtcblxudmFyIF94dGFwID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gX3h0YXAoZiwgeGYpIHtcbiAgcmV0dXJuIG5ldyBYVGFwKGYsIHhmKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBfeHRhcDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgX2Rpc3BhdGNoYWJsZSBmcm9tIFwiLi9pbnRlcm5hbC9fZGlzcGF0Y2hhYmxlLmpzXCI7XG5pbXBvcnQgX3h0YXAgZnJvbSBcIi4vaW50ZXJuYWwvX3h0YXAuanNcIjtcbi8qKlxuICogUnVucyB0aGUgZ2l2ZW4gZnVuY3Rpb24gd2l0aCB0aGUgc3VwcGxpZWQgb2JqZWN0LCB0aGVuIHJldHVybnMgdGhlIG9iamVjdC5cbiAqXG4gKiBBY3RzIGFzIGEgdHJhbnNkdWNlciBpZiBhIHRyYW5zZm9ybWVyIGlzIGdpdmVuIGFzIHNlY29uZCBwYXJhbWV0ZXIuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKGEgLT4gKikgLT4gYSAtPiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aXRoIGB4YC4gVGhlIHJldHVybiB2YWx1ZSBvZiBgZm5gIHdpbGwgYmUgdGhyb3duIGF3YXkuXG4gKiBAcGFyYW0geyp9IHhcbiAqIEByZXR1cm4geyp9IGB4YC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBzYXlYID0geCA9PiBjb25zb2xlLmxvZygneCBpcyAnICsgeCk7XG4gKiAgICAgIFIudGFwKHNheVgsIDEwMCk7IC8vPT4gMTAwXG4gKiAgICAgIC8vIGxvZ3MgJ3ggaXMgMTAwJ1xuICogQHN5bWIgUi50YXAoZiwgYSkgPSBhXG4gKi9cblxudmFyIHRhcCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKFxuLyojX19QVVJFX18qL1xuX2Rpc3BhdGNoYWJsZShbXSwgX3h0YXAsIGZ1bmN0aW9uIHRhcChmbiwgeCkge1xuICBmbih4KTtcbiAgcmV0dXJuIHg7XG59KSk7XG5cbmV4cG9ydCBkZWZhdWx0IHRhcDsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXNSZWdFeHAoeCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn0iLCJpbXBvcnQgX2Nsb25lUmVnRXhwIGZyb20gXCIuL2ludGVybmFsL19jbG9uZVJlZ0V4cC5qc1wiO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9pc1JlZ0V4cCBmcm9tIFwiLi9pbnRlcm5hbC9faXNSZWdFeHAuanNcIjtcbmltcG9ydCB0b1N0cmluZyBmcm9tIFwiLi90b1N0cmluZy5qc1wiO1xuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBnaXZlbiBzdHJpbmcgbWF0Y2hlcyBhIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xMi4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAc2lnIFJlZ0V4cCAtPiBTdHJpbmcgLT4gQm9vbGVhblxuICogQHBhcmFtIHtSZWdFeHB9IHBhdHRlcm5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIubWF0Y2hcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRlc3QoL154LywgJ3h5eicpOyAvLz0+IHRydWVcbiAqICAgICAgUi50ZXN0KC9eeS8sICd4eXonKTsgLy89PiBmYWxzZVxuICovXG5cbnZhciB0ZXN0ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gdGVzdChwYXR0ZXJuLCBzdHIpIHtcbiAgaWYgKCFfaXNSZWdFeHAocGF0dGVybikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCfigJh0ZXN04oCZIHJlcXVpcmVzIGEgdmFsdWUgb2YgdHlwZSBSZWdFeHAgYXMgaXRzIGZpcnN0IGFyZ3VtZW50OyByZWNlaXZlZCAnICsgdG9TdHJpbmcocGF0dGVybikpO1xuICB9XG5cbiAgcmV0dXJuIF9jbG9uZVJlZ0V4cChwYXR0ZXJuKS50ZXN0KHN0cik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdGVzdDsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgX2Fzc2VydFByb21pc2UgZnJvbSBcIi4vaW50ZXJuYWwvX2Fzc2VydFByb21pc2UuanNcIjtcbi8qKlxuICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBvblN1Y2Nlc3MgZnVuY3Rpb24gdG8gdGhlIHZhbHVlIGluc2lkZVxuICogYSBzdWNjZXNzZnVsbHkgcmVzb2x2ZWQgcHJvbWlzZS4gVGhpcyBpcyB1c2VmdWwgZm9yIHdvcmtpbmcgd2l0aCBwcm9taXNlc1xuICogaW5zaWRlIGZ1bmN0aW9uIGNvbXBvc2l0aW9ucy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yNy4xXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKGEgLT4gYikgLT4gKFByb21pc2UgZSBhKSAtPiAoUHJvbWlzZSBlIGIpXG4gKiBAc2lnIChhIC0+IChQcm9taXNlIGUgYikpIC0+IChQcm9taXNlIGUgYSkgLT4gKFByb21pc2UgZSBiKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb25TdWNjZXNzIFRoZSBmdW5jdGlvbiB0byBhcHBseS4gQ2FuIHJldHVybiBhIHZhbHVlIG9yIGEgcHJvbWlzZSBvZiBhIHZhbHVlLlxuICogQHBhcmFtIHtQcm9taXNlfSBwXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBUaGUgcmVzdWx0IG9mIGNhbGxpbmcgYHAudGhlbihvblN1Y2Nlc3MpYFxuICogQHNlZSBSLm90aGVyd2lzZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIHZhciBtYWtlUXVlcnkgPSAoZW1haWwpID0+ICh7IHF1ZXJ5OiB7IGVtYWlsIH19KTtcbiAqXG4gKiAgICAgIC8vZ2V0TWVtYmVyTmFtZSA6OiBTdHJpbmcgLT4gUHJvbWlzZSAoe2ZpcnN0TmFtZSwgbGFzdE5hbWV9KVxuICogICAgICB2YXIgZ2V0TWVtYmVyTmFtZSA9IFIucGlwZShcbiAqICAgICAgICBtYWtlUXVlcnksXG4gKiAgICAgICAgZmV0Y2hNZW1iZXIsXG4gKiAgICAgICAgUi5hbmRUaGVuKFIucGljayhbJ2ZpcnN0TmFtZScsICdsYXN0TmFtZSddKSlcbiAqICAgICAgKTtcbiAqL1xuXG52YXIgYW5kVGhlbiA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIGFuZFRoZW4oZiwgcCkge1xuICBfYXNzZXJ0UHJvbWlzZSgnYW5kVGhlbicsIHApO1xuXG4gIHJldHVybiBwLnRoZW4oZik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgYW5kVGhlbjsiLCJpbXBvcnQgaW52b2tlciBmcm9tIFwiLi9pbnZva2VyLmpzXCI7XG4vKipcbiAqIFRoZSBsb3dlciBjYXNlIHZlcnNpb24gb2YgYSBzdHJpbmcuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBsb3dlciBjYXNlLlxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgbG93ZXIgY2FzZSB2ZXJzaW9uIG9mIGBzdHJgLlxuICogQHNlZSBSLnRvVXBwZXJcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRvTG93ZXIoJ1hZWicpOyAvLz0+ICd4eXonXG4gKi9cblxudmFyIHRvTG93ZXIgPVxuLyojX19QVVJFX18qL1xuaW52b2tlcigwLCAndG9Mb3dlckNhc2UnKTtcbmV4cG9ydCBkZWZhdWx0IHRvTG93ZXI7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5MS5qc1wiO1xuaW1wb3J0IF9oYXMgZnJvbSBcIi4vaW50ZXJuYWwvX2hhcy5qc1wiO1xuLyoqXG4gKiBDb252ZXJ0cyBhbiBvYmplY3QgaW50byBhbiBhcnJheSBvZiBrZXksIHZhbHVlIGFycmF5cy4gT25seSB0aGUgb2JqZWN0J3NcbiAqIG93biBwcm9wZXJ0aWVzIGFyZSB1c2VkLlxuICogTm90ZSB0aGF0IHRoZSBvcmRlciBvZiB0aGUgb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGNvbnNpc3RlbnRcbiAqIGFjcm9zcyBkaWZmZXJlbnQgSlMgcGxhdGZvcm1zLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjQuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7U3RyaW5nOiAqfSAtPiBbW1N0cmluZywqXV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IGZyb21cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBrZXksIHZhbHVlIGFycmF5cyBmcm9tIHRoZSBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAqIEBzZWUgUi5mcm9tUGFpcnNcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRvUGFpcnMoe2E6IDEsIGI6IDIsIGM6IDN9KTsgLy89PiBbWydhJywgMV0sIFsnYicsIDJdLCBbJ2MnLCAzXV1cbiAqL1xuXG52YXIgdG9QYWlycyA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkxKGZ1bmN0aW9uIHRvUGFpcnMob2JqKSB7XG4gIHZhciBwYWlycyA9IFtdO1xuXG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgaWYgKF9oYXMocHJvcCwgb2JqKSkge1xuICAgICAgcGFpcnNbcGFpcnMubGVuZ3RoXSA9IFtwcm9wLCBvYmpbcHJvcF1dO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYWlycztcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB0b1BhaXJzOyIsImltcG9ydCBfY3VycnkxIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTEuanNcIjtcbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0IGludG8gYW4gYXJyYXkgb2Yga2V5LCB2YWx1ZSBhcnJheXMuIFRoZSBvYmplY3QncyBvd25cbiAqIHByb3BlcnRpZXMgYW5kIHByb3RvdHlwZSBwcm9wZXJ0aWVzIGFyZSB1c2VkLiBOb3RlIHRoYXQgdGhlIG9yZGVyIG9mIHRoZVxuICogb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGNvbnNpc3RlbnQgYWNyb3NzIGRpZmZlcmVudCBKU1xuICogcGxhdGZvcm1zLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjQuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7U3RyaW5nOiAqfSAtPiBbW1N0cmluZywqXV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBleHRyYWN0IGZyb21cbiAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBrZXksIHZhbHVlIGFycmF5cyBmcm9tIHRoZSBvYmplY3QncyBvd25cbiAqICAgICAgICAgYW5kIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IEYgPSBmdW5jdGlvbigpIHsgdGhpcy54ID0gJ1gnOyB9O1xuICogICAgICBGLnByb3RvdHlwZS55ID0gJ1knO1xuICogICAgICBjb25zdCBmID0gbmV3IEYoKTtcbiAqICAgICAgUi50b1BhaXJzSW4oZik7IC8vPT4gW1sneCcsJ1gnXSwgWyd5JywnWSddXVxuICovXG5cbnZhciB0b1BhaXJzSW4gPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiB0b1BhaXJzSW4ob2JqKSB7XG4gIHZhciBwYWlycyA9IFtdO1xuXG4gIGZvciAodmFyIHByb3AgaW4gb2JqKSB7XG4gICAgcGFpcnNbcGFpcnMubGVuZ3RoXSA9IFtwcm9wLCBvYmpbcHJvcF1dO1xuICB9XG5cbiAgcmV0dXJuIHBhaXJzO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHRvUGFpcnNJbjsiLCJpbXBvcnQgaW52b2tlciBmcm9tIFwiLi9pbnZva2VyLmpzXCI7XG4vKipcbiAqIFRoZSB1cHBlciBjYXNlIHZlcnNpb24gb2YgYSBzdHJpbmcuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuOS4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB1cHBlciBjYXNlLlxuICogQHJldHVybiB7U3RyaW5nfSBUaGUgdXBwZXIgY2FzZSB2ZXJzaW9uIG9mIGBzdHJgLlxuICogQHNlZSBSLnRvTG93ZXJcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRvVXBwZXIoJ2FiYycpOyAvLz0+ICdBQkMnXG4gKi9cblxudmFyIHRvVXBwZXIgPVxuLyojX19QVVJFX18qL1xuaW52b2tlcigwLCAndG9VcHBlckNhc2UnKTtcbmV4cG9ydCBkZWZhdWx0IHRvVXBwZXI7IiwiaW1wb3J0IF9yZWR1Y2UgZnJvbSBcIi4vaW50ZXJuYWwvX3JlZHVjZS5qc1wiO1xuaW1wb3J0IF94d3JhcCBmcm9tIFwiLi9pbnRlcm5hbC9feHdyYXAuanNcIjtcbmltcG9ydCBjdXJyeU4gZnJvbSBcIi4vY3VycnlOLmpzXCI7XG4vKipcbiAqIEluaXRpYWxpemVzIGEgdHJhbnNkdWNlciB1c2luZyBzdXBwbGllZCBpdGVyYXRvciBmdW5jdGlvbi4gUmV0dXJucyBhIHNpbmdsZVxuICogaXRlbSBieSBpdGVyYXRpbmcgdGhyb3VnaCB0aGUgbGlzdCwgc3VjY2Vzc2l2ZWx5IGNhbGxpbmcgdGhlIHRyYW5zZm9ybWVkXG4gKiBpdGVyYXRvciBmdW5jdGlvbiBhbmQgcGFzc2luZyBpdCBhbiBhY2N1bXVsYXRvciB2YWx1ZSBhbmQgdGhlIGN1cnJlbnQgdmFsdWVcbiAqIGZyb20gdGhlIGFycmF5LCBhbmQgdGhlbiBwYXNzaW5nIHRoZSByZXN1bHQgdG8gdGhlIG5leHQgY2FsbC5cbiAqXG4gKiBUaGUgaXRlcmF0b3IgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIHZhbHVlczogKihhY2MsIHZhbHVlKSouIEl0IHdpbGwgYmVcbiAqIHdyYXBwZWQgYXMgYSB0cmFuc2Zvcm1lciB0byBpbml0aWFsaXplIHRoZSB0cmFuc2R1Y2VyLiBBIHRyYW5zZm9ybWVyIGNhbiBiZVxuICogcGFzc2VkIGRpcmVjdGx5IGluIHBsYWNlIG9mIGFuIGl0ZXJhdG9yIGZ1bmN0aW9uLiBJbiBib3RoIGNhc2VzLCBpdGVyYXRpb25cbiAqIG1heSBiZSBzdG9wcGVkIGVhcmx5IHdpdGggdGhlIFtgUi5yZWR1Y2VkYF0oI3JlZHVjZWQpIGZ1bmN0aW9uLlxuICpcbiAqIEEgdHJhbnNkdWNlciBpcyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBhIHRyYW5zZm9ybWVyIGFuZCByZXR1cm5zIGFcbiAqIHRyYW5zZm9ybWVyIGFuZCBjYW4gYmUgY29tcG9zZWQgZGlyZWN0bHkuXG4gKlxuICogQSB0cmFuc2Zvcm1lciBpcyBhbiBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhIDItYXJpdHkgcmVkdWNpbmcgaXRlcmF0b3JcbiAqIGZ1bmN0aW9uLCBzdGVwLCAwLWFyaXR5IGluaXRpYWwgdmFsdWUgZnVuY3Rpb24sIGluaXQsIGFuZCAxLWFyaXR5IHJlc3VsdFxuICogZXh0cmFjdGlvbiBmdW5jdGlvbiwgcmVzdWx0LiBUaGUgc3RlcCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBpdGVyYXRvclxuICogZnVuY3Rpb24gaW4gcmVkdWNlLiBUaGUgcmVzdWx0IGZ1bmN0aW9uIGlzIHVzZWQgdG8gY29udmVydCB0aGUgZmluYWxcbiAqIGFjY3VtdWxhdG9yIGludG8gdGhlIHJldHVybiB0eXBlIGFuZCBpbiBtb3N0IGNhc2VzIGlzXG4gKiBbYFIuaWRlbnRpdHlgXSgjaWRlbnRpdHkpLiBUaGUgaW5pdCBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGFuXG4gKiBpbml0aWFsIGFjY3VtdWxhdG9yLCBidXQgaXMgaWdub3JlZCBieSB0cmFuc2R1Y2UuXG4gKlxuICogVGhlIGl0ZXJhdGlvbiBpcyBwZXJmb3JtZWQgd2l0aCBbYFIucmVkdWNlYF0oI3JlZHVjZSkgYWZ0ZXIgaW5pdGlhbGl6aW5nIHRoZSB0cmFuc2R1Y2VyLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEyLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChjIC0+IGMpIC0+ICgoYSwgYikgLT4gYSkgLT4gYSAtPiBbYl0gLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0geGYgVGhlIHRyYW5zZHVjZXIgZnVuY3Rpb24uIFJlY2VpdmVzIGEgdHJhbnNmb3JtZXIgYW5kIHJldHVybnMgYSB0cmFuc2Zvcm1lci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gUmVjZWl2ZXMgdHdvIHZhbHVlcywgdGhlIGFjY3VtdWxhdG9yIGFuZCB0aGVcbiAqICAgICAgICBjdXJyZW50IGVsZW1lbnQgZnJvbSB0aGUgYXJyYXkuIFdyYXBwZWQgYXMgdHJhbnNmb3JtZXIsIGlmIG5lY2Vzc2FyeSwgYW5kIHVzZWQgdG9cbiAqICAgICAgICBpbml0aWFsaXplIHRoZSB0cmFuc2R1Y2VyXG4gKiBAcGFyYW0geyp9IGFjYyBUaGUgaW5pdGlhbCBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGxpc3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybiB7Kn0gVGhlIGZpbmFsLCBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgUi5yZWR1Y2UsIFIucmVkdWNlZCwgUi5pbnRvXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgY29uc3QgbnVtYmVycyA9IFsxLCAyLCAzLCA0XTtcbiAqICAgICAgY29uc3QgdHJhbnNkdWNlciA9IFIuY29tcG9zZShSLm1hcChSLmFkZCgxKSksIFIudGFrZSgyKSk7XG4gKiAgICAgIFIudHJhbnNkdWNlKHRyYW5zZHVjZXIsIFIuZmxpcChSLmFwcGVuZCksIFtdLCBudW1iZXJzKTsgLy89PiBbMiwgM11cbiAqXG4gKiAgICAgIGNvbnN0IGlzT2RkID0gKHgpID0+IHggJSAyID09PSAxO1xuICogICAgICBjb25zdCBmaXJzdE9kZFRyYW5zZHVjZXIgPSBSLmNvbXBvc2UoUi5maWx0ZXIoaXNPZGQpLCBSLnRha2UoMSkpO1xuICogICAgICBSLnRyYW5zZHVjZShmaXJzdE9kZFRyYW5zZHVjZXIsIFIuZmxpcChSLmFwcGVuZCksIFtdLCBSLnJhbmdlKDAsIDEwMCkpOyAvLz0+IFsxXVxuICovXG5cbnZhciB0cmFuc2R1Y2UgPVxuLyojX19QVVJFX18qL1xuY3VycnlOKDQsIGZ1bmN0aW9uIHRyYW5zZHVjZSh4ZiwgZm4sIGFjYywgbGlzdCkge1xuICByZXR1cm4gX3JlZHVjZSh4Zih0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBfeHdyYXAoZm4pIDogZm4pLCBhY2MsIGxpc3QpO1xufSk7XG5leHBvcnQgZGVmYXVsdCB0cmFuc2R1Y2U7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5MS5qc1wiO1xuLyoqXG4gKiBUcmFuc3Bvc2VzIHRoZSByb3dzIGFuZCBjb2x1bW5zIG9mIGEgMkQgbGlzdC5cbiAqIFdoZW4gcGFzc2VkIGEgbGlzdCBvZiBgbmAgbGlzdHMgb2YgbGVuZ3RoIGB4YCxcbiAqIHJldHVybnMgYSBsaXN0IG9mIGB4YCBsaXN0cyBvZiBsZW5ndGggYG5gLlxuICpcbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbW2FdXSAtPiBbW2FdXVxuICogQHBhcmFtIHtBcnJheX0gbGlzdCBBIDJEIGxpc3RcbiAqIEByZXR1cm4ge0FycmF5fSBBIDJEIGxpc3RcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRyYW5zcG9zZShbWzEsICdhJ10sIFsyLCAnYiddLCBbMywgJ2MnXV0pIC8vPT4gW1sxLCAyLCAzXSwgWydhJywgJ2InLCAnYyddXVxuICogICAgICBSLnRyYW5zcG9zZShbWzEsIDIsIDNdLCBbJ2EnLCAnYicsICdjJ11dKSAvLz0+IFtbMSwgJ2EnXSwgWzIsICdiJ10sIFszLCAnYyddXVxuICpcbiAqICAgICAgLy8gSWYgc29tZSBvZiB0aGUgcm93cyBhcmUgc2hvcnRlciB0aGFuIHRoZSBmb2xsb3dpbmcgcm93cywgdGhlaXIgZWxlbWVudHMgYXJlIHNraXBwZWQ6XG4gKiAgICAgIFIudHJhbnNwb3NlKFtbMTAsIDExXSwgWzIwXSwgW10sIFszMCwgMzEsIDMyXV0pIC8vPT4gW1sxMCwgMjAsIDMwXSwgWzExLCAzMV0sIFszMl1dXG4gKiBAc3ltYiBSLnRyYW5zcG9zZShbW2FdLCBbYl0sIFtjXV0pID0gW2EsIGIsIGNdXG4gKiBAc3ltYiBSLnRyYW5zcG9zZShbW2EsIGJdLCBbYywgZF1dKSA9IFtbYSwgY10sIFtiLCBkXV1cbiAqIEBzeW1iIFIudHJhbnNwb3NlKFtbYSwgYl0sIFtjXV0pID0gW1thLCBjXSwgW2JdXVxuICovXG5cbnZhciB0cmFuc3Bvc2UgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiB0cmFuc3Bvc2Uob3V0ZXJsaXN0KSB7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlIChpIDwgb3V0ZXJsaXN0Lmxlbmd0aCkge1xuICAgIHZhciBpbm5lcmxpc3QgPSBvdXRlcmxpc3RbaV07XG4gICAgdmFyIGogPSAwO1xuXG4gICAgd2hpbGUgKGogPCBpbm5lcmxpc3QubGVuZ3RoKSB7XG4gICAgICBpZiAodHlwZW9mIHJlc3VsdFtqXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmVzdWx0W2pdID0gW107XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdFtqXS5wdXNoKGlubmVybGlzdFtqXSk7XG4gICAgICBqICs9IDE7XG4gICAgfVxuXG4gICAgaSArPSAxO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB0cmFuc3Bvc2U7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5My5qc1wiO1xuaW1wb3J0IG1hcCBmcm9tIFwiLi9tYXAuanNcIjtcbmltcG9ydCBzZXF1ZW5jZSBmcm9tIFwiLi9zZXF1ZW5jZS5qc1wiO1xuLyoqXG4gKiBNYXBzIGFuIFtBcHBsaWNhdGl2ZV0oaHR0cHM6Ly9naXRodWIuY29tL2ZhbnRhc3lsYW5kL2ZhbnRhc3ktbGFuZCNhcHBsaWNhdGl2ZSktcmV0dXJuaW5nXG4gKiBmdW5jdGlvbiBvdmVyIGEgW1RyYXZlcnNhYmxlXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI3RyYXZlcnNhYmxlKSxcbiAqIHRoZW4gdXNlcyBbYHNlcXVlbmNlYF0oI3NlcXVlbmNlKSB0byB0cmFuc2Zvcm0gdGhlIHJlc3VsdGluZyBUcmF2ZXJzYWJsZSBvZiBBcHBsaWNhdGl2ZVxuICogaW50byBhbiBBcHBsaWNhdGl2ZSBvZiBUcmF2ZXJzYWJsZS5cbiAqXG4gKiBEaXNwYXRjaGVzIHRvIHRoZSBgdHJhdmVyc2VgIG1ldGhvZCBvZiB0aGUgdGhpcmQgYXJndW1lbnQsIGlmIHByZXNlbnQuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTkuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgKEFwcGxpY2F0aXZlIGYsIFRyYXZlcnNhYmxlIHQpID0+IChhIC0+IGYgYSkgLT4gKGEgLT4gZiBiKSAtPiB0IGEgLT4gZiAodCBiKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gb2ZcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAqIEBwYXJhbSB7Kn0gdHJhdmVyc2FibGVcbiAqIEByZXR1cm4geyp9XG4gKiBAc2VlIFIuc2VxdWVuY2VcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyBSZXR1cm5zIGBNYXliZS5Ob3RoaW5nYCBpZiB0aGUgZ2l2ZW4gZGl2aXNvciBpcyBgMGBcbiAqICAgICAgY29uc3Qgc2FmZURpdiA9IG4gPT4gZCA9PiBkID09PSAwID8gTWF5YmUuTm90aGluZygpIDogTWF5YmUuSnVzdChuIC8gZClcbiAqXG4gKiAgICAgIFIudHJhdmVyc2UoTWF5YmUub2YsIHNhZmVEaXYoMTApLCBbMiwgNCwgNV0pOyAvLz0+IE1heWJlLkp1c3QoWzUsIDIuNSwgMl0pXG4gKiAgICAgIFIudHJhdmVyc2UoTWF5YmUub2YsIHNhZmVEaXYoMTApLCBbMiwgMCwgNV0pOyAvLz0+IE1heWJlLk5vdGhpbmdcbiAqL1xuXG52YXIgdHJhdmVyc2UgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MyhmdW5jdGlvbiB0cmF2ZXJzZShvZiwgZiwgdHJhdmVyc2FibGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0cmF2ZXJzYWJsZVsnZmFudGFzeS1sYW5kL3RyYXZlcnNlJ10gPT09ICdmdW5jdGlvbicgPyB0cmF2ZXJzYWJsZVsnZmFudGFzeS1sYW5kL3RyYXZlcnNlJ10oZiwgb2YpIDogc2VxdWVuY2Uob2YsIG1hcChmLCB0cmF2ZXJzYWJsZSkpO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHRyYXZlcnNlOyIsImltcG9ydCBfY3VycnkxIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTEuanNcIjtcbnZhciB3cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgKyAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjgnICsgJ1xcdTIwMjlcXHVGRUZGJztcbnZhciB6ZXJvV2lkdGggPSAnXFx1MjAwYic7XG52YXIgaGFzUHJvdG9UcmltID0gdHlwZW9mIFN0cmluZy5wcm90b3R5cGUudHJpbSA9PT0gJ2Z1bmN0aW9uJztcbi8qKlxuICogUmVtb3ZlcyAoc3RyaXBzKSB3aGl0ZXNwYWNlIGZyb20gYm90aCBlbmRzIG9mIHRoZSBzdHJpbmcuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuNi4wXG4gKiBAY2F0ZWdvcnkgU3RyaW5nXG4gKiBAc2lnIFN0cmluZyAtPiBTdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byB0cmltLlxuICogQHJldHVybiB7U3RyaW5nfSBUcmltbWVkIHZlcnNpb24gb2YgYHN0cmAuXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50cmltKCcgICB4eXogICcpOyAvLz0+ICd4eXonXG4gKiAgICAgIFIubWFwKFIudHJpbSwgUi5zcGxpdCgnLCcsICd4LCB5LCB6JykpOyAvLz0+IFsneCcsICd5JywgJ3onXVxuICovXG5cbnZhciB0cmltID0gIWhhc1Byb3RvVHJpbSB8fFxuLyojX19QVVJFX18qL1xud3MudHJpbSgpIHx8ICFcbi8qI19fUFVSRV9fKi9cbnplcm9XaWR0aC50cmltKCkgP1xuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiB0cmltKHN0cikge1xuICB2YXIgYmVnaW5SeCA9IG5ldyBSZWdFeHAoJ15bJyArIHdzICsgJ11bJyArIHdzICsgJ10qJyk7XG4gIHZhciBlbmRSeCA9IG5ldyBSZWdFeHAoJ1snICsgd3MgKyAnXVsnICsgd3MgKyAnXSokJyk7XG4gIHJldHVybiBzdHIucmVwbGFjZShiZWdpblJ4LCAnJykucmVwbGFjZShlbmRSeCwgJycpO1xufSkgOlxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnRyaW0oKTtcbn0pO1xuZXhwb3J0IGRlZmF1bHQgdHJpbTsiLCJpbXBvcnQgX2FyaXR5IGZyb20gXCIuL2ludGVybmFsL19hcml0eS5qc1wiO1xuaW1wb3J0IF9jb25jYXQgZnJvbSBcIi4vaW50ZXJuYWwvX2NvbmNhdC5qc1wiO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuLyoqXG4gKiBgdHJ5Q2F0Y2hgIHRha2VzIHR3byBmdW5jdGlvbnMsIGEgYHRyeWVyYCBhbmQgYSBgY2F0Y2hlcmAuIFRoZSByZXR1cm5lZFxuICogZnVuY3Rpb24gZXZhbHVhdGVzIHRoZSBgdHJ5ZXJgOyBpZiBpdCBkb2VzIG5vdCB0aHJvdywgaXQgc2ltcGx5IHJldHVybnMgdGhlXG4gKiByZXN1bHQuIElmIHRoZSBgdHJ5ZXJgICpkb2VzKiB0aHJvdywgdGhlIHJldHVybmVkIGZ1bmN0aW9uIGV2YWx1YXRlcyB0aGVcbiAqIGBjYXRjaGVyYCBmdW5jdGlvbiBhbmQgcmV0dXJucyBpdHMgcmVzdWx0LiBOb3RlIHRoYXQgZm9yIGVmZmVjdGl2ZVxuICogY29tcG9zaXRpb24gd2l0aCB0aGlzIGZ1bmN0aW9uLCBib3RoIHRoZSBgdHJ5ZXJgIGFuZCBgY2F0Y2hlcmAgZnVuY3Rpb25zXG4gKiBtdXN0IHJldHVybiB0aGUgc2FtZSB0eXBlIG9mIHJlc3VsdHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMjAuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICguLi54IC0+IGEpIC0+ICgoZSwgLi4ueCkgLT4gYSkgLT4gKC4uLnggLT4gYSlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyeWVyIFRoZSBmdW5jdGlvbiB0aGF0IG1heSB0aHJvdy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhdGNoZXIgVGhlIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBldmFsdWF0ZWQgaWYgYHRyeWVyYCB0aHJvd3MuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gdGhhdCB3aWxsIGNhdGNoIGV4Y2VwdGlvbnMgYW5kIHNlbmQgdGhlbiB0byB0aGUgY2F0Y2hlci5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnRyeUNhdGNoKFIucHJvcCgneCcpLCBSLkYpKHt4OiB0cnVlfSk7IC8vPT4gdHJ1ZVxuICogICAgICBSLnRyeUNhdGNoKCgpID0+IHsgdGhyb3cgJ2Zvbyd9LCBSLmFsd2F5cygnY2F0Y2hlZCcpKSgnYmFyJykgLy8gPT4gJ2NhdGNoZWQnXG4gKiAgICAgIFIudHJ5Q2F0Y2goUi50aW1lcyhSLmlkZW50aXR5KSwgUi5hbHdheXMoW10pKSgncycpIC8vID0+IFtdXG4gKiAgICAgIFIudHJ5Q2F0Y2goKCkgPT4geyB0aHJvdyAndGhpcyBpcyBub3QgYSB2YWxpZCB2YWx1ZSd9LCAoZXJyLCB2YWx1ZSk9Pih7ZXJyb3IgOiBlcnIsICB2YWx1ZSB9KSkoJ2JhcicpIC8vID0+IHsnZXJyb3InOiAndGhpcyBpcyBub3QgYSB2YWxpZCB2YWx1ZScsICd2YWx1ZSc6ICdiYXInfVxuICovXG5cbnZhciB0cnlDYXRjaCA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIF90cnlDYXRjaCh0cnllciwgY2F0Y2hlcikge1xuICByZXR1cm4gX2FyaXR5KHRyeWVyLmxlbmd0aCwgZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdHJ5ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gY2F0Y2hlci5hcHBseSh0aGlzLCBfY29uY2F0KFtlXSwgYXJndW1lbnRzKSk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB0cnlDYXRjaDsiLCJpbXBvcnQgX2N1cnJ5MSBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkxLmpzXCI7XG4vKipcbiAqIFRha2VzIGEgZnVuY3Rpb24gYGZuYCwgd2hpY2ggdGFrZXMgYSBzaW5nbGUgYXJyYXkgYXJndW1lbnQsIGFuZCByZXR1cm5zIGFcbiAqIGZ1bmN0aW9uIHdoaWNoOlxuICpcbiAqICAgLSB0YWtlcyBhbnkgbnVtYmVyIG9mIHBvc2l0aW9uYWwgYXJndW1lbnRzO1xuICogICAtIHBhc3NlcyB0aGVzZSBhcmd1bWVudHMgdG8gYGZuYCBhcyBhbiBhcnJheTsgYW5kXG4gKiAgIC0gcmV0dXJucyB0aGUgcmVzdWx0LlxuICpcbiAqIEluIG90aGVyIHdvcmRzLCBgUi51bmFwcGx5YCBkZXJpdmVzIGEgdmFyaWFkaWMgZnVuY3Rpb24gZnJvbSBhIGZ1bmN0aW9uIHdoaWNoXG4gKiB0YWtlcyBhbiBhcnJheS4gYFIudW5hcHBseWAgaXMgdGhlIGludmVyc2Ugb2YgW2BSLmFwcGx5YF0oI2FwcGx5KS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC44LjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHNpZyAoWyouLi5dIC0+IGEpIC0+ICgqLi4uIC0+IGEpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAc2VlIFIuYXBwbHlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnVuYXBwbHkoSlNPTi5zdHJpbmdpZnkpKDEsIDIsIDMpOyAvLz0+ICdbMSwyLDNdJ1xuICogQHN5bWIgUi51bmFwcGx5KGYpKGEsIGIpID0gZihbYSwgYl0pXG4gKi9cblxudmFyIHVuYXBwbHkgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MShmdW5jdGlvbiB1bmFwcGx5KGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZuKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkpO1xuICB9O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHVuYXBwbHk7IiwiaW1wb3J0IF9jdXJyeTEgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5MS5qc1wiO1xuaW1wb3J0IG5BcnkgZnJvbSBcIi4vbkFyeS5qc1wiO1xuLyoqXG4gKiBXcmFwcyBhIGZ1bmN0aW9uIG9mIGFueSBhcml0eSAoaW5jbHVkaW5nIG51bGxhcnkpIGluIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzXG4gKiBleGFjdGx5IDEgcGFyYW1ldGVyLiBBbnkgZXh0cmFuZW91cyBwYXJhbWV0ZXJzIHdpbGwgbm90IGJlIHBhc3NlZCB0byB0aGVcbiAqIHN1cHBsaWVkIGZ1bmN0aW9uLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAc2lnICgqIC0+IGIpIC0+IChhIC0+IGIpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBBIG5ldyBmdW5jdGlvbiB3cmFwcGluZyBgZm5gLiBUaGUgbmV3IGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gYmUgb2ZcbiAqICAgICAgICAgYXJpdHkgMS5cbiAqIEBzZWUgUi5iaW5hcnksIFIubkFyeVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IHRha2VzVHdvQXJncyA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAqICAgICAgICByZXR1cm4gW2EsIGJdO1xuICogICAgICB9O1xuICogICAgICB0YWtlc1R3b0FyZ3MubGVuZ3RoOyAvLz0+IDJcbiAqICAgICAgdGFrZXNUd29BcmdzKDEsIDIpOyAvLz0+IFsxLCAyXVxuICpcbiAqICAgICAgY29uc3QgdGFrZXNPbmVBcmcgPSBSLnVuYXJ5KHRha2VzVHdvQXJncyk7XG4gKiAgICAgIHRha2VzT25lQXJnLmxlbmd0aDsgLy89PiAxXG4gKiAgICAgIC8vIE9ubHkgMSBhcmd1bWVudCBpcyBwYXNzZWQgdG8gdGhlIHdyYXBwZWQgZnVuY3Rpb25cbiAqICAgICAgdGFrZXNPbmVBcmcoMSwgMik7IC8vPT4gWzEsIHVuZGVmaW5lZF1cbiAqIEBzeW1iIFIudW5hcnkoZikoYSwgYiwgYykgPSBmKGEpXG4gKi9cblxudmFyIHVuYXJ5ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoZnVuY3Rpb24gdW5hcnkoZm4pIHtcbiAgcmV0dXJuIG5BcnkoMSwgZm4pO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHVuYXJ5OyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbmltcG9ydCBjdXJyeU4gZnJvbSBcIi4vY3VycnlOLmpzXCI7XG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiBvZiBhcml0eSBgbmAgZnJvbSBhIChtYW51YWxseSkgY3VycmllZCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNC4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgTnVtYmVyIC0+IChhIC0+IGIpIC0+IChhIC0+IGMpXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBhcml0eSBmb3IgdGhlIHJldHVybmVkIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIHVuY3VycnkuXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24uXG4gKiBAc2VlIFIuY3VycnlcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBhZGRGb3VyID0gYSA9PiBiID0+IGMgPT4gZCA9PiBhICsgYiArIGMgKyBkO1xuICpcbiAqICAgICAgY29uc3QgdW5jdXJyaWVkQWRkRm91ciA9IFIudW5jdXJyeU4oNCwgYWRkRm91cik7XG4gKiAgICAgIHVuY3VycmllZEFkZEZvdXIoMSwgMiwgMywgNCk7IC8vPT4gMTBcbiAqL1xuXG52YXIgdW5jdXJyeU4gPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiB1bmN1cnJ5TihkZXB0aCwgZm4pIHtcbiAgcmV0dXJuIGN1cnJ5TihkZXB0aCwgZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdXJyZW50RGVwdGggPSAxO1xuICAgIHZhciB2YWx1ZSA9IGZuO1xuICAgIHZhciBpZHggPSAwO1xuICAgIHZhciBlbmRJZHg7XG5cbiAgICB3aGlsZSAoY3VycmVudERlcHRoIDw9IGRlcHRoICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZW5kSWR4ID0gY3VycmVudERlcHRoID09PSBkZXB0aCA/IGFyZ3VtZW50cy5sZW5ndGggOiBpZHggKyB2YWx1ZS5sZW5ndGg7XG4gICAgICB2YWx1ZSA9IHZhbHVlLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgaWR4LCBlbmRJZHgpKTtcbiAgICAgIGN1cnJlbnREZXB0aCArPSAxO1xuICAgICAgaWR4ID0gZW5kSWR4O1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdW5jdXJyeU47IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuLyoqXG4gKiBCdWlsZHMgYSBsaXN0IGZyb20gYSBzZWVkIHZhbHVlLiBBY2NlcHRzIGFuIGl0ZXJhdG9yIGZ1bmN0aW9uLCB3aGljaCByZXR1cm5zXG4gKiBlaXRoZXIgZmFsc2UgdG8gc3RvcCBpdGVyYXRpb24gb3IgYW4gYXJyYXkgb2YgbGVuZ3RoIDIgY29udGFpbmluZyB0aGUgdmFsdWVcbiAqIHRvIGFkZCB0byB0aGUgcmVzdWx0aW5nIGxpc3QgYW5kIHRoZSBzZWVkIHRvIGJlIHVzZWQgaW4gdGhlIG5leHQgY2FsbCB0byB0aGVcbiAqIGl0ZXJhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIFRoZSBpdGVyYXRvciBmdW5jdGlvbiByZWNlaXZlcyBvbmUgYXJndW1lbnQ6ICooc2VlZCkqLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEwLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIChhIC0+IFtiXSkgLT4gKiAtPiBbYl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvbi4gcmVjZWl2ZXMgb25lIGFyZ3VtZW50LCBgc2VlZGAsIGFuZCByZXR1cm5zXG4gKiAgICAgICAgZWl0aGVyIGZhbHNlIHRvIHF1aXQgaXRlcmF0aW9uIG9yIGFuIGFycmF5IG9mIGxlbmd0aCB0d28gdG8gcHJvY2VlZC4gVGhlIGVsZW1lbnRcbiAqICAgICAgICBhdCBpbmRleCAwIG9mIHRoaXMgYXJyYXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgcmVzdWx0aW5nIGFycmF5LCBhbmQgdGhlIGVsZW1lbnRcbiAqICAgICAgICBhdCBpbmRleCAxIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBuZXh0IGNhbGwgdG8gYGZuYC5cbiAqIEBwYXJhbSB7Kn0gc2VlZCBUaGUgc2VlZCB2YWx1ZS5cbiAqIEByZXR1cm4ge0FycmF5fSBUaGUgZmluYWwgbGlzdC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBmID0gbiA9PiBuID4gNTAgPyBmYWxzZSA6IFstbiwgbiArIDEwXTtcbiAqICAgICAgUi51bmZvbGQoZiwgMTApOyAvLz0+IFstMTAsIC0yMCwgLTMwLCAtNDAsIC01MF1cbiAqIEBzeW1iIFIudW5mb2xkKGYsIHgpID0gW2YoeClbMF0sIGYoZih4KVsxXSlbMF0sIGYoZihmKHgpWzFdKVsxXSlbMF0sIC4uLl1cbiAqL1xuXG52YXIgdW5mb2xkID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gdW5mb2xkKGZuLCBzZWVkKSB7XG4gIHZhciBwYWlyID0gZm4oc2VlZCk7XG4gIHZhciByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAocGFpciAmJiBwYWlyLmxlbmd0aCkge1xuICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHBhaXJbMF07XG4gICAgcGFpciA9IGZuKHBhaXJbMV0pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB1bmZvbGQ7IiwiaW1wb3J0IF9jb25jYXQgZnJvbSBcIi4vaW50ZXJuYWwvX2NvbmNhdC5qc1wiO1xuaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IGNvbXBvc2UgZnJvbSBcIi4vY29tcG9zZS5qc1wiO1xuaW1wb3J0IHVuaXEgZnJvbSBcIi4vdW5pcS5qc1wiO1xuLyoqXG4gKiBDb21iaW5lcyB0d28gbGlzdHMgaW50byBhIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBjb21wb3NlZCBvZiB0aGUgZWxlbWVudHNcbiAqIG9mIGVhY2ggbGlzdC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBSZWxhdGlvblxuICogQHNpZyBbKl0gLT4gWypdIC0+IFsqXVxuICogQHBhcmFtIHtBcnJheX0gYXMgVGhlIGZpcnN0IGxpc3QuXG4gKiBAcGFyYW0ge0FycmF5fSBicyBUaGUgc2Vjb25kIGxpc3QuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGZpcnN0IGFuZCBzZWNvbmQgbGlzdHMgY29uY2F0ZW5hdGVkLCB3aXRoXG4gKiAgICAgICAgIGR1cGxpY2F0ZXMgcmVtb3ZlZC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnVuaW9uKFsxLCAyLCAzXSwgWzIsIDMsIDRdKTsgLy89PiBbMSwgMiwgMywgNF1cbiAqL1xuXG52YXIgdW5pb24gPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5Mihcbi8qI19fUFVSRV9fKi9cbmNvbXBvc2UodW5pcSwgX2NvbmNhdCkpO1xuXG5leHBvcnQgZGVmYXVsdCB1bmlvbjsiLCJpbXBvcnQgX2luY2x1ZGVzV2l0aCBmcm9tIFwiLi9pbnRlcm5hbC9faW5jbHVkZXNXaXRoLmpzXCI7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG4vKipcbiAqIFJldHVybnMgYSBuZXcgbGlzdCBjb250YWluaW5nIG9ubHkgb25lIGNvcHkgb2YgZWFjaCBlbGVtZW50IGluIHRoZSBvcmlnaW5hbFxuICogbGlzdCwgYmFzZWQgdXBvbiB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgYXBwbHlpbmcgdGhlIHN1cHBsaWVkIHByZWRpY2F0ZSB0b1xuICogdHdvIGxpc3QgZWxlbWVudHMuIFByZWZlcnMgdGhlIGZpcnN0IGl0ZW0gaWYgdHdvIGl0ZW1zIGNvbXBhcmUgZXF1YWwgYmFzZWRcbiAqIG9uIHRoZSBwcmVkaWNhdGUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMi4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyAoKGEsIGEpIC0+IEJvb2xlYW4pIC0+IFthXSAtPiBbYV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdXNlZCB0byB0ZXN0IHdoZXRoZXIgdHdvIGl0ZW1zIGFyZSBlcXVhbC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgVGhlIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG9mIHVuaXF1ZSBpdGVtcy5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBzdHJFcSA9IFIuZXFCeShTdHJpbmcpO1xuICogICAgICBSLnVuaXFXaXRoKHN0ckVxKShbMSwgJzEnLCAyLCAxXSk7IC8vPT4gWzEsIDJdXG4gKiAgICAgIFIudW5pcVdpdGgoc3RyRXEpKFt7fSwge31dKTsgICAgICAgLy89PiBbe31dXG4gKiAgICAgIFIudW5pcVdpdGgoc3RyRXEpKFsxLCAnMScsIDFdKTsgICAgLy89PiBbMV1cbiAqICAgICAgUi51bmlxV2l0aChzdHJFcSkoWycxJywgMSwgMV0pOyAgICAvLz0+IFsnMSddXG4gKi9cblxudmFyIHVuaXFXaXRoID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gdW5pcVdpdGgocHJlZCwgbGlzdCkge1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpdGVtO1xuXG4gIHdoaWxlIChpZHggPCBsZW4pIHtcbiAgICBpdGVtID0gbGlzdFtpZHhdO1xuXG4gICAgaWYgKCFfaW5jbHVkZXNXaXRoKHByZWQsIGl0ZW0sIHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IGl0ZW07XG4gICAgfVxuXG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHVuaXFXaXRoOyIsImltcG9ydCBfY29uY2F0IGZyb20gXCIuL2ludGVybmFsL19jb25jYXQuanNcIjtcbmltcG9ydCBfY3VycnkzIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTMuanNcIjtcbmltcG9ydCB1bmlxV2l0aCBmcm9tIFwiLi91bmlxV2l0aC5qc1wiO1xuLyoqXG4gKiBDb21iaW5lcyB0d28gbGlzdHMgaW50byBhIHNldCAoaS5lLiBubyBkdXBsaWNhdGVzKSBjb21wb3NlZCBvZiB0aGUgZWxlbWVudHNcbiAqIG9mIGVhY2ggbGlzdC4gRHVwbGljYXRpb24gaXMgZGV0ZXJtaW5lZCBhY2NvcmRpbmcgdG8gdGhlIHZhbHVlIHJldHVybmVkIGJ5XG4gKiBhcHBseWluZyB0aGUgc3VwcGxpZWQgcHJlZGljYXRlIHRvIHR3byBsaXN0IGVsZW1lbnRzLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IFJlbGF0aW9uXG4gKiBAc2lnICgoYSwgYSkgLT4gQm9vbGVhbikgLT4gWypdIC0+IFsqXSAtPiBbKl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgdXNlZCB0byB0ZXN0IHdoZXRoZXIgdHdvIGl0ZW1zIGFyZSBlcXVhbC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gbGlzdDIgVGhlIHNlY29uZCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBmaXJzdCBhbmQgc2Vjb25kIGxpc3RzIGNvbmNhdGVuYXRlZCwgd2l0aFxuICogICAgICAgICBkdXBsaWNhdGVzIHJlbW92ZWQuXG4gKiBAc2VlIFIudW5pb25cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBsMSA9IFt7YTogMX0sIHthOiAyfV07XG4gKiAgICAgIGNvbnN0IGwyID0gW3thOiAxfSwge2E6IDR9XTtcbiAqICAgICAgUi51bmlvbldpdGgoUi5lcUJ5KFIucHJvcCgnYScpKSwgbDEsIGwyKTsgLy89PiBbe2E6IDF9LCB7YTogMn0sIHthOiA0fV1cbiAqL1xuXG52YXIgdW5pb25XaXRoID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTMoZnVuY3Rpb24gdW5pb25XaXRoKHByZWQsIGxpc3QxLCBsaXN0Mikge1xuICByZXR1cm4gdW5pcVdpdGgocHJlZCwgX2NvbmNhdChsaXN0MSwgbGlzdDIpKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB1bmlvbldpdGg7IiwiaW1wb3J0IF9jdXJyeTMgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5My5qc1wiO1xuLyoqXG4gKiBUZXN0cyB0aGUgZmluYWwgYXJndW1lbnQgYnkgcGFzc2luZyBpdCB0byB0aGUgZ2l2ZW4gcHJlZGljYXRlIGZ1bmN0aW9uLiBJZlxuICogdGhlIHByZWRpY2F0ZSBpcyBub3Qgc2F0aXNmaWVkLCB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHJlc3VsdCBvZlxuICogY2FsbGluZyB0aGUgYHdoZW5GYWxzZUZuYCBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50LiBJZiB0aGUgcHJlZGljYXRlXG4gKiBpcyBzYXRpc2ZpZWQsIHRoZSBhcmd1bWVudCBpcyByZXR1cm5lZCBhcyBpcy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOC4wXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgKGEgLT4gQm9vbGVhbikgLT4gKGEgLT4gYSkgLT4gYSAtPiBhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkICAgICAgICBBIHByZWRpY2F0ZSBmdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gd2hlbkZhbHNlRm4gQSBmdW5jdGlvbiB0byBpbnZva2Ugd2hlbiB0aGUgYHByZWRgIGV2YWx1YXRlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYSBmYWxzeSB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gICAgICAgIHggICAgICAgICAgIEFuIG9iamVjdCB0byB0ZXN0IHdpdGggdGhlIGBwcmVkYCBmdW5jdGlvbiBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MgdG8gYHdoZW5GYWxzZUZuYCBpZiBuZWNlc3NhcnkuXG4gKiBAcmV0dXJuIHsqfSBFaXRoZXIgYHhgIG9yIHRoZSByZXN1bHQgb2YgYXBwbHlpbmcgYHhgIHRvIGB3aGVuRmFsc2VGbmAuXG4gKiBAc2VlIFIuaWZFbHNlLCBSLndoZW4sIFIuY29uZFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGxldCBzYWZlSW5jID0gUi51bmxlc3MoUi5pc05pbCwgUi5pbmMpO1xuICogICAgICBzYWZlSW5jKG51bGwpOyAvLz0+IG51bGxcbiAqICAgICAgc2FmZUluYygxKTsgLy89PiAyXG4gKi9cblxudmFyIHVubGVzcyA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKGZ1bmN0aW9uIHVubGVzcyhwcmVkLCB3aGVuRmFsc2VGbiwgeCkge1xuICByZXR1cm4gcHJlZCh4KSA/IHggOiB3aGVuRmFsc2VGbih4KTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB1bmxlc3M7IiwiaW1wb3J0IF9pZGVudGl0eSBmcm9tIFwiLi9pbnRlcm5hbC9faWRlbnRpdHkuanNcIjtcbmltcG9ydCBjaGFpbiBmcm9tIFwiLi9jaGFpbi5qc1wiO1xuLyoqXG4gKiBTaG9ydGhhbmQgZm9yIGBSLmNoYWluKFIuaWRlbnRpdHkpYCwgd2hpY2ggcmVtb3ZlcyBvbmUgbGV2ZWwgb2YgbmVzdGluZyBmcm9tXG4gKiBhbnkgW0NoYWluXShodHRwczovL2dpdGh1Yi5jb20vZmFudGFzeWxhbmQvZmFudGFzeS1sYW5kI2NoYWluKS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4zLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIENoYWluIGMgPT4gYyAoYyBhKSAtPiBjIGFcbiAqIEBwYXJhbSB7Kn0gbGlzdFxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5mbGF0dGVuLCBSLmNoYWluXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi51bm5lc3QoWzEsIFsyXSwgW1szXV1dKTsgLy89PiBbMSwgMiwgWzNdXVxuICogICAgICBSLnVubmVzdChbWzEsIDJdLCBbMywgNF0sIFs1LCA2XV0pOyAvLz0+IFsxLCAyLCAzLCA0LCA1LCA2XVxuICovXG5cbnZhciB1bm5lc3QgPVxuLyojX19QVVJFX18qL1xuY2hhaW4oX2lkZW50aXR5KTtcbmV4cG9ydCBkZWZhdWx0IHVubmVzdDsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkzLmpzXCI7XG4vKipcbiAqIFRha2VzIGEgcHJlZGljYXRlLCBhIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uLCBhbmQgYW4gaW5pdGlhbCB2YWx1ZSxcbiAqIGFuZCByZXR1cm5zIGEgdmFsdWUgb2YgdGhlIHNhbWUgdHlwZSBhcyB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEl0IGRvZXMgc28gYnkgYXBwbHlpbmcgdGhlIHRyYW5zZm9ybWF0aW9uIHVudGlsIHRoZSBwcmVkaWNhdGUgaXMgc2F0aXNmaWVkLFxuICogYXQgd2hpY2ggcG9pbnQgaXQgcmV0dXJucyB0aGUgc2F0aXNmYWN0b3J5IHZhbHVlLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIwLjBcbiAqIEBjYXRlZ29yeSBMb2dpY1xuICogQHNpZyAoYSAtPiBCb29sZWFuKSAtPiAoYSAtPiBhKSAtPiBhIC0+IGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWQgQSBwcmVkaWNhdGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBpdGVyYXRvciBmdW5jdGlvblxuICogQHBhcmFtIHsqfSBpbml0IEluaXRpYWwgdmFsdWVcbiAqIEByZXR1cm4geyp9IEZpbmFsIHZhbHVlIHRoYXQgc2F0aXNmaWVzIHByZWRpY2F0ZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIudW50aWwoUi5ndChSLl9fLCAxMDApLCBSLm11bHRpcGx5KDIpKSgxKSAvLyA9PiAxMjhcbiAqL1xuXG52YXIgdW50aWwgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MyhmdW5jdGlvbiB1bnRpbChwcmVkLCBmbiwgaW5pdCkge1xuICB2YXIgdmFsID0gaW5pdDtcblxuICB3aGlsZSAoIXByZWQodmFsKSkge1xuICAgIHZhbCA9IGZuKHZhbCk7XG4gIH1cblxuICByZXR1cm4gdmFsO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHVudGlsOyIsImltcG9ydCBfY3VycnkxIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTEuanNcIjtcbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHRoZSBwcm9wZXJ0aWVzLCBpbmNsdWRpbmcgcHJvdG90eXBlIHByb3BlcnRpZXMsIG9mIHRoZVxuICogc3VwcGxpZWQgb2JqZWN0LlxuICogTm90ZSB0aGF0IHRoZSBvcmRlciBvZiB0aGUgb3V0cHV0IGFycmF5IGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGNvbnNpc3RlbnRcbiAqIGFjcm9zcyBkaWZmZXJlbnQgSlMgcGxhdGZvcm1zLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjIuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHNpZyB7azogdn0gLT4gW3ZdXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gZXh0cmFjdCB2YWx1ZXMgZnJvbVxuICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgb2YgdGhlIG9iamVjdCdzIG93biBhbmQgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKiBAc2VlIFIudmFsdWVzLCBSLmtleXNJblxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IEYgPSBmdW5jdGlvbigpIHsgdGhpcy54ID0gJ1gnOyB9O1xuICogICAgICBGLnByb3RvdHlwZS55ID0gJ1knO1xuICogICAgICBjb25zdCBmID0gbmV3IEYoKTtcbiAqICAgICAgUi52YWx1ZXNJbihmKTsgLy89PiBbJ1gnLCAnWSddXG4gKi9cblxudmFyIHZhbHVlc0luID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoZnVuY3Rpb24gdmFsdWVzSW4ob2JqKSB7XG4gIHZhciBwcm9wO1xuICB2YXIgdnMgPSBbXTtcblxuICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAgdnNbdnMubGVuZ3RoXSA9IG9ialtwcm9wXTtcbiAgfVxuXG4gIHJldHVybiB2cztcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB2YWx1ZXNJbjsiLCJpbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7IC8vIGBDb25zdGAgaXMgYSBmdW5jdG9yIHRoYXQgZWZmZWN0aXZlbHkgaWdub3JlcyB0aGUgZnVuY3Rpb24gZ2l2ZW4gdG8gYG1hcGAuXG5cbnZhciBDb25zdCA9IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiB7XG4gICAgdmFsdWU6IHgsXG4gICAgJ2ZhbnRhc3ktbGFuZC9tYXAnOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG59O1xuLyoqXG4gKiBSZXR1cm5zIGEgXCJ2aWV3XCIgb2YgdGhlIGdpdmVuIGRhdGEgc3RydWN0dXJlLCBkZXRlcm1pbmVkIGJ5IHRoZSBnaXZlbiBsZW5zLlxuICogVGhlIGxlbnMncyBmb2N1cyBkZXRlcm1pbmVzIHdoaWNoIHBvcnRpb24gb2YgdGhlIGRhdGEgc3RydWN0dXJlIGlzIHZpc2libGUuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTYuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHR5cGVkZWZuIExlbnMgcyBhID0gRnVuY3RvciBmID0+IChhIC0+IGYgYSkgLT4gcyAtPiBmIHNcbiAqIEBzaWcgTGVucyBzIGEgLT4gcyAtPiBhXG4gKiBAcGFyYW0ge0xlbnN9IGxlbnNcbiAqIEBwYXJhbSB7Kn0geFxuICogQHJldHVybiB7Kn1cbiAqIEBzZWUgUi5wcm9wLCBSLmxlbnNJbmRleCwgUi5sZW5zUHJvcFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIGNvbnN0IHhMZW5zID0gUi5sZW5zUHJvcCgneCcpO1xuICpcbiAqICAgICAgUi52aWV3KHhMZW5zLCB7eDogMSwgeTogMn0pOyAgLy89PiAxXG4gKiAgICAgIFIudmlldyh4TGVucywge3g6IDQsIHk6IDJ9KTsgIC8vPT4gNFxuICovXG5cblxudmFyIHZpZXcgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiB2aWV3KGxlbnMsIHgpIHtcbiAgLy8gVXNpbmcgYENvbnN0YCBlZmZlY3RpdmVseSBpZ25vcmVzIHRoZSBzZXR0ZXIgZnVuY3Rpb24gb2YgdGhlIGBsZW5zYCxcbiAgLy8gbGVhdmluZyB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgdGhlIGdldHRlciBmdW5jdGlvbiB1bm1vZGlmaWVkLlxuICByZXR1cm4gbGVucyhDb25zdCkoeCkudmFsdWU7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdmlldzsiLCJpbXBvcnQgX2N1cnJ5MyBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkzLmpzXCI7XG4vKipcbiAqIFRlc3RzIHRoZSBmaW5hbCBhcmd1bWVudCBieSBwYXNzaW5nIGl0IHRvIHRoZSBnaXZlbiBwcmVkaWNhdGUgZnVuY3Rpb24uIElmXG4gKiB0aGUgcHJlZGljYXRlIGlzIHNhdGlzZmllZCwgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZ1xuICogdGhlIGB3aGVuVHJ1ZUZuYCBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50LiBJZiB0aGUgcHJlZGljYXRlIGlzIG5vdFxuICogc2F0aXNmaWVkLCB0aGUgYXJndW1lbnQgaXMgcmV0dXJuZWQgYXMgaXMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMTguMFxuICogQGNhdGVnb3J5IExvZ2ljXG4gKiBAc2lnIChhIC0+IEJvb2xlYW4pIC0+IChhIC0+IGEpIC0+IGEgLT4gYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZCAgICAgICBBIHByZWRpY2F0ZSBmdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gd2hlblRydWVGbiBBIGZ1bmN0aW9uIHRvIGludm9rZSB3aGVuIHRoZSBgY29uZGl0aW9uYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmFsdWF0ZXMgdG8gYSB0cnV0aHkgdmFsdWUuXG4gKiBAcGFyYW0geyp9ICAgICAgICB4ICAgICAgICAgIEFuIG9iamVjdCB0byB0ZXN0IHdpdGggdGhlIGBwcmVkYCBmdW5jdGlvbiBhbmRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcyB0byBgd2hlblRydWVGbmAgaWYgbmVjZXNzYXJ5LlxuICogQHJldHVybiB7Kn0gRWl0aGVyIGB4YCBvciB0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIGB4YCB0byBgd2hlblRydWVGbmAuXG4gKiBAc2VlIFIuaWZFbHNlLCBSLnVubGVzcywgUi5jb25kXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgLy8gdHJ1bmNhdGUgOjogU3RyaW5nIC0+IFN0cmluZ1xuICogICAgICBjb25zdCB0cnVuY2F0ZSA9IFIud2hlbihcbiAqICAgICAgICBSLnByb3BTYXRpc2ZpZXMoUi5ndChSLl9fLCAxMCksICdsZW5ndGgnKSxcbiAqICAgICAgICBSLnBpcGUoUi50YWtlKDEwKSwgUi5hcHBlbmQoJ+KApicpLCBSLmpvaW4oJycpKVxuICogICAgICApO1xuICogICAgICB0cnVuY2F0ZSgnMTIzNDUnKTsgICAgICAgICAvLz0+ICcxMjM0NSdcbiAqICAgICAgdHJ1bmNhdGUoJzAxMjM0NTY3ODlBQkMnKTsgLy89PiAnMDEyMzQ1Njc4OeKApidcbiAqL1xuXG52YXIgd2hlbiA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkzKGZ1bmN0aW9uIHdoZW4ocHJlZCwgd2hlblRydWVGbiwgeCkge1xuICByZXR1cm4gcHJlZCh4KSA/IHdoZW5UcnVlRm4oeCkgOiB4O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHdoZW47IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IF9oYXMgZnJvbSBcIi4vaW50ZXJuYWwvX2hhcy5qc1wiO1xuLyoqXG4gKiBUYWtlcyBhIHNwZWMgb2JqZWN0IGFuZCBhIHRlc3Qgb2JqZWN0OyByZXR1cm5zIHRydWUgaWYgdGhlIHRlc3Qgc2F0aXNmaWVzXG4gKiB0aGUgc3BlYy4gRWFjaCBvZiB0aGUgc3BlYydzIG93biBwcm9wZXJ0aWVzIG11c3QgYmUgYSBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gKiBFYWNoIHByZWRpY2F0ZSBpcyBhcHBsaWVkIHRvIHRoZSB2YWx1ZSBvZiB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBvZiB0aGVcbiAqIHRlc3Qgb2JqZWN0LiBgd2hlcmVgIHJldHVybnMgdHJ1ZSBpZiBhbGwgdGhlIHByZWRpY2F0ZXMgcmV0dXJuIHRydWUsIGZhbHNlXG4gKiBvdGhlcndpc2UuXG4gKlxuICogYHdoZXJlYCBpcyB3ZWxsIHN1aXRlZCB0byBkZWNsYXJhdGl2ZWx5IGV4cHJlc3NpbmcgY29uc3RyYWludHMgZm9yIG90aGVyXG4gKiBmdW5jdGlvbnMgc3VjaCBhcyBbYGZpbHRlcmBdKCNmaWx0ZXIpIGFuZCBbYGZpbmRgXSgjZmluZCkuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4xXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtTdHJpbmc6ICgqIC0+IEJvb2xlYW4pfSAtPiB7U3RyaW5nOiAqfSAtPiBCb29sZWFuXG4gKiBAcGFyYW0ge09iamVjdH0gc3BlY1xuICogQHBhcmFtIHtPYmplY3R9IHRlc3RPYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAc2VlIFIucHJvcFNhdGlzZmllcywgUi53aGVyZUVxXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgLy8gcHJlZCA6OiBPYmplY3QgLT4gQm9vbGVhblxuICogICAgICBjb25zdCBwcmVkID0gUi53aGVyZSh7XG4gKiAgICAgICAgYTogUi5lcXVhbHMoJ2ZvbycpLFxuICogICAgICAgIGI6IFIuY29tcGxlbWVudChSLmVxdWFscygnYmFyJykpLFxuICogICAgICAgIHg6IFIuZ3QoUi5fXywgMTApLFxuICogICAgICAgIHk6IFIubHQoUi5fXywgMjApXG4gKiAgICAgIH0pO1xuICpcbiAqICAgICAgcHJlZCh7YTogJ2ZvbycsIGI6ICd4eHgnLCB4OiAxMSwgeTogMTl9KTsgLy89PiB0cnVlXG4gKiAgICAgIHByZWQoe2E6ICd4eHgnLCBiOiAneHh4JywgeDogMTEsIHk6IDE5fSk7IC8vPT4gZmFsc2VcbiAqICAgICAgcHJlZCh7YTogJ2ZvbycsIGI6ICdiYXInLCB4OiAxMSwgeTogMTl9KTsgLy89PiBmYWxzZVxuICogICAgICBwcmVkKHthOiAnZm9vJywgYjogJ3h4eCcsIHg6IDEwLCB5OiAxOX0pOyAvLz0+IGZhbHNlXG4gKiAgICAgIHByZWQoe2E6ICdmb28nLCBiOiAneHh4JywgeDogMTEsIHk6IDIwfSk7IC8vPT4gZmFsc2VcbiAqL1xuXG52YXIgd2hlcmUgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiB3aGVyZShzcGVjLCB0ZXN0T2JqKSB7XG4gIGZvciAodmFyIHByb3AgaW4gc3BlYykge1xuICAgIGlmIChfaGFzKHByb3AsIHNwZWMpICYmICFzcGVjW3Byb3BdKHRlc3RPYmpbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgd2hlcmU7IiwiaW1wb3J0IF9jdXJyeTIgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5Mi5qc1wiO1xuaW1wb3J0IGVxdWFscyBmcm9tIFwiLi9lcXVhbHMuanNcIjtcbmltcG9ydCBtYXAgZnJvbSBcIi4vbWFwLmpzXCI7XG5pbXBvcnQgd2hlcmUgZnJvbSBcIi4vd2hlcmUuanNcIjtcbi8qKlxuICogVGFrZXMgYSBzcGVjIG9iamVjdCBhbmQgYSB0ZXN0IG9iamVjdDsgcmV0dXJucyB0cnVlIGlmIHRoZSB0ZXN0IHNhdGlzZmllc1xuICogdGhlIHNwZWMsIGZhbHNlIG90aGVyd2lzZS4gQW4gb2JqZWN0IHNhdGlzZmllcyB0aGUgc3BlYyBpZiwgZm9yIGVhY2ggb2YgdGhlXG4gKiBzcGVjJ3Mgb3duIHByb3BlcnRpZXMsIGFjY2Vzc2luZyB0aGF0IHByb3BlcnR5IG9mIHRoZSBvYmplY3QgZ2l2ZXMgdGhlIHNhbWVcbiAqIHZhbHVlIChpbiBbYFIuZXF1YWxzYF0oI2VxdWFscykgdGVybXMpIGFzIGFjY2Vzc2luZyB0aGF0IHByb3BlcnR5IG9mIHRoZVxuICogc3BlYy5cbiAqXG4gKiBgd2hlcmVFcWAgaXMgYSBzcGVjaWFsaXphdGlvbiBvZiBbYHdoZXJlYF0oI3doZXJlKS5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xNC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAc2lnIHtTdHJpbmc6ICp9IC0+IHtTdHJpbmc6ICp9IC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzcGVjXG4gKiBAcGFyYW0ge09iamVjdH0gdGVzdE9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBzZWUgUi5wcm9wRXEsIFIud2hlcmVcbiAqIEBleGFtcGxlXG4gKlxuICogICAgICAvLyBwcmVkIDo6IE9iamVjdCAtPiBCb29sZWFuXG4gKiAgICAgIGNvbnN0IHByZWQgPSBSLndoZXJlRXEoe2E6IDEsIGI6IDJ9KTtcbiAqXG4gKiAgICAgIHByZWQoe2E6IDF9KTsgICAgICAgICAgICAgIC8vPT4gZmFsc2VcbiAqICAgICAgcHJlZCh7YTogMSwgYjogMn0pOyAgICAgICAgLy89PiB0cnVlXG4gKiAgICAgIHByZWQoe2E6IDEsIGI6IDIsIGM6IDN9KTsgIC8vPT4gdHJ1ZVxuICogICAgICBwcmVkKHthOiAxLCBiOiAxfSk7ICAgICAgICAvLz0+IGZhbHNlXG4gKi9cblxudmFyIHdoZXJlRXEgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiB3aGVyZUVxKHNwZWMsIHRlc3RPYmopIHtcbiAgcmV0dXJuIHdoZXJlKG1hcChlcXVhbHMsIHNwZWMpLCB0ZXN0T2JqKTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB3aGVyZUVxOyIsImltcG9ydCBfaW5jbHVkZXMgZnJvbSBcIi4vaW50ZXJuYWwvX2luY2x1ZGVzLmpzXCI7XG5pbXBvcnQgX2N1cnJ5MiBmcm9tIFwiLi9pbnRlcm5hbC9fY3VycnkyLmpzXCI7XG5pbXBvcnQgZmxpcCBmcm9tIFwiLi9mbGlwLmpzXCI7XG5pbXBvcnQgcmVqZWN0IGZyb20gXCIuL3JlamVjdC5qc1wiO1xuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGxpc3Qgd2l0aG91dCB2YWx1ZXMgaW4gdGhlIGZpcnN0IGFyZ3VtZW50LlxuICogW2BSLmVxdWFsc2BdKCNlcXVhbHMpIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGVxdWFsaXR5LlxuICpcbiAqIEFjdHMgYXMgYSB0cmFuc2R1Y2VyIGlmIGEgdHJhbnNmb3JtZXIgaXMgZ2l2ZW4gaW4gbGlzdCBwb3NpdGlvbi5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xOS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2FdIC0+IFthXVxuICogQHBhcmFtIHtBcnJheX0gbGlzdDEgVGhlIHZhbHVlcyB0byBiZSByZW1vdmVkIGZyb20gYGxpc3QyYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBhcnJheSB0byByZW1vdmUgdmFsdWVzIGZyb20uXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIG5ldyBhcnJheSB3aXRob3V0IHZhbHVlcyBpbiBgbGlzdDFgLlxuICogQHNlZSBSLnRyYW5zZHVjZSwgUi5kaWZmZXJlbmNlLCBSLnJlbW92ZVxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIud2l0aG91dChbMSwgMl0sIFsxLCAyLCAxLCAzLCA0XSk7IC8vPT4gWzMsIDRdXG4gKi9cblxudmFyIHdpdGhvdXQgPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MihmdW5jdGlvbiAoeHMsIGxpc3QpIHtcbiAgcmV0dXJuIHJlamVjdChmbGlwKF9pbmNsdWRlcykoeHMpLCBsaXN0KTtcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB3aXRob3V0OyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogRXhjbHVzaXZlIGRpc2p1bmN0aW9uIGxvZ2ljYWwgb3BlcmF0aW9uLlxuICogUmV0dXJucyBgdHJ1ZWAgaWYgb25lIG9mIHRoZSBhcmd1bWVudHMgaXMgdHJ1dGh5IGFuZCB0aGUgb3RoZXIgaXMgZmFsc3kuXG4gKiBPdGhlcndpc2UsIGl0IHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yNy4xXG4gKiBAY2F0ZWdvcnkgTG9naWNcbiAqIEBzaWcgYSAtPiBiIC0+IEJvb2xlYW5cbiAqIEBwYXJhbSB7QW55fSBhXG4gKiBAcGFyYW0ge0FueX0gYlxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBvbmUgb2YgdGhlIGFyZ3VtZW50cyBpcyB0cnV0aHkgYW5kIHRoZSBvdGhlciBpcyBmYWxzeVxuICogQHNlZSBSLm9yLCBSLmFuZFxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIueG9yKHRydWUsIHRydWUpOyAvLz0+IGZhbHNlXG4gKiAgICAgIFIueG9yKHRydWUsIGZhbHNlKTsgLy89PiB0cnVlXG4gKiAgICAgIFIueG9yKGZhbHNlLCB0cnVlKTsgLy89PiB0cnVlXG4gKiAgICAgIFIueG9yKGZhbHNlLCBmYWxzZSk7IC8vPT4gZmFsc2VcbiAqL1xuXG52YXIgeG9yID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24geG9yKGEsIGIpIHtcbiAgcmV0dXJuIEJvb2xlYW4oIWEgXiAhYik7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgeG9yOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBsaXN0IG91dCBvZiB0aGUgdHdvIHN1cHBsaWVkIGJ5IGNyZWF0aW5nIGVhY2ggcG9zc2libGUgcGFpclxuICogZnJvbSB0aGUgbGlzdHMuXG4gKlxuICogQGZ1bmNcbiAqIEBtZW1iZXJPZiBSXG4gKiBAc2luY2UgdjAuMS4wXG4gKiBAY2F0ZWdvcnkgTGlzdFxuICogQHNpZyBbYV0gLT4gW2JdIC0+IFtbYSxiXV1cbiAqIEBwYXJhbSB7QXJyYXl9IGFzIFRoZSBmaXJzdCBsaXN0LlxuICogQHBhcmFtIHtBcnJheX0gYnMgVGhlIHNlY29uZCBsaXN0LlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG1hZGUgYnkgY29tYmluaW5nIGVhY2ggcG9zc2libGUgcGFpciBmcm9tXG4gKiAgICAgICAgIGBhc2AgYW5kIGBic2AgaW50byBwYWlycyAoYFthLCBiXWApLlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgIFIueHByb2QoWzEsIDJdLCBbJ2EnLCAnYiddKTsgLy89PiBbWzEsICdhJ10sIFsxLCAnYiddLCBbMiwgJ2EnXSwgWzIsICdiJ11dXG4gKiBAc3ltYiBSLnhwcm9kKFthLCBiXSwgW2MsIGRdKSA9IFtbYSwgY10sIFthLCBkXSwgW2IsIGNdLCBbYiwgZF1dXG4gKi9cblxudmFyIHhwcm9kID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24geHByb2QoYSwgYikge1xuICAvLyA9IHhwcm9kV2l0aChwcmVwZW5kKTsgKHRha2VzIGFib3V0IDMgdGltZXMgYXMgbG9uZy4uLilcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBpbGVuID0gYS5sZW5ndGg7XG4gIHZhciBqO1xuICB2YXIgamxlbiA9IGIubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKGlkeCA8IGlsZW4pIHtcbiAgICBqID0gMDtcblxuICAgIHdoaWxlIChqIDwgamxlbikge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gW2FbaWR4XSwgYltqXV07XG4gICAgICBqICs9IDE7XG4gICAgfVxuXG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IHhwcm9kOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBsaXN0IG91dCBvZiB0aGUgdHdvIHN1cHBsaWVkIGJ5IHBhaXJpbmcgdXAgZXF1YWxseS1wb3NpdGlvbmVkXG4gKiBpdGVtcyBmcm9tIGJvdGggbGlzdHMuIFRoZSByZXR1cm5lZCBsaXN0IGlzIHRydW5jYXRlZCB0byB0aGUgbGVuZ3RoIG9mIHRoZVxuICogc2hvcnRlciBvZiB0aGUgdHdvIGlucHV0IGxpc3RzLlxuICogTm90ZTogYHppcGAgaXMgZXF1aXZhbGVudCB0byBgemlwV2l0aChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBbYSwgYl0gfSlgLlxuICpcbiAqIEBmdW5jXG4gKiBAbWVtYmVyT2YgUlxuICogQHNpbmNlIHYwLjEuMFxuICogQGNhdGVnb3J5IExpc3RcbiAqIEBzaWcgW2FdIC0+IFtiXSAtPiBbW2EsYl1dXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MSBUaGUgZmlyc3QgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0MiBUaGUgc2Vjb25kIGFycmF5IHRvIGNvbnNpZGVyLlxuICogQHJldHVybiB7QXJyYXl9IFRoZSBsaXN0IG1hZGUgYnkgcGFpcmluZyB1cCBzYW1lLWluZGV4ZWQgZWxlbWVudHMgb2YgYGxpc3QxYCBhbmQgYGxpc3QyYC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnppcChbMSwgMiwgM10sIFsnYScsICdiJywgJ2MnXSk7IC8vPT4gW1sxLCAnYSddLCBbMiwgJ2InXSwgWzMsICdjJ11dXG4gKiBAc3ltYiBSLnppcChbYSwgYiwgY10sIFtkLCBlLCBmXSkgPSBbW2EsIGRdLCBbYiwgZV0sIFtjLCBmXV1cbiAqL1xuXG52YXIgemlwID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTIoZnVuY3Rpb24gemlwKGEsIGIpIHtcbiAgdmFyIHJ2ID0gW107XG4gIHZhciBpZHggPSAwO1xuICB2YXIgbGVuID0gTWF0aC5taW4oYS5sZW5ndGgsIGIubGVuZ3RoKTtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgcnZbaWR4XSA9IFthW2lkeF0sIGJbaWR4XV07XG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gcnY7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgemlwOyIsImltcG9ydCBfY3VycnkyIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTIuanNcIjtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBvYmplY3Qgb3V0IG9mIGEgbGlzdCBvZiBrZXlzIGFuZCBhIGxpc3Qgb2YgdmFsdWVzLlxuICogS2V5L3ZhbHVlIHBhaXJpbmcgaXMgdHJ1bmNhdGVkIHRvIHRoZSBsZW5ndGggb2YgdGhlIHNob3J0ZXIgb2YgdGhlIHR3byBsaXN0cy5cbiAqIE5vdGU6IGB6aXBPYmpgIGlzIGVxdWl2YWxlbnQgdG8gYHBpcGUoemlwLCBmcm9tUGFpcnMpYC5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4zLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnIFtTdHJpbmddIC0+IFsqXSAtPiB7U3RyaW5nOiAqfVxuICogQHBhcmFtIHtBcnJheX0ga2V5cyBUaGUgYXJyYXkgdGhhdCB3aWxsIGJlIHByb3BlcnRpZXMgb24gdGhlIG91dHB1dCBvYmplY3QuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIGxpc3Qgb2YgdmFsdWVzIG9uIHRoZSBvdXRwdXQgb2JqZWN0LlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgb2JqZWN0IG1hZGUgYnkgcGFpcmluZyB1cCBzYW1lLWluZGV4ZWQgZWxlbWVudHMgb2YgYGtleXNgIGFuZCBgdmFsdWVzYC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBSLnppcE9iaihbJ2EnLCAnYicsICdjJ10sIFsxLCAyLCAzXSk7IC8vPT4ge2E6IDEsIGI6IDIsIGM6IDN9XG4gKi9cblxudmFyIHppcE9iaiA9XG4vKiNfX1BVUkVfXyovXG5fY3VycnkyKGZ1bmN0aW9uIHppcE9iaihrZXlzLCB2YWx1ZXMpIHtcbiAgdmFyIGlkeCA9IDA7XG4gIHZhciBsZW4gPSBNYXRoLm1pbihrZXlzLmxlbmd0aCwgdmFsdWVzLmxlbmd0aCk7XG4gIHZhciBvdXQgPSB7fTtcblxuICB3aGlsZSAoaWR4IDwgbGVuKSB7XG4gICAgb3V0W2tleXNbaWR4XV0gPSB2YWx1ZXNbaWR4XTtcbiAgICBpZHggKz0gMTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgemlwT2JqOyIsImltcG9ydCBfY3VycnkzIGZyb20gXCIuL2ludGVybmFsL19jdXJyeTMuanNcIjtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBsaXN0IG91dCBvZiB0aGUgdHdvIHN1cHBsaWVkIGJ5IGFwcGx5aW5nIHRoZSBmdW5jdGlvbiB0byBlYWNoXG4gKiBlcXVhbGx5LXBvc2l0aW9uZWQgcGFpciBpbiB0aGUgbGlzdHMuIFRoZSByZXR1cm5lZCBsaXN0IGlzIHRydW5jYXRlZCB0byB0aGVcbiAqIGxlbmd0aCBvZiB0aGUgc2hvcnRlciBvZiB0aGUgdHdvIGlucHV0IGxpc3RzLlxuICpcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4xLjBcbiAqIEBjYXRlZ29yeSBMaXN0XG4gKiBAc2lnICgoYSwgYikgLT4gYykgLT4gW2FdIC0+IFtiXSAtPiBbY11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGNvbWJpbmUgdGhlIHR3byBlbGVtZW50cyBpbnRvIG9uZSB2YWx1ZS5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QxIFRoZSBmaXJzdCBhcnJheSB0byBjb25zaWRlci5cbiAqIEBwYXJhbSB7QXJyYXl9IGxpc3QyIFRoZSBzZWNvbmQgYXJyYXkgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3QgbWFkZSBieSBjb21iaW5pbmcgc2FtZS1pbmRleGVkIGVsZW1lbnRzIG9mIGBsaXN0MWAgYW5kIGBsaXN0MmBcbiAqICAgICAgICAgdXNpbmcgYGZuYC5cbiAqIEBleGFtcGxlXG4gKlxuICogICAgICBjb25zdCBmID0gKHgsIHkpID0+IHtcbiAqICAgICAgICAvLyAuLi5cbiAqICAgICAgfTtcbiAqICAgICAgUi56aXBXaXRoKGYsIFsxLCAyLCAzXSwgWydhJywgJ2InLCAnYyddKTtcbiAqICAgICAgLy89PiBbZigxLCAnYScpLCBmKDIsICdiJyksIGYoMywgJ2MnKV1cbiAqIEBzeW1iIFIuemlwV2l0aChmbiwgW2EsIGIsIGNdLCBbZCwgZSwgZl0pID0gW2ZuKGEsIGQpLCBmbihiLCBlKSwgZm4oYywgZildXG4gKi9cblxudmFyIHppcFdpdGggPVxuLyojX19QVVJFX18qL1xuX2N1cnJ5MyhmdW5jdGlvbiB6aXBXaXRoKGZuLCBhLCBiKSB7XG4gIHZhciBydiA9IFtdO1xuICB2YXIgaWR4ID0gMDtcbiAgdmFyIGxlbiA9IE1hdGgubWluKGEubGVuZ3RoLCBiLmxlbmd0aCk7XG5cbiAgd2hpbGUgKGlkeCA8IGxlbikge1xuICAgIHJ2W2lkeF0gPSBmbihhW2lkeF0sIGJbaWR4XSk7XG4gICAgaWR4ICs9IDE7XG4gIH1cblxuICByZXR1cm4gcnY7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgemlwV2l0aDsiLCJpbXBvcnQgY3VycnlOIGZyb20gXCIuL2N1cnJ5Ti5qc1wiO1xuaW1wb3J0IF9jdXJyeTEgZnJvbSBcIi4vaW50ZXJuYWwvX2N1cnJ5MS5qc1wiO1xuLyoqXG4gKiBDcmVhdGVzIGEgdGh1bmsgb3V0IG9mIGEgZnVuY3Rpb24uIEEgdGh1bmsgZGVsYXlzIGEgY2FsY3VsYXRpb24gdW50aWxcbiAqIGl0cyByZXN1bHQgaXMgbmVlZGVkLCBwcm92aWRpbmcgbGF6eSBldmFsdWF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqXG4gKiBAZnVuY1xuICogQG1lbWJlck9mIFJcbiAqIEBzaW5jZSB2MC4yNi4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBzaWcgKChhLCBiLCAuLi4sIGopIC0+IGspIC0+IChhLCBiLCAuLi4sIGopIC0+ICgoKSAtPiBrKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQSBmdW5jdGlvbiB0byB3cmFwIGluIGEgdGh1bmtcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBFeHBlY3RzIGFyZ3VtZW50cyBmb3IgYGZuYCBhbmQgcmV0dXJucyBhIG5ldyBmdW5jdGlvblxuICogIHRoYXQsIHdoZW4gY2FsbGVkLCBhcHBsaWVzIHRob3NlIGFyZ3VtZW50cyB0byBgZm5gLlxuICogQHNlZSBSLnBhcnRpYWwsIFIucGFydGlhbFJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICAgUi50aHVua2lmeShSLmlkZW50aXR5KSg0MikoKTsgLy89PiA0MlxuICogICAgICBSLnRodW5raWZ5KChhLCBiKSA9PiBhICsgYikoMjUsIDE3KSgpOyAvLz0+IDQyXG4gKi9cblxudmFyIHRodW5raWZ5ID1cbi8qI19fUFVSRV9fKi9cbl9jdXJyeTEoZnVuY3Rpb24gdGh1bmtpZnkoZm4pIHtcbiAgcmV0dXJuIGN1cnJ5Tihmbi5sZW5ndGgsIGZ1bmN0aW9uIGNyZWF0ZVRodW5rKCkge1xuICAgIHZhciBmbkFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZVRodW5rKCkge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGZuQXJncyk7XG4gICAgfTtcbiAgfSk7XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgdGh1bmtpZnk7Il0sIm5hbWVzIjpbImN1cnJ5TiIsIl94YWxsIiwiYmluZCIsIl9pc0FycmF5TGlrZSIsInRvU3RyaW5nIiwiY29udGFpbnMiLCJfaXNBcmd1bWVudHMiLCJfeG1hcCIsImtleXMiLCJudGgiLCJwYXRocyIsInBhdGgiLCJtYXAiLCJwcm9wIiwicmVkdWNlIiwibWF4IiwicGx1Y2siLCJfeGFueSIsIl94YXBlcnR1cmUiLCJ2YWx1ZXMiLCJhcHBseSIsImlzTmlsIiwiYXNzb2MiLCJuQXJ5IiwiYXAiLCJsaWZ0TiIsImxpZnQiLCJhbmQiLCJjdXJyeSIsIl9mbGF0Q2F0IiwiX3hjaGFpbiIsInR5cGUiLCJub3QiLCJzbGljZSIsInRhaWwiLCJyZXZlcnNlIiwiY2hhaW4iLCJpZGVudGl0eSIsImhlYWQiLCJwaXBlV2l0aCIsIl9vYmplY3RJcyIsImVxdWFscyIsIl94ZmlsdGVyIiwiZmlsdGVyIiwicmVqZWN0IiwiX3RvSVNPU3RyaW5nIiwiY29uc3RydWN0TiIsIl94cmVkdWNlQnkiLCJyZWR1Y2VCeSIsImFkZCIsIl9TZXQiLCJhZGp1c3QiLCJhbHdheXMiLCJyZW1vdmUiLCJkaXNzb2MiLCJ1cGRhdGUiLCJfeGRyb3AiLCJfeHRha2UiLCJkcm9wTGFzdCIsInRha2UiLCJfeGRyb3BMYXN0IiwiX2Ryb3BMYXN0IiwiZHJvcExhc3RXaGlsZSIsIl94ZHJvcExhc3RXaGlsZSIsIl9kcm9wTGFzdFdoaWxlIiwiX3hkcm9wUmVwZWF0c1dpdGgiLCJsYXN0IiwiZHJvcFJlcGVhdHNXaXRoIiwiX3hkcm9wV2hpbGUiLCJvciIsImRyb3AiLCJ0YWtlTGFzdCIsIl94ZmluZCIsIl94ZmluZEluZGV4IiwiX3hmaW5kTGFzdCIsIl94ZmluZExhc3RJbmRleCIsImhhc1BhdGgiLCJ1bmlxQnkiLCJ1bmlxIiwiZmxpcCIsIl9vYmplY3RBc3NpZ24iLCJvYmpPZiIsImVtcHR5IiwiaW52b2tlciIsImNvbnZlcmdlIiwibGVucyIsImFzc29jUGF0aCIsInN1bSIsIm1lYW4iLCJtZXJnZVdpdGhLZXkiLCJtZXJnZURlZXBXaXRoS2V5IiwiYWxsIiwianV4dCIsImRlZmF1bHRUbyIsIm11bHRpcGx5IiwidXNlV2l0aCIsInBpY2tBbGwiLCJpcyIsInBhdGhPciIsInRpbWVzIiwicmVkdWNlUmlnaHQiLCJwcmVwZW5kIiwib3ZlciIsImxlbmd0aCIsImNvbmNhdCIsImRpZmZlcmVuY2UiLCJkaWZmZXJlbmNlV2l0aCIsIl94dGFrZVdoaWxlIiwiX3h0YXAiLCJzZXF1ZW5jZSIsInVuaXFXaXRoIiwid2hlcmUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O01BQUE7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0EsSUFBSSxDQUFDLEdBQUcsWUFBWTtNQUNwQixFQUFFLE9BQU8sS0FBSyxDQUFDO01BQ2YsQ0FBQyxDQUFDO0FBQ0Y7QUFDQSw2QkFBZSxFQUFDOztNQ25CaEI7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0EsSUFBSSxDQUFDLEdBQUcsWUFBWTtNQUNwQixFQUFFLE9BQU8sSUFBSSxDQUFDO01BQ2QsQ0FBQyxDQUFDO0FBQ0Y7QUFDQSw2QkFBZSxFQUFDOztNQ25CaEI7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO0FBQ0EsNkJBQWU7TUFDZixFQUFFLDBCQUEwQixFQUFFLElBQUk7TUFDbEMsRUFBQzs7TUM3QmMsU0FBUyxjQUFjLENBQUMsQ0FBQyxFQUFFO01BQzFDLEVBQUUsT0FBTyxDQUFDLElBQUks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RUFBRSxFQUFFLEVBQUUsRUFBRTtNQUNuQyxRQUFRLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7TUFDekMsT0FBTyxDQUFDO0FBQ1I7TUFDQSxJQUFJLEtBQUssQ0FBQztNQUNWLE1BQU0sT0FBTyxVQUFVLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtNQUN2QyxRQUFRLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7TUFDekMsT0FBTyxDQUFDO0FBQ1I7TUFDQSxJQUFJLEtBQUssQ0FBQztNQUNWLE1BQU0sT0FBTyxVQUFVLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7TUFDM0MsUUFBUSxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBQyxDQUFDO01BQ3pDLE9BQU8sQ0FBQztBQUNSO01BQ0EsSUFBSSxLQUFLLENBQUM7TUFDVixNQUFNLE9BQU8sVUFBVSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtNQUMvQyxRQUFRLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7TUFDekMsT0FBTyxDQUFDO0FBQ1I7TUFDQSxJQUFJLEtBQUssQ0FBQztNQUNWLE1BQU0sT0FBTyxVQUFVLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtNQUNuRCxRQUFRLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7TUFDekMsT0FBTyxDQUFDO0FBQ1I7TUFDQSxJQUFJLEtBQUssQ0FBQztNQUNWLE1BQU0sT0FBTyxVQUFVLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUs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QUksRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO01BQ3pDLE9BQU8sQ0FBQztBQUNSO01BQ0EsSUFBSSxLQUFLLENBQUM7TUFDVixNQUFNLE9BQU8sVUFBVSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7TUFDdkMsUUFBUSxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO01BQzdDLE9BQU8sQ0FBQztBQUNSO01BQ0EsSUFBSSxLQUFLLENBQUM7TUFDVixNQUFNLE9BQU8sVUFBVSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO01BQzNDLFFBQVEsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7TUFDakQsT0FBTyxDQUFDO0FBQ1I7TUFDQSxJQUFJLEtBQUssQ0FBQztNQUNWLE1BQU0sT0FBTyxVQUFVLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO01BQy9DLFFBQVEsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO01BQ3JELE9BQU8sQ0FBQztBQUNSO01BQ0EsSUFBSSxLQUFLLENBQUM7TUFDVixNQUFNLE9BQU8sVUFBVSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7TUFDbkQsUUFBUSxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO01BQ3pELE9BQU8sQ0FBQztBQUNSO01BQ0EsSUFBSSxLQUFLLENBQUM7TUFDVixNQUFNLE9BQU8sVUFBVSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO01BQ3ZELFFBQVEsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7TUFDN0QsT0FBTyxDQUFDO0FBQ1I7TUFDQSxJQUFJLEtBQUssQ0FBQztNQUNWLE1BQU0sT0FBTyxVQUFVLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO01BQzNELFFBQVEsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO01BQ2pFLE9BQU8sQ0FBQztBQUNSO01BQ0EsSUFBSSxLQUFLLEVBQUU7TUFDWCxNQUFNLE9BQU8sVUFBVSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7TUFDL0QsUUFBUSxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FB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QUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUN0QztNQUNBLE1BQU0sS0FBSyxDQUFDO01BQ1osUUFBUSxPQUFPLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUMxQztNQUNBLE1BQU0sS0FBSyxDQUFDO01BQ1osUUFBUSxPQUFPLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDOUM7TUFDQSxNQUFNLEtBQUssQ0FBQztNQUNaLFFBQVEsT0FBTyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNsRDtNQUNBLE1BQU0sS0FBSyxDQUFDO01BQ1osUUFBUSxPQUFPLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUN0RDtNQUNBLE1BQU0sS0FBSyxDQUFDO01BQ1osUUFBUSxPQUFPLElBQUksRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDMUQ7TUFDQSxNQUFNLEtBQUssRUFBRTtNQUNiLFFBQVEsT0FBTyxJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztNQUM5RCxLQUFLO01BQ0wsR0FBRyxDQUFDLENBQUMsQ0FBQztNQUNOLENBQUMs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
