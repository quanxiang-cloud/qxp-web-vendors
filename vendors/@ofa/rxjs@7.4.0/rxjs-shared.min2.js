/* rxjs@7.4.0 */
System.register(["./rxjs-shared.min.js"],(function(e){"use strict";var s,t,r,i,a,n,o,c,h,u,l,d,b,m,f,p;return{setters:[function(e){s=e.O,t=e.S,r=e.o,i=e.a,a=e.b,n=e.V,o=e.c,c=e.n,h=e.e,u=e.C,l=e.d,d=e.f,b=e.i,m=e.g,f=e.t,p=e.p}],execute:function(){class w{constructor(e,s=1/0){this.subscribedFrame=e,this.unsubscribedFrame=s}}class g{constructor(){this.subscriptions=[]}logSubscribedFrame(){return this.subscriptions.push(new w(this.scheduler.now())),this.subscriptions.length-1}logUnsubscribedFrame(e){const s=this.subscriptions,t=s[e];s[e]=new w(t.subscribedFrame,this.scheduler.now())}}class v extends s{constructor(e,s){super((function(e){const s=this,r=s.logSubscribedFrame(),i=new t;return i.add(new t((()=>{s.logUnsubscribedFrame(r)}))),s.scheduleMessages(e),i})),this.messages=e,this.subscriptions=[],this.scheduler=s}scheduleMessages(e){const s=this.messages.length;for(let t=0;t<s;t++){const s=this.messages[t];e.add(this.scheduler.schedule((e=>{const{message:{notification:s},subscriber:t}=e;r(s,t)}),s.frame,{message:s,subscriber:e}))}}}i(v,[g]);class F extends a{constructor(e,s){super(),this.messages=e,this.subscriptions=[],this.scheduler=s}_subscribe(e){const s=this,r=s.logSubscribedFrame(),i=new t;return i.add(new t((()=>{s.logUnsubscribedFrame(r)}))),i.add(super._subscribe(e)),i}setup(){const e=this,s=e.messages.length;for(let t=0;t<s;t++)(()=>{const{notification:s,frame:i}=e.messages[t];e.scheduler.schedule((()=>{r(s,e)}),i)})()}}i(F,[g]);class x extends n{constructor(e){super(o,750),this.assertDeepEqual=e,this.hotObservables=[],this.coldObservables=[],this.flushTests=[],this.runMode=!1}createTime(e){const s=this.runMode?e.trim().indexOf("|"):e.indexOf("|");if(-1===s)throw new Error('marble diagram for time should have a completion marker "|"');return s*x.frameTimeFactor}createColdObservable(e,s,t){if(-1!==e.indexOf("^"))throw new Error('cold observable cannot have subscription offset "^"');if(-1!==e.indexOf("!"))throw new Error('cold observable cannot have unsubscription marker "!"');const r=x.parseMarbles(e,s,t,void 0,this.runMode),i=new v(r,this);return this.coldObservables.push(i),i}createHotObservable(e,s,t){if(-1!==e.indexOf("!"))throw new Error('hot observable cannot have unsubscription marker "!"');const r=x.parseMarbles(e,s,t,void 0,this.runMode),i=new F(r,this);return this.hotObservables.push(i),i}materializeInnerObservable(e,s){const t=[];return e.subscribe((e=>{t.push({frame:this.frame-s,notification:c(e)})}),(e=>{t.push({frame:this.frame-s,notification:h(e)})}),(()=>{t.push({frame:this.frame-s,notification:u})})),t}expectObservable(e,t=null){const r=[],i={actual:r,ready:!1},a=x.parseMarblesAsSubscriptions(t,this.runMode),n=a.subscribedFrame===1/0?0:a.subscribedFrame,o=a.unsubscribedFrame;let l;this.schedule((()=>{l=e.subscribe((e=>{const t=e instanceof s?this.materializeInnerObservable(e,this.frame):e;r.push({frame:this.frame,notification:c(t)})}),(e=>{r.push({frame:this.frame,notification:h(e)})}),(()=>{r.push({frame:this.frame,notification:u})}))}),n),o!==1/0&&this.schedule((()=>l.unsubscribe()),o),this.flushTests.push(i);const{runMode:d}=this;return{toBe(e,s,t){i.ready=!0,i.expected=x.parseMarbles(e,s,t,!0,d)},toEqual:e=>{i.ready=!0,i.expected=[],this.schedule((()=>{l=e.subscribe((e=>{const t=e instanceof s?this.materializeInnerObservable(e,this.frame):e;i.expected.push({frame:this.frame,notification:c(t)})}),(e=>{i.expected.push({frame:this.frame,notification:h(e)})}),(()=>{i.expected.push({frame:this.frame,notification:u})}))}),n)}}}expectSubscriptions(e){const s={actual:e,ready:!1};this.flushTests.push(s);const{runMode:t}=this;return{toBe(e){const r="string"==typeof e?[e]:e;s.ready=!0,s.expected=r.map((e=>x.parseMarblesAsSubscriptions(e,t))).filter((e=>e.subscribedFrame!==1/0))}}}flush(){const e=this.hotObservables;for(;e.length>0;)e.shift().setup();super.flush(),this.flushTests=this.flushTests.filter((e=>!e.ready||(this.assertDeepEqual(e.actual,e.expected),!1)))}static parseMarblesAsSubscriptions(e,s=!1){if("string"!=typeof e)return new w(1/0);const t=[...e],r=t.length;let i=-1,a=1/0,n=1/0,o=0;for(let e=0;e<r;e++){let r=o;const c=e=>{r+=e*this.frameTimeFactor},h=t[e];switch(h){case" ":s||c(1);break;case"-":c(1);break;case"(":i=o,c(1);break;case")":i=-1,c(1);break;case"^":if(a!==1/0)throw new Error("found a second subscription point '^' in a subscription marble diagram. There can only be one.");a=i>-1?i:o,c(1);break;case"!":if(n!==1/0)throw new Error("found a second unsubscription point '!' in a subscription marble diagram. There can only be one.");n=i>-1?i:o;break;default:if(s&&h.match(/^[0-9]$/)&&(0===e||" "===t[e-1])){const s=t.slice(e).join("").match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);if(s){e+=s[0].length-1;const t=parseFloat(s[1]);let r;switch(s[2]){case"ms":r=t;break;case"s":r=1e3*t;break;case"m":r=1e3*t*60}c(r/this.frameTimeFactor);break}}throw new Error("there can only be '^' and '!' markers in a subscription marble diagram. Found instead '"+h+"'.")}o=r}return n<0?new w(a):new w(a,n)}static parseMarbles(e,s,t,r=!1,i=!1){if(-1!==e.indexOf("!"))throw new Error('conventional marble diagrams cannot have the unsubscription marker "!"');const a=[...e],n=a.length,o=[],l=i?e.replace(/^[ ]+/,"").indexOf("^"):e.indexOf("^");let d=-1===l?0:l*-this.frameTimeFactor;const b="object"!=typeof s?e=>e:e=>r&&s[e]instanceof v?s[e].messages:s[e];let m=-1;for(let e=0;e<n;e++){let s=d;const r=e=>{s+=e*this.frameTimeFactor};let n;const l=a[e];switch(l){case" ":i||r(1);break;case"-":case"^":r(1);break;case"(":m=d,r(1);break;case")":m=-1,r(1);break;case"|":n=u,r(1);break;case"#":n=h(t||"error"),r(1);break;default:if(i&&l.match(/^[0-9]$/)&&(0===e||" "===a[e-1])){const s=a.slice(e).join("").match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);if(s){e+=s[0].length-1;const t=parseFloat(s[1]);let i;switch(s[2]){case"ms":i=t;break;case"s":i=1e3*t;break;case"m":i=1e3*t*60}r(i/this.frameTimeFactor);break}}n=c(b(l)),r(1)}n&&o.push({frame:m>-1?m:d,notification:n}),d=s}return o}createAnimator(){if(!this.runMode)throw new Error("animate() must only be used in run mode");let e,s=0;return{animate:s=>{if(e)throw new Error("animate() must not be called more than once within run()");if(/[|#]/.test(s))throw new Error("animate() must not complete or error");e=new Map;const t=x.parseMarbles(s,void 0,void 0,void 0,!0);for(const s of t)this.schedule((()=>{const s=this.now(),t=Array.from(e.values());e.clear();for(const e of t)e(s)}),s.frame)},delegate:{requestAnimationFrame(t){if(!e)throw new Error("animate() was not called within run()");const r=++s;return e.set(r,t),r},cancelAnimationFrame(s){if(!e)throw new Error("animate() was not called within run()");e.delete(s)}}}}createDelegates(){let e=0;const s=new Map,t=()=>{const e=this.now(),r=Array.from(s.values()).filter((({due:s})=>s<=e)),i=r.filter((({type:e})=>"immediate"===e));if(i.length>0){const{handle:e,handler:t}=i[0];return s.delete(e),void t()}const a=r.filter((({type:e})=>"interval"===e));if(a.length>0){const s=a[0],{duration:r,handler:i}=s;return s.due=e+r,s.subscription=this.schedule(t,r),void i()}const n=r.filter((({type:e})=>"timeout"===e));if(n.length>0){const{handle:e,handler:t}=n[0];return s.delete(e),void t()}throw new Error("Expected a due immediate or interval")};return{immediate:{setImmediate:r=>{const i=++e;return s.set(i,{due:this.now(),duration:0,handle:i,handler:r,subscription:this.schedule(t,0),type:"immediate"}),i},clearImmediate:e=>{const t=s.get(e);t&&(t.subscription.unsubscribe(),s.delete(e))}},interval:{setInterval:(r,i=0)=>{const a=++e;return s.set(a,{due:this.now()+i,duration:i,handle:a,handler:r,subscription:this.schedule(t,i),type:"interval"}),a},clearInterval:e=>{const t=s.get(e);t&&(t.subscription.unsubscribe(),s.delete(e))}},timeout:{setTimeout:(r,i=0)=>{const a=++e;return s.set(a,{due:this.now()+i,duration:i,handle:a,handler:r,subscription:this.schedule(t,i),type:"timeout"}),a},clearTimeout:e=>{const t=s.get(e);t&&(t.subscription.unsubscribe(),s.delete(e))}}}}run(e){const s=x.frameTimeFactor,t=this.maxFrames;x.frameTimeFactor=1,this.maxFrames=1/0,this.runMode=!0;const r=this.createAnimator(),i=this.createDelegates();l.delegate=r.delegate,d.delegate=this,b.delegate=i.immediate,m.delegate=i.interval,f.delegate=i.timeout,p.delegate=this;const a={cold:this.createColdObservable.bind(this),hot:this.createHotObservable.bind(this),flush:this.flush.bind(this),time:this.createTime.bind(this),expectObservable:this.expectObservable.bind(this),expectSubscriptions:this.expectSubscriptions.bind(this),animate:r.animate};try{const r=e(a);return this.flush(),r}finally{x.frameTimeFactor=s,this.maxFrames=t,this.runMode=!1,l.delegate=void 0,d.delegate=void 0,b.delegate=void 0,m.delegate=void 0,f.delegate=void 0,p.delegate=void 0}}}e("T",x),x.frameTimeFactor=10}}}));
